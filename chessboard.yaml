esphome:
  name: chessboard
  friendly_name: chessboard

  includes:
    - chess_validator.h
  

  # Do some initialition work
  on_boot:
    - priority: 400
      then:
      - script.execute: reset_all_values 
    - priority: 700
      then:
        - lambda: |-
            id(redraw_displays).execute();

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: WARN

api:
  reboot_timeout: 0s

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True

  ap:
    ssid: "chessboard"
    password: "chessboard"

# HTTP request component
http_request:
  timeout: 10s
  verify_ssl: false 

captive_portal:

# Enable web server
web_server:
  port: 80
  include_internal: False
  version: 3
  log: false
  ota: false
  local: true
  sorting_groups:
    - id: sorting_group_settings
      name: "Game Settings"
      sorting_weight: 10
    - id: sorting_group_board
      name: "Board"
      sorting_weight: 20
    - id: sorting_group_pgn
      name: "PGN"
      sorting_weight: 30
    - id: sorting_group_sensors
      name: "Sensors"
      sorting_weight: 50
    - id: sorting_group_simulation
      name: "DEBUG"
      sorting_weight: 100
    - id: sorting_group_lichess
      name: "Lichess"
      sorting_weight: 40
    - id: sorting_group_system
      name: "System"
      sorting_weight: 70
time:
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Berlin"  


substitutions:
  # shorter delay and high amount of samples works best
  adc_n_sampels: '50' 
  attenuation_value: 12dB
  hall_sensor_intervall_game: 500ms 
  hall_sensor_intervall_idle: 1s
  delay_before_adc_reading: '2'

i2c:
  sda: GPIO21
  scl: GPIO22
  id: i2c0
  scan: false
  frequency: 200kHz 
  # max frequency of pcf8574 is 100kHz, we try higher frequencies for faster display update
  

tca9548a:
  - address: 0x70
    id: i2c_mux_b
    i2c_id: i2c0
    channels:
      - bus_id: i2c_mux_b_display
        channel: 7
      - bus_id: i2c_mux_b_buttons
        channel: 2

  - address: 0x77
    id: i2c_mux_w
    i2c_id: i2c0
    channels:
      - bus_id: i2c_mux_w_display
        channel: 7

pcf8574:
  - id: 'pcf8574_b'
    address: 0x20
    i2c_id: i2c_mux_b_buttons
    pcf8575: false
  - id: 'pcf8574_w'
    address: 0x27
    i2c_id: i2c0
    pcf8575: false

font:
  - file: "gfonts://Roboto"
    id: roboto_10
    size: 10
  - file: "gfonts://Roboto"
    id: roboto_12
    size: 12
  - file: "gfonts://Roboto"
    id: roboto_14
    size: 14
  - file: "gfonts://Roboto"
    id: roboto_24
    size: 24
  - file: "gfonts://Roboto"
    id: roboto_30
    size: 30
  - file: "gfonts://Roboto"
    id: roboto_32
    size: 32

globals:

  # some constants
  - id: chess_field_names
    type: std::array<std::string, 64>
    initial_value: |-
      {
        "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
        "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
        "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
        "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
        "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
        "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
        "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
        "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1"
      }

  - id: chess_field_indexes
    type: std::map<std::string, int>
    initial_value: |-
      {
        {"a8", 0}, {"b8", 1}, {"c8", 2}, {"d8", 3}, {"e8", 4}, {"f8", 5}, {"g8", 6}, {"h8", 7},
        {"a7", 8}, {"b7", 9}, {"c7", 10}, {"d7", 11}, {"e7", 12}, {"f7", 13}, {"g7", 14}, {"h7", 15},
        {"a6", 16}, {"b6", 17}, {"c6", 18}, {"d6", 19}, {"e6", 20}, {"f6", 21}, {"g6", 22}, {"h6", 23},
        {"a5", 24}, {"b5", 25}, {"c5", 26}, {"d5", 27}, {"e5", 28}, {"f5", 29}, {"g5", 30}, {"h5", 31},
        {"a4", 32}, {"b4", 33}, {"c4", 34}, {"d4", 35}, {"e4", 36}, {"f4", 37}, {"g4", 38}, {"h4", 39},
        {"a3", 40}, {"b3", 41}, {"c3", 42}, {"d3", 43}, {"e3", 44}, {"f3", 45}, {"g3", 46}, {"h3", 47},
        {"a2", 48}, {"b2", 49}, {"c2", 50}, {"d2", 51}, {"e2", 52}, {"f2", 53}, {"g2", 54}, {"h2", 55},
        {"a1", 56}, {"b1", 57}, {"c1", 58}, {"d1", 59}, {"e1", 60}, {"f1", 61}, {"g1", 62}, {"h1", 63}
      }

  - id: chess_symbols
    type: std::map<char, std::string>
    initial_value: |- 
      /*
        Standard spaces (" ") can be too narrow. Instead, use:
        Non-Breaking Space (\u00A0) → " "
        Thin Space (\u2009) → " "
        En Space (\u2002) → " "
        Full-Width Space (\u3000) → "　"
        ♔	U+2654	White Chess King
        ♕	U+2655	White Chess Queen
        ♖	U+2656	White Chess Rook
        ♗	U+2657	White Chess Bishop
        ♘	U+2658	White Chess Knight
        ♙	U+2659	White Chess Pawn
        ♚	U+265A	Black Chess King
        ♛	U+265B	Black Chess Queen
        ♜	U+265C	Black Chess Rook
        ♝	U+265D	Black Chess Bishop
        ♞	U+265E	Black Chess Knight
        ♟	U+265F	Black Chess Pawn
      */
      {
        {'K', "\u2002\u2654\u2002"},
        {'Q', "\u2002\u2655\u2002"},
        {'R', "\u2002\u2656\u2002"},
        {'B', "\u2002\u2657\u2002"},
        {'N', "\u2002\u2658\u2002"},
        {'P', "\u2002\u2659\u2002"},
        {'k', "\u2002\u265A\u2002"},
        {'q', "\u2002\u265B\u2002"},
        {'r', "\u2002\u265C\u2002"},
        {'b', "\u2002\u265D\u2002"},
        {'n', "\u2002\u265E\u2002"},
        {'p', "\u2002\u265F\u2002"},
        {'0', "\u2002\u3000\u2002"}
      }

  - id: chess_symbols_telegram
    type: std::map<char, std::string>
    initial_value: |- 
      /*
        Standard spaces (" ") can be too narrow. Instead, use:
        Non-Breaking Space (\u00A0) → " "
        Thin Space (\u2009) → " "
        En Space (\u2002) → " "
        Full-Width Space (\u3000) → "　"
        ♔	U+2654	White Chess King
        ♕	U+2655	White Chess Queen
        ♖	U+2656	White Chess Rook
        ♗	U+2657	White Chess Bishop
        ♘	U+2658	White Chess Knight
        ♙	U+2659	White Chess Pawn
        ♚	U+265A	Black Chess King
        ♛	U+265B	Black Chess Queen
        ♜	U+265C	Black Chess Rook
        ♝	U+265D	Black Chess Bishop
        ♞	U+265E	Black Chess Knight
        ♟	U+265F	Black Chess Pawn
         	U+2002	En Space
         	U+2003	Em Space
         	U+2004	Three-Per-Em Space
         	U+2005	Four-Per-Em Space
         	U+2006	Six-Per-Em Space
         	U+2007	Figure Space
         	U+2008	Punctuation Space
         	U+2009	Thin Space
         	U+200A	Hair Space
         	U+202F	Narrow No-Break Space (NNBSP)
         	U+205F	Medium Mathematical Space (MMSP)
      */
      {
        {'K', "\u2009\u200A\u200A\u200A\u200A\u2654\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'k', "\u2009\u200A\u200A\u200A\u200A\u265A\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'Q', "\u200A\u200A\u200A\u200A\u200A\u200A\u2655\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'q', "\u200A\u200A\u200A\u200A\u200A\u200A\u265B\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'R', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u2656\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'r', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u265C\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'B', "\u200A\u200A\u200A\u200A\u200A\u200A\u2657\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'b', "\u200A\u200A\u200A\u200A\u200A\u200A\u265D\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'N', "\u200A\u200A\u200A\u200A\u200A\u200A\u2658\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'n', "\u200A\u200A\u200A\u200A\u200A\u200A\u265E\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'P', "\u200A\u200A\u200A\u200A\u200A\u200A\u2659\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},    
        {'p', "\u200A\u200A\u200A\u200A\u265F\u200A\u200A\u200A\u200A"},

        {'0', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A"}
      }
  # order of hall sensors from A8 to H1
  - id: hall_sensor_order
    type: std::array<int, 64>
    initial_value: |-
      {
        23,  7, 11, 27, 10, 30, 62, 58,
        19,  3, 15, 31, 26, 46, 14, 42,
        43, 51, 59, 39, 54, 34, 2,  6,
        47, 55, 63, 35, 38, 18, 50, 22,
        41, 25, 9,  49, 8,  28, 60, 44,
        33,  1, 17, 57, 12, 56, 24, 40,
        21, 37, 53, 13, 52, 32,  0, 16,
        29, 61, 45,  5, 48,  4, 36, 20
      }

  # Variables for voltage-field
  - id: voltage_field_offset
    type: std::array<float, 64>
    initial_value: |-
      {
        2.40, 2.54, 2.50, 2.46, 2.43, 2.53, 2.42, 2.38,
        2.48, 2.45, 2.50, 2.44, 2.48, 2.44, 2.43, 2.43,
        2.52, 2.47, 2.42, 2.43, 2.45, 2.51, 2.45, 2.47,
        2.46, 2.44, 2.53, 2.55, 2.35, 2.41, 2.39, 2.50, 
        2.40, 2.39, 2.55, 2.46, 2.38, 2.41, 2.43, 2.49,
        2.48, 2.46, 2.40, 2.50, 2.52, 2.42, 2.51, 2.45,
        2.50, 2.44, 2.45, 2.53, 2.54, 2.55, 2.46, 2.47,
        2.42, 2.45, 2.53, 2.51, 2.47, 2.43, 2.53, 2.42
      }

  - id: voltage_field_detection_threshold
    type: std::array<float, 64>
    initial_value: |-
      {
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
        0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25
      }

  - id: voltage_field_drift
    type: float
    initial_value: '0.00'

  # Variables for FEN
  - id: fen_black
    type: std::array<std::string, 6>
    initial_value: |-
      {
        "p","n","b","q","r","k"
      }

  - id: fen_white
    type: std::array<std::string, 6>
    initial_value: |-
      {
        "P","N","B","Q","R","K"
      }

  # Variables for FEN
  - id: fen_position_init
    type: std::array<std::string, 72>
    initial_value: |-
      {
        "r","n","b","q","k","b","n","r",
        "p","p","p","p","p","p","p","p",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "P","P","P","P","P","P","P","P",
        "R","N","B","Q","K","B","N","R",
        "w","K","Q","k","q", "-", "0", "1"
      }

  - id: fen_position_last
    type: std::array<std::string, 72>
    initial_value: '{""}'

  - id: fen_position_last_string
    type: std::string
    initial_value: '""'

  - id: fen_position_new_string
    type: std::string
    initial_value: '""'

  - id: fen_position_current
    type: std::array<std::string, 72>
    initial_value: '{""}'

  - id: fen_position_chessboard
    type: std::string
    initial_value: '""'

  - id: fen_enpassant_index
    type: int
    initial_value: '-1'

  - id: fen_position_take_back
    type: std::array<std::string, 72>
    initial_value: '{""}'
  
  # Variables for RAW-position
  - id: raw_position_init
    type: std::array<int, 64>
    initial_value: |-
      {
        -1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1
      }

  - id: raw_position_take_back
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_last
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_current
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_differences
    type: std::array<int, 64>
    initial_value: '{0}'


  - id: voltage_field_current
    type: std::array<float, 64>
    initial_value: '{0.0}'

  - id: pgn_history
    type: std::string
    initial_value: ''    

  - id: pgn_history_take_back
    type: std::string
    initial_value: '' 

  - id: pgn_full
    type: std::string
    initial_value: ''

  - id: valid_move
    type: bool
    initial_value: 'false'

  - id: white_to_move
    type: bool
    initial_value: 'true'

  - id: game_running
    type: bool
    initial_value: 'false'

  - id: move_to_store_flag
    type: bool
    initial_value: 'false'

  - id: changed_position
    type: bool
    initial_value: 'false'

  - id: lichess_game_running
    type: bool
    initial_value: 'false'

  - id: lichess_is_my_color_white
    type: bool
    initial_value: 'true'

  - id: lichess_opponent_name
    type: std::string
    initial_value: '""'

  - id: moved_piece
    type: std::string
    initial_value: ''  

  - id: halfmove_counter
    type: int
    initial_value: '0'

  - id: halfmove_or_capture_counter
    type: int
    initial_value: '0'

  - id: last_move_pgn_take_back
    type: std::string
    initial_value: ''

  - id: last_move_pgn
    type: std::string
    initial_value: ''

  - id: last_move_pgn_additional
    type: std::string
    initial_value: ''

  - id: current_move_from
    type: int
    initial_value: '0'

  - id: current_move_to
    type: int
    initial_value: '0'

  - id: current_move_type
    type: std::string
    initial_value: ''

  - id: current_move_uci
    type: std::string
    initial_value: ''

  - id: current_move_uci_lichess
    type: std::string
    initial_value: ''

  - id: time_control_duration
    type: int
    initial_value: '900'

  - id: time_control_increment
    type: int
    initial_value: '10'

  - id: time_control_timer_black
    type: int
    initial_value: '900'

  - id: time_control_timer_white
    type: int
    initial_value: '900'

  - id: n_queens_white
    type: int
    initial_value: '1'

  - id: n_queens_black
    type: int
    initial_value: '1'

  - id: default_pawn_promotion_to
    type: std::string
    initial_value: '"Q"' 

  - id: chessboard_token_a
    type: std::string
    initial_value: !secret chessboard_token_a
  - id: chessboard_token_b
    type: std::string
    initial_value: !secret chessboard_token_b
  - id: chessboard_token_c
    type: std::string
    initial_value: !secret chessboard_token_c
  - id: chessboard_token_current
    type: std::string
    initial_value: ""
  - id: chessboard_token_opponent
    type: std::string
    initial_value: ""

  - id: last_move_white
    type: std::string
    initial_value: '""'

  - id: last_move_black
    type: std::string
    initial_value: '""'

  - id: display_message_white
    type: std::string
    initial_value: '""'

  - id: display_message_black
    type: std::string
    initial_value: '""'

  # 0 - menu, 1 - clock, 2 - message
  - id: oled_white_acitve_page
    type: int
    initial_value: '2'

  - id: oled_black_acitve_page
    type: int
    initial_value: '2'

  - id: differences_sum
    type: int
    initial_value: '0'

  - id: differences_sum_abs
    type: int
    initial_value: '0'

  - id: differences_n_changes
    type: int
    initial_value: '0'

  - id: differences_n_pieces
    type: int
    initial_value: '0'

  - id: initial_position_set_black
    type: bool
    initial_value: 'false'

  - id: initial_position_set_white
    type: bool
    initial_value: 'false'

  - id: debug_mode
    type: bool
    initial_value: 'true'


# we updating all the time the values of hall sensors
interval:
  - interval: $hall_sensor_intervall_game
    then:
      - lambda: |-
          if (id(game_running)) {
            // perform main loop
            id(main_loop).execute();
          }
  - interval: $hall_sensor_intervall_idle
    then:
      - lambda: |-
          if (!id(game_running)) {
            // check position of the pieces 
            id(main_loop).execute();
            // we have to update lichess_game_id if meanwhile a new id was sent by stream
            id(lichess_game_id).update();
            // update variables, if black & white init-positions are set
            id(check_init_position_set).execute();
            // turn on red-led if not
            id(led_update_initial_position_set).execute();
          }
  - interval: 1000ms
    then:
      - script.execute: update_timer
      - script.execute: check_opponent_at_board_select

display:
  - platform: ssd1306_i2c
    id: oled_white
    model: "SSD1306 128x32"
    flip_y: False
    flip_x: False
    address: 0x3C
    i2c_id: i2c_mux_w_display
    update_interval: 60s
    lambda: |-
      // 0 - menu, 1 - clock, 2 - message
      if (id(oled_white_acitve_page) == 1) { // clock

          std::string time_to_show_w = id(timer_white).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_w.c_str());

          std::string time_to_show_b = id(timer_black).state;
          it.printf(85, 0, id(roboto_12), time_to_show_b.c_str());

          std::string move_to_show = id(last_move_black);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());

      } else if (id(oled_white_acitve_page) == 0) { // menu

          const auto display_width = it.get_width();
          const auto display_height = it.get_height();
          it.menu(0, 0, id(my_menu), display_width, display_height);

        } else {  // message

          std::string json_str = id(display_message_white);
          StaticJsonDocument<200> root;
          deserializeJson(root, json_str);

          if (root.containsKey("n_lines")) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }
        }

  - platform: ssd1306_i2c
    id: oled_black
    flip_y: False
    flip_x: False
    model: "SSD1306 128x32"
    address: 0x3C
    i2c_id: i2c_mux_b_display
    update_interval: 60s
    lambda: |-
      // 0 - menu, 1 - clock, 2 - message
      if (id(oled_black_acitve_page) == 1) {  // clock

          std::string time_to_show_b = id(timer_black).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_b.c_str());

          std::string time_to_show_w = id(timer_white).state;
          it.printf(85, 0, id(roboto_12), time_to_show_w.c_str());

          std::string move_to_show = id(last_move_white);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());

      } else if (id(oled_black_acitve_page) == 0) { // menu

          const auto display_width = it.get_width();
          const auto display_height = it.get_height();
          it.menu(0, 0, id(my_menu), display_width, display_height);

        } else { // message

          std::string json_str = id(display_message_black);          
          StaticJsonDocument<200> root;
          deserializeJson(root, json_str);

          if (root.containsKey("n_lines")) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }
        }

# Declare a LCD menu
graphical_display_menu:
  id: my_menu
  # display: oled_test
  font: roboto_10
  active: false
  mode: rotary
  on_redraw:
    then:
      - lambda: |-
          id(redraw_displays).execute();
  items:
    - type: select
      immediate_edit: false
      text: 'TIMER'
      select: chess_time_control
    - type: select
      immediate_edit: false
      text: 'PROMOTION'
      select: pawn_promotion
    - type: menu
      text: 'LICHESS'
      items:
        - type: command
          text: 'New game'
          on_value:
            then:
              - display_menu.show_main:   my_menu
              - display_menu.hide:  my_menu 
              - lambda: |-
                  id(lichess_create_new_game).execute();
        - type: command
          text: 'Resign'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"resign\"}");
        - type: command
          text: 'Claim victory'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"claim-victory\"}");
        - type: command
          text: 'Draw (yes)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"draw\", \"parameter\": \"yes\"}");
        - type: command
          text: 'Draw (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"draw\", \"parameter\": \"no\"}");
        - type: command
          text: 'Takeback (yes)'
          on_value:
            then:
              - lambda: |-
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"takeback\", \"parameter\": \"yes\"}");
        - type: command
          text: 'Takeback (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"takeback\", \"parameter\": \"no\"}");
        - type: command
          text: 'Abort game'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"abort\"}");
        - type: select
          immediate_edit: false
          text: 'User'
          select: lichess_account
        - type: select
          immediate_edit: false
          text: 'Opponent'
          select: lichess_opponent
        - type: select
          immediate_edit: False
          text: 'Opponent at board'
          select: lichess_opponent_at_board
        - type: back
          text: 'Back'
    - type: command
      text: 'PGN SEND'
      on_value:
        then:
          - lambda: |-
              id(send_telegram_message).execute();
    - type: command
      text: 'TAKE BACK'
      on_value:
        then:
          - lambda: |-
              id(take_back).execute();
    - type: command
      text: 'Reset game'
      on_value:
        then:
          - lambda: |-
              id(reset_all_values).execute();
    - type: command
      text: 'Restart Board'
      on_value:
        then:
          - lambda: |-
              id(device_factory_reset).press();

# Define internal outputs
output:
  # outputs for analog multiplexer
  - platform: gpio
    pin: GPIO14
    id: output_s1
  - platform: gpio
    pin: GPIO25
    id: output_s2
  - platform: gpio
    pin: GPIO26
    id: output_s3
  - platform: gpio
    pin: GPIO27
    id: output_s4
# beep
  - platform: gpio
    id: beep_switch
    pin:
      number: 4
      mode:
        output: true
      inverted: false

switch:

# LED color to move
  - platform: gpio
    id: led_white_to_move
    icon: mdi:led-on
    name: White to move
    pin:
      pcf8574: pcf8574_w
      number: 5
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_to_move
    icon: mdi:led-on
    name: Black to move
    pin:
      pcf8574: pcf8574_b
      number: 2
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_white_nonvalid_move
    icon: mdi:led-on
    name: White (non valid move)
    pin:
      pcf8574: pcf8574_w
      number: 7
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_white_valid_move
    icon: mdi:led-on
    name: White (valid move)
    pin:
      pcf8574: pcf8574_w
      number: 6
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_nonvalid_move
    icon: mdi:led-on
    name: Black (non valid move)
    pin:
      pcf8574: pcf8574_b
      number: 0
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_valid_move
    icon: mdi:led-on
    name: Black (valid move)
    pin:
      pcf8574: pcf8574_b
      number: 1
      mode:
        output: true
      inverted: true
    internal: true

button:
  - platform: factory_reset
    name: Restart with Factory Default Settings
    id: device_factory_reset
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 100
  - platform: template
    name: "PGN to telegram"
    id: pgn_to_telegram
    on_press: 
      then:
        lambda: |-
          id(send_telegram_message).execute();
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: -1
  - platform: template
    name: New Lichess Game
    id: lichess_new_game_button
    on_press:
      then:
        - lambda: |-
            id(lichess_create_new_game).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: -1


binary_sensor:
  - platform: gpio
    name: "White finished"
    id: button_white_finished
    pin:
      pcf8574: pcf8574_w
      number: 4
      mode:
        input: true
      inverted: true
    on_press:
      then:
        - lambda: |-
            id(button_white_finished_script).execute();
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_b
      number: 3
      mode:
        input: true
      inverted: true
    name: "Black finished"
    id: button_black_finished
    on_press:
      then:
        - lambda: |-
            id(button_black_finished_script).execute();
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 0
      mode:
        input: true
      inverted: true
    name: "Back"
    id: button_back
    internal: true
    on_press:
      then:
        - display_menu.show_main:   my_menu
        - display_menu.hide:  my_menu 
        - lambda: |-
            if (id(halfmove_counter) > 0) {
              // start the clock during a game
              id(game_running) = true;
              // the game can be also started by the pause button
              id(led_update_color_to_move).execute();
              id(oled_show_page_clock).execute();
            } else {
              id(oled_show_page_message).execute();
            }

  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 1
      mode:
        input: true
      inverted: true
    name: "Up"
    id: button_up
    on_press:
      then:
        - display_menu.up: my_menu
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 2
      mode:
        input: true
      inverted: true
    name: "Down"
    id: button_down
    on_press:
      then:
        - display_menu.down: my_menu
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 3
      mode:
        input: true
      inverted: true
    name: "Set"
    id: button_set
    on_press:
      then:
        - if:
              condition:
                display_menu.is_active: my_menu
              then:
                - display_menu.enter: my_menu
              else:
                - display_menu.show:  my_menu
                - lambda: |-
                    id(game_running) = !id(game_running);
                    id(led_update_color_to_move).execute(); 
                    id(oled_show_page_menu).execute();
    internal: true
  - platform: template
    name: initial_position_set
    id: initial_position_set
    internal: true
    lambda: |-
      if (id(game_running)) {
        return false;
      } else {
        return id(initial_position_set_black) && id(initial_position_set_white);
      }
    on_press:
      then:
        - lambda: |-
            id(post_game_operation).execute();
            // notfiy -> ready for new game

select:
  - platform: template
    name: "Time Control"
    id: chess_time_control
    optimistic: true
    options:
      - "Blitz (3+0)"
      - "Blitz (3+2)"
      - "Blitz (5+0)"
      - "Blitz (5+3)"
      - "Rapid (10+0)"
      - "Rapid (10+5)"
      - "Rapid (15+10)"
      - "Classical (30+0)"
      - "Classical (60+0)"
      - "Classical (90+30)"
    initial_option: "Rapid (15+10)"
    on_value: 
      then:
        - lambda: |-
            // not during the game
            if (id(halfmove_counter) == 0) {
              if (x == "Blitz (3+0)") {
                // Set time control to Blitz (3+0)
                id(time_control_duration) = 180;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (3+2)") {
                // Set time control to Blitz (3+2)
                id(time_control_duration) = 180;
                id(time_control_increment) = 2;
              } else if (x == "Blitz (5+0)") {
                // Set time control to Blitz (5+0)
                id(time_control_duration) = 300;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (5+3)") {
                // Set time control to Blitz (5+3)
                id(time_control_duration) = 300;
                id(time_control_increment) = 3;
              } else if (x == "Rapid (10+0)") {
                // Set time control to Rapid (10+0)
                id(time_control_duration) = 600;
                id(time_control_increment) = 0;
              } else if (x == "Rapid (10+5)") {
                // Set time control to Rapid (10+5)
                id(time_control_duration) = 600;
                id(time_control_increment) = 5;
              } else if (x == "Rapid (15+10)") {
                // Set time control to Rapid (15+10)
                id(time_control_duration) = 900;
                id(time_control_increment) = 10;
              } else if (x == "Classical (30+0)") {
                // Set time control to Classical (30+0)
                id(time_control_duration) = 1800;
                id(time_control_increment) = 0;
              } else if (x == "Classical (60+0)") {
                // Set time control to Classical (60+0)
                id(time_control_duration) = 3600;
                id(time_control_increment) = 0;
              } else if (x == "Classical (90+30)") {
                // Set time control to Classical (90+30)
                id(time_control_duration) = 5400;
                id(time_control_increment) = 30;
              }

              id(time_control_timer_black) = id(time_control_duration);
              id(time_control_timer_white) = id(time_control_duration);

              id(timer_black).update();
              id(timer_white).update();

            } else {
              // select previos selected option
            }

            // overwrite display message, if we are in init state
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"" + x + "\"}";
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"" + x + "\"}";
            // we dont need to activate the message screen here, just overwrite values
            id(redraw_displays).execute();
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 1
  - platform: template
    name: "Promotion to"
    id: pawn_promotion
    optimistic: true
    options:
      - "Queen"
      - "Rook"
      - "Bishop"
      - "Knight"
    initial_option: "Queen"
    on_value: 
      then:
        lambda: |-
          if (x == "Queen") {
            // Set promotion to Queen
            id(default_pawn_promotion_to) = "Q";
          } else if (x == "Rook") {
            // Set promotion to Rook
            id(default_pawn_promotion_to) = "R";
          } else if (x == "Bishop") {
            // Set promotion to Bishop
            id(default_pawn_promotion_to) = "B";
          } else if (x == "Knight") {
            // Set promotion to Knight
            id(default_pawn_promotion_to) = "N";
          }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 2
  - platform: template
    name: "Telegram notification"
    id: telegram_notification
    optimistic: true
    options:
      - "yes"
      - "no"
    initial_option: "yes"
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 3
  - platform: template
    name: "Account"
    id: lichess_account
    internal: False
    optimistic: true
    options:
      - !secret chessboard_player_a
      - !secret chessboard_player_b
      - !secret chessboard_player_c
    initial_option: !secret chessboard_player_c
    on_value: 
      then:
        lambda: |-
          id(update_lichess_token).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 1
  - platform: template
    name: "Opponent"
    id: lichess_opponent
    internal: False
    optimistic: true
    options:
      - !secret chessboard_opponent_a
      - !secret chessboard_opponent_b
      - !secret chessboard_opponent_c
      - "random"
      - "AI_1"
      - "AI_2"
      - "AI_3"
      - "AI_4"
      - "AI_5"
      - "AI_6"
      - "AI_7"
      - "AI_8"
    initial_option: AI_1
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 2
  - platform: template
    name: "Color"
    id: lichess_seek_color
    internal: False
    optimistic: true
    options:
      - "random"
      - "white"
      - "black"
    initial_option: "random"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 3
  - platform: template
    name: "Rated"
    id: lichess_seek_rated
    internal: False
    optimistic: true
    options:
      - "rated"
      - "not rated"
    initial_option: "not rated"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 4
  - platform: template
    name: "Opponent at board"
    id: lichess_opponent_at_board
    internal: False
    optimistic: true
    options:
      - "yes"
      - "no"
    initial_option: "no"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 6
sensor:
  - platform: adc
    pin: GPIO34
    name: current_hall_sensor_1
    id: current_hall_sensor_1
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO35
    name: current_hall_sensor_2
    id: current_hall_sensor_2
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO36
    name: current_hall_sensor_3
    id: current_hall_sensor_3
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO39
    name: current_hall_sensor_4
    id: current_hall_sensor_4
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never

text_sensor:

  # used just to define out-sensor for ha to be set as ha-input sensor
  - platform: template
    name: "Lichess Last Move (out)"
    id: lichess_last_move
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 7

  - platform: homeassistant
    name: "Lichess Last Move"
    id: lichess_last_move_in
    entity_id: sensor.chessboard_lichess_last_move_out
    internal: false
    on_value:
      then:
        - lambda: |-
            id(lichess_handle_last_move).execute();
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 4

  # used just to define out-sensor for ha to be set as ha-input sensor
  - platform: template
    name: "Lichess Last Event (out)"
    id: lichess_last_event
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 6

  - platform: homeassistant
    name: "Lichess Last Event"
    id: lichess_last_event_in
    entity_id: sensor.chessboard_lichess_last_event_out
    internal: false
    on_value:
      then:
        - lambda: |-
            id(lichess_handle_new_event).execute();
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 3

  - platform: template
    name: "Lichess Stream Events"
    id: lichess_stream_events
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 1

  - platform: template
    name: "Lichess Game Id"
    id: lichess_game_id
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 7

  - platform: template
    name: "Lichess Api Call"
    id: lichess_api_call
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 2

  - platform: template
    name: "Lichess Token"
    id: lichess_token
    lambda: >- 
      return id(chessboard_token_current);
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 5

  - platform: template
    name: "Hall Array Part Black"
    id: array_part_1
    internal: false
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 10
  - platform: template
    name: "Hall Array Part White"
    id: array_part_2
    internal: false
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 11
  - platform: template
    name: FEN (last)
    id: fen_position_last_string_sensor
    internal: False
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 12
    lambda: |-
      return id(fen_position_last_string);
  - platform: template
    name: FEN (new)
    id: fen_position_new_string_sensor
    internal: False
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 13
    lambda: |-
      return id(fen_position_new_string);
  - platform: template
    name: Debugger
    id: debugger_sensor
    internal: False
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 14
  - platform: template
    name: UCI
    id: current_move_uci_sensor
    internal: False
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 15
    lambda: |-
      return id(current_move_uci);      
  - platform: template
    name: "Timer (white)"
    id: timer_white
    lambda: |-
      if (id(time_control_timer_white) > 0 ) {
        int minutes = id(time_control_timer_white) / 60;
        int seconds = id(time_control_timer_white) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";        
        return e;
      }
    on_value:
      then:
        - lambda: |-
            if (x == "--:--") {
              if (id(game_running)) {
                id(game_running) = false;
                id(beep_long).execute();
              }
              id(inform_game_over).execute();
            }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 3
  - platform: template
    name: "Timer (black)"
    id: timer_black
    lambda: |-
      if (id(time_control_timer_black) > 0 ) {
        int minutes = id(time_control_timer_black) / 60;
        int seconds = id(time_control_timer_black) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";
        return e;
      }
    on_value:
      then:
        - lambda: |-
            if (x == "--:--") {
              if (id(game_running)) {
                id(game_running) = false;
                id(beep_long).execute();
              }
              id(inform_game_over).execute();
            }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 4


  - platform: template
    id: last_move_pgn_sensor
    name: "PGN Move"
    lambda: |-
      std::string pgn_move = id(last_move_pgn);
      if (pgn_move.length() > 0 ) {
        int fullmove = (int)(id(halfmove_counter) / 2.) + 1;
        if (id(halfmove_counter) % 2 == 0) {
            pgn_move += " ...";
        } else {
          pgn_move = "... " + pgn_move; 
        }
        pgn_move = std::to_string(fullmove) + ". " + pgn_move;
      }
      return pgn_move;
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 0
  - platform: template
    id: pgn_history_1
    name: "PGN_1"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      return cutted_history.substr(0, 255);
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 1
  - platform: template
    id: pgn_history_2
    name: "PGN_2"
    lambda: |-
      std::string cutted_history = id(pgn_history);      
      if (cutted_history.length() > 255) {
        return cutted_history.substr(255, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 2
  - platform: template
    id: pgn_history_3
    name: "PGN_3"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*2;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 3
  - platform: template
    id: pgn_history_4
    name: "PGN_4"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*3;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 4
  - platform: template
    id: pgn_history_5
    name: "PGN_5"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*4;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 5
  - platform: template
    id: pgn_history_6
    name: "PGN_6"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*5;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 6
  - platform: template
    id: pgn_history_7
    name: "PGN_7"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*6;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 7
  - platform: template
    id: pgn_history_8
    name: "PGN_8"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*7;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 8
  - platform: template
    id: pgn_history_9
    name: "PGN_9"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*8;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 9

  - platform: template
    name: "8"
    id: line_8
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 1

  - platform: template
    name: "7"
    id: line_7
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 2

  - platform: template
    name: "6"
    id: line_6
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 3

  - platform: template
    name: "5"
    id: line_5
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 4

  - platform: template
    name: "4"
    id: line_4
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 5

  - platform: template
    name: "3"
    id: line_3
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 6

  - platform: template
    name: "2"
    id: line_2
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 7

  - platform: template
    name: "1"
    id: line_1
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 8

script:

  - id: main_loop
    # to avoid long queues, we skip the iteration if not finished till next call
    mode: queued
    max_runs: 3 
    then:
      - lambda: |-
          // measure execution time
          int tic = 0;
          int toc = 0;
          
          if (id(debug_mode)) {
            tic = millis();  // Start time
          }

          // read hall sensors
          id(update_all_hall_sensors).execute();

          if (id(debug_mode)) {
            toc = millis() - tic;
            ESP_LOGW("TIMER", "Execution Time (hall): %d ms", toc);
          }
          
          // transform voltage to position flags (-1, 0, 1)
          id(update_raw_position_current).execute();
          // check, if we have new position in comparison to the previous
          id(compare_raw_position).execute();
          // if any changes in position
          if (id(changed_position)) {
            // calculate differences in position, to be able to calculate the move
            id(calculate_position_differences).execute();
            // transform position - differences to a move (coordinate from - to)
            id(move_validator).execute(); // update from, to, uci, valid_flag, new_fen
            // update led's valid / non valid move
            id(led_update_valid_move).execute();
            // we check, if we should store the move (i.e. button pressed, or lichess-move is applied)
            id(store_move).execute();            
          } else {
            // reset display messages, if any
            id(clear_display_messages).execute();
            // reset flags
            id(reset_validator_flags).execute();
            // same position, turn on blue
            id(led_update_color_to_move).execute();
          }

          if (id(debug_mode)) {
            // to deactivate after debuging phase
            toc = millis() - tic;
            ESP_LOGW("TIMER", "Execution Time (loop): %d ms", toc);
          }
       
  - id: button_black_finished_script
    mode: queued
    then: 
      - lambda: |-
          // only during the gave
          if (id(game_running)) {
            // if our turn, we store the move and let opponent play
            if (!id(white_to_move))
            {
              if (id(valid_move)) {                
                id(move_to_store_flag) = true;
              }    
            }
          } else if (id(halfmove_counter) == 0) {
            // at the begin of the game black can start the clock by button
            id(game_running) = true;
            // the game can be also started by the pause button
            id(led_update_color_to_move).execute();
            // show timer
            id(oled_show_page_clock).execute();
          } 
  - id: button_white_finished_script
    mode: queued
    then: 
      - lambda: |-
            // only during the gave
            if (id(game_running) && id(white_to_move) ) {
              // if our turn, we store the move and let opponent play
              if (id(valid_move)) {
                id(move_to_store_flag) = true; 
              }
            // we assume here, initial-position-set is updated by the idle iteration loop
            } else if (!id(game_running) && id(white_to_move) && !id(lichess_game_running) && id(halfmove_counter) == 0 && id(initial_position_set).state) { 
                // if initial position, white can also start the the clock
                id(game_running) = true;
                // update LEDs
                id(led_update_color_to_move).execute();
                // show timer
                id(oled_show_page_clock).execute();
            }
  - id: update_array_text
    mode: restart
    then:
      - lambda: |-
          std::string part1;
          std::string part2;
          std::string* target = &part1;

          for (size_t i = 0; i < 64; i++) {
            // Round to 2 decimal places
            int rounded = static_cast<int>(id(voltage_field_current)[i] * 100);
            float rounded_val = rounded / 100.0f;

            char buffer[6]; // Max "3.99\0"
            snprintf(buffer, sizeof(buffer), "%.2f", rounded_val);
            if (rounded >= 0) {
              *target += '+';
            }
            *target += buffer;
            *target += ((i + 1) % 8 == 0) ? '\n' : ' ';

            if (i == 31) {
              target = &part2; // Switch to second sensor
            }
          }

          id(array_part_1).publish_state(part1);
          id(array_part_2).publish_state(part2);

  - id: take_back
    then:
      - lambda: |-
          // one take back only
          if (id(pgn_history) != id(pgn_history_take_back)) {

            // if promotion to queen, we have to reduce the number of queens
            if (id(last_move_pgn).find("=Q") != std::string::npos) {
              if (id(white_to_move) && id(n_queens_white) > 1 ) {
                id(n_queens_white) -= 1;
              } else  if (!id(white_to_move) && id(n_queens_black) > 1) {
                  id(n_queens_black) -= 1;
              }
            }

            // toggle who to move
            id(white_to_move) = !id(white_to_move);

            // replace last fen by take back
            for (int i = 0; i < 72; i++) {
              id(fen_position_current)[i] = id(fen_position_last)[i];
              id(fen_position_last)[i] = id(fen_position_take_back)[i];
            };

            // replace last position by take back
            for (int i = 0; i < 64; i++) {              
              id(raw_position_current)[i] = id(raw_position_last)[i];  
              id(raw_position_last)[i] = id(raw_position_take_back)[i]; 
            };

            // counter back
            id(halfmove_counter) -= 1;

            // pgn history
            int previous_length = id(pgn_history).length();
            id(pgn_history) = id(pgn_history_take_back);
            id(last_move_pgn) = id(last_move_pgn_take_back);

            // update led
            id(led_update_color_to_move).execute();

            // update pgn sensors
            id(pgn_history_1).update();
            // update furhter sensors (take previous length)
            if ( previous_length > 255) {
              id(pgn_history_2).update();  
            }
            if ( previous_length > 510) {
              id(pgn_history_3).update();  
            }
            if ( previous_length > 765) {
              id(pgn_history_4).update();  
            }
            if ( previous_length > 1020) {
              id(pgn_history_5).update();  
            }
            if ( previous_length > 1275) {
              id(pgn_history_6).update();  
            }
            if ( previous_length > 1530) {
              id(pgn_history_7).update();  
            }
            if ( previous_length > 1785) {
              id(pgn_history_8).update();  
            }
            if ( previous_length > 2040) {
              id(pgn_history_9).update();  
            }
                
            // update further sensors
            id(update_chess_board).execute();
            id(last_move_pgn_sensor).update();
            // update fen string
            id(fen_position_last_arr_to_string).execute();
          }

  - id: update_chess_board
    mode: queued
    then:
      - lambda: |-
            //  init some variables
            const std::string border_line = "---------------------------------------------------------------";
            int line_counter = 0;
            std::string line_representation = "|";
            id(fen_position_chessboard) = border_line + "\n|";

            // iterate over current fen raw position  
            for (int i=0; i<64; i++) {
              // extend current line
              // Select first char from fen string
              line_representation += id(chess_symbols)[id(fen_position_current)[i].at(0)] + "|";
              id(fen_position_chessboard) += id(chess_symbols_telegram)[id(fen_position_current)[i].at(0)] + "|";

              if ((i + 1) % 8 == 0) { // store line
                
                int line_counter = (int)(i / 8);

                // update line
                if (line_counter == 0)
                {
                  id(line_8).publish_state(line_representation);
                } else if (line_counter == 1)
                {
                  id(line_7).publish_state(line_representation);
                } else if (line_counter == 2)
                {
                  id(line_6).publish_state(line_representation);
                } else if (line_counter == 3)
                {
                  id(line_5).publish_state(line_representation);
                } else if (line_counter == 4)
                {
                  id(line_4).publish_state(line_representation);
                } else if (line_counter == 5)
                {
                  id(line_3).publish_state(line_representation);
                } else if (line_counter == 6)
                {
                  id(line_2).publish_state(line_representation);
                } else if (line_counter == 7)
                {
                  id(line_1).publish_state(line_representation);
                }

                if  (line_counter != 7) {
                  id(fen_position_chessboard) += "\n" + border_line + "\n|";
                } else {
                  id(fen_position_chessboard) += "\n" + border_line;
                }               
                line_representation = "|";
              } 
            }

  - id: update_timer
    mode: queued
    then:
      - lambda: |-
          if ( id(game_running) ) // we are in the game or no pause pressed
          {
            if (id(white_to_move)) {
              if (id(time_control_timer_white) > 0 )
              {
                id(time_control_timer_white) -= 1;
                id(timer_white).update();
              }
            } else {
              if (id(time_control_timer_black) > 0 ) {
                id(time_control_timer_black) -= 1;
                id(timer_black).update();
              }
            }
            id(oled_white).update();
            id(oled_black).update();
          }


  - id: send_telegram_message
    then:
      - script.execute: create_full_pgn
      - http_request.post:
          url: !secret telegram_cheesboard_url
          headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_a
            text: !lambda |-
                return id(pgn_full);
              
      - http_request.post:
          url: !secret telegram_cheesboard_url
          headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_b
            text: !lambda |-
                return id(pgn_full);

  - id: create_full_pgn
    mode: queued
    then:
      - lambda: |-
          auto time = id(sntp_time).now();

          std::string year = std::to_string(time.year);
          std::string month = std::to_string(time.month);
          std::string month_prefix = (time.month < 10 ? "0" : "");
          std::string day_prefix = (time.day_of_month < 10 ? "0" : "");
          std::string day = std::to_string(time.day_of_month);
          std::string hour_prefix = (time.hour < 10 ? "0" : "");
          std::string hour = std::to_string(time.hour);
          std::string minute_prefix = (time.minute < 10 ? "0" : "");
          std::string minute = std::to_string(time.minute);
          std::string second_prefix = (time.second < 10 ? "0" : "");
          std::string second = std::to_string(time.second);

          std::string pgn_header = "[Event \"Chessboard Game\"]\n";
          pgn_header += "[Date \"" + year + "." + month_prefix  + month + "." + day_prefix  + day  + "\"]\n";
          if (id(lichess_game_running)) {
            if (id(lichess_is_my_color_white)) { 
              pgn_header += "[White \"Chessboard-Player\"]\n";
              pgn_header += "[Black \"" + id(lichess_opponent_name) + "\"]\n";              
            } else {
              pgn_header += "[White \"" + id(lichess_opponent_name) + "\"]\n"; 
              pgn_header += "[Black \"Chessboard-Player\"]\n";              
            }
          } else {
            pgn_header += "[White \"Chessboard-Player A\"]\n";
            pgn_header += "[Black \"Chessboard-Player B\"]\n";
          }
          pgn_header += "[UTCDate \"" + year + "." + month_prefix  + month + "." +  day_prefix  + day + "\"]\n";
          pgn_header += "[UTCTime \"" + hour_prefix + hour + ":" + minute_prefix + minute + ":" + second_prefix + second + "\"]\n";
          pgn_header += "[Variant \"Standard\"]\n";
          pgn_header += "[TimeControl \"" + std::to_string(id(time_control_duration)) + "+" + std::to_string(id(time_control_increment))+ "\"]";

          pgn_header += "\n\n" + id(pgn_history);
          
          if (id(fen_position_chessboard) != "") {
            pgn_header += "\n{\n";
            pgn_header += id(fen_position_chessboard) + "\n}";
          }

          id(pgn_full) = pgn_header;

  - id: post_game_operation
    then:
      - lambda: |-
          if (id(halfmove_counter) > 0 ) {
            if (id(telegram_notification).state == "yes") {
              id(send_telegram_message).execute();
            }            
            id(reset_all_values).execute();
          }

  - id: reset_all_values 
    then:
      - lambda: |-
          id(reset_fen_position).execute();
          id(reset_raw_position).execute();
          id(reset_voltage_field).execute();
          id(reset_pgn_values).execute();
          id(white_to_move) = true;
          id(game_running) = false;
          id(led_update_color_to_move).execute();          
          id(move_to_store_flag) = false;          
          id(halfmove_counter) = 0;
          id(halfmove_or_capture_counter) = 0;
          id(current_move_from) = 0;
          id(current_move_to) = 0;
          id(current_move_type) = "";
          id(current_move_uci) = "";
          id(valid_move) = false;
          id(moved_piece) = "";

          id(last_move_white) = "";
          id(last_move_black) = "";

          id(lichess_is_my_color_white) = true;
          id(lichess_game_running) = false;

          id(sync_time_control).execute();
          id(time_control_timer_black) = id(time_control_duration);
          id(time_control_timer_white) = id(time_control_duration);
          
          id(n_queens_white) = 1;
          id(n_queens_black) = 1;

          id(differences_sum) = 0;
          id(differences_sum_abs) = 0;
          id(differences_n_changes) = 0;
          id(differences_n_pieces) = 0;

          id(timer_black).update();
          id(timer_white).update();

          id(lichess_last_move).publish_state(std::string(""));
          id(lichess_game_id).publish_state(std::string("idle"));
          id(update_lichess_token).execute();
          
          id(current_move_uci_lichess) = "-";

          id(reset_display_message).execute();

  - id: reset_display_message
    then:
      - lambda: |-
          id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
          id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
          id(oled_show_page_message).execute();

  - id: redraw_displays
    then:
      - component.update: oled_white
      - component.update: oled_black

  - id: update_pgn_history
    mode: queued
    then:
      - lambda: |-
          // add current pgn to history
          if (id(white_to_move)) { // white
            std::string fullmove = std::to_string((int)(id(halfmove_counter) / 2.) + 1);
            id(pgn_history) = id(pgn_history) + fullmove + ". " + id(last_move_pgn);
          } else { // black
            id(pgn_history) = id(pgn_history) + " " + id(last_move_pgn) + "\n";
          }

          // allways update first pgn          
          id(pgn_history_1).update();
          // update furhter sensors (pgn can not be shorten in game)
          int curr_pgn_length = id(pgn_history).length();
          if ( curr_pgn_length > 255) {
            id(pgn_history_2).update();  
          }
          if ( curr_pgn_length > 510) {
            id(pgn_history_3).update();  
          }
          if ( curr_pgn_length > 765) {
            id(pgn_history_4).update();  
          }
          if ( curr_pgn_length > 1020) {
            id(pgn_history_5).update();  
          }
          if ( curr_pgn_length > 1275) {
            id(pgn_history_6).update();  
          }
          if ( curr_pgn_length > 1530) {
            id(pgn_history_7).update();  
          }
          if ( curr_pgn_length > 1785) {
            id(pgn_history_8).update();  
          }
          if ( curr_pgn_length > 2040) {
            id(pgn_history_9).update();  
          }

  - id: reset_pgn_values
    then:
      - lambda: |-
          id(last_move_pgn) = "";
          id(last_move_pgn_additional) = "";
          id(last_move_pgn_take_back) = "";
          id(pgn_history) = "";
          id(pgn_history_take_back) = "";
          id(pgn_full) = "";
          id(pgn_history_1).update();
          id(pgn_history_2).update();
          id(pgn_history_3).update();
          id(pgn_history_4).update();
          id(pgn_history_5).update();
          id(pgn_history_6).update();
          id(pgn_history_7).update();
          id(pgn_history_8).update();
          id(pgn_history_9).update();

          id(last_move_pgn_sensor).update();

  - id: reset_fen_position
    then:
      - lambda: |-
          for (int i = 0; i < 72; i++) {
            std::string curr_value = id(fen_position_init)[i];
            id(fen_position_take_back)[i] = curr_value;
            id(fen_position_last)[i] = curr_value;   
            id(fen_position_current)[i] = curr_value;          
          };
          id(fen_position_last_string) = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
          id(fen_position_new_string) = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
          id(update_chess_board).execute();
          id(fen_position_chessboard) = "";
          id(fen_position_last_string_sensor).update();
          id(fen_position_new_string_sensor).update();

  - id: reset_raw_position
    then:
      - lambda: |-
          for (int i = 0; i < 64; i++) {
            int curr_value = id(raw_position_init)[i];
            id(raw_position_take_back)[i] = curr_value; 
            id(raw_position_last)[i] = curr_value;   
            id(raw_position_current)[i] = curr_value;          
          };

  - id: reset_voltage_field
    then:
      - lambda: |-
          for (int i = 0; i < 64; i++) {
            float curr_value = id(voltage_field_offset)[i];
            id(voltage_field_current)[i] = curr_value;   
          };

  - id: check_init_position_set
    then:
      - lambda: |-
          // check black
          bool init_position = true;
          for (int i = 0; i < 16; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_init)[i])
            {
              init_position = false;
              break;
            }
          }
          id(initial_position_set_black) = init_position;
          // check white
          init_position = true;
          for (int i = 48; i < 64; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_init)[i])
            {
              init_position = false;
              break;
            }
          }
          id(initial_position_set_white) = init_position;


  - id: inform_game_over
    then:
      - lambda: |-
          // turn all led's off
          id(led_all_turn_off).execute();

          bool white_won = (bool)(id(last_move_pgn_additional) == " 1-0" || (id(last_move_pgn_additional) == "#" &&  id(white_to_move))|| id(timer_black).state == "--:--");
          bool black_won = (bool)(id(last_move_pgn_additional) == " 0-1" || (id(last_move_pgn_additional) == "#" && !id(white_to_move))|| id(timer_white).state == "--:--");
          bool draw = (bool)(id(last_move_pgn_additional) == " 1/2-1/2");

          if (white_won) { 
            id(led_white_green).execute(); // green
            id(led_black_red).execute(); // red            
            id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"LOST\"}";
            id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"WINNER\"}";
            id(pgn_history) += " 1-0";
            if (id(timer_black).state == "--:--") {
              id(pgn_history) += " {Won by time}";
            }
          }

          if (black_won) {
            id(led_black_green).execute(); // green
            id(led_white_red).execute(); // red       
            id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"WINNER\"}";
            id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"LOST\"}";
            id(pgn_history) += " 0-1";
            if (id(timer_white).state == "--:--") {
              id(pgn_history) += " {Won by time}";
            }
          }

          if (draw) {
            id(led_black_blue).execute(); // blue
            id(led_white_blue).execute(); // blue 
            id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"DRAW\"}";
            id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"DRAW\"}";
            id(pgn_history) += " 1/2-1/2";
          }

          if (!white_won && !black_won && !draw) {
            id(led_black_red).execute(); // blue
            id(led_white_red).execute(); // blue 
            id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"Aborted\"}";
            id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"Aborted\"}";
          }

          id(oled_show_page_message).execute();
          delay(3000);


  - id: sync_time_control
    then:
      - lambda: |-
          auto call = id(chess_time_control).make_call();
          if (id(time_control_duration) == 120 && id(time_control_increment) == 1) {
            call.set_option("Bullet (2+1)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 0) {
            call.set_option("Blitz (3+0)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 2) {
            call.set_option("Blitz (3+2)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 0) {
            call.set_option("Blitz (5+0)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 3) {
            call.set_option("Blitz (5+3)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 0) {
            call.set_option("Rapid (10+0)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 5) {
            call.set_option("Rapid (10+5)");
          } else if (id(time_control_duration) == 900 && id(time_control_increment) == 10) {
            call.set_option("Rapid (15+10)");
          } else if (id(time_control_duration) == 1800 && id(time_control_increment) == 0) {
            call.set_option("Classical (30+0)");
          } else if (id(time_control_duration) == 3600 && id(time_control_increment) == 0) {
            call.set_option("Classical (60+0)");
          } else if (id(time_control_duration) == 5400 && id(time_control_increment) == 30) {
            call.set_option("Classical (90+30)");
          } else {
            call.set_option("Rapid (15+10)");  // Default option
          }
          call.perform();

  - id: store_move
    mode: queued
    then:
      - lambda: |-
          // store move if valid only
          if (id(move_to_store_flag) && id(valid_move) && id(game_running)) {
            // turn off the LED ... we are storing ....
            id(led_all_turn_off).execute();
            // store previous pgn history
            id(pgn_history_take_back) = id(pgn_history);

            //update pgn sensors
            id(update_pgn_history).execute();

            // update fen move, castling, enpassant, move counts
            id(update_fen_additional_fields).execute();

            // update n queens
            id(update_number_of_queens).execute();

            // replace last fen by current fen
            for (int i = 0; i < 72; i++) {
              id(fen_position_take_back)[i] = id(fen_position_last)[i];
              id(fen_position_last)[i] = id(fen_position_current)[i];          
            };

            // update fen string current to last
            id(fen_position_last_arr_to_string).execute();

            // replace last position by current position
            for (int i = 0; i < 64; i++) {
              id(raw_position_take_back)[i] = id(raw_position_last)[i];
              id(raw_position_last)[i] = id(raw_position_current)[i];   
            };

            // show clock
            id(oled_show_page_clock).execute();

            // update last move
            if (id(white_to_move)) {
              id(last_move_white) = id(current_move_uci);
            } else {
              id(last_move_black) = id(current_move_uci);
            }

            // make lichess move
            id(lichess_make_move).execute();

            // game finished on board ?
            if (!id(lichess_game_running) && (id(last_move_pgn_additional) == "#" || id(last_move_pgn_additional).length() > 1)){
              // game over
              id(inform_game_over).execute();
              // do some post game operations
              id(post_game_operation).execute();
            } else {               
              // toggle white_to_move
              id(white_to_move) = !id(white_to_move);               
              // increase coutner of halfmoves
              id(halfmove_counter) += 1;
              // update timer
              id(time_control_add_increment).execute();              
              // reset flags
              id(reset_validator_flags).execute();
            }
            id(move_to_store_flag) = false;
          }

  - id: update_number_of_queens
    then:
      - lambda: |-
          if (id(last_move_pgn).find("=Q") != std::string::npos){
            // encrease number of queens
            if (id(white_to_move)) {
              id(n_queens_white) += 1;
            } else {
              id(n_queens_black) += 1;
            }            
          }
          // decrease number of queens
          if (id(current_move_type) == "TAKE") {
            std::string fen_name_to = id(fen_position_last)[id(current_move_to)];
            if (fen_name_to == "q") {
              id(n_queens_black) -= 1;
            }
            if (fen_name_to == "Q") {
              id(n_queens_white) -= 1;
            }
          }
  
  - id: time_control_add_increment
    then:
      - lambda: |-
          if (!id(lichess_game_running)) {
            if (id(white_to_move)){
              id(time_control_timer_white) += id(time_control_increment);
            } else {
              id(time_control_timer_black) += id(time_control_increment);
            }
          }

  - id: update_uci_notation
    then:
      - lambda: |-
          // create uci move for lichess
          std::string field_name_from = id(chess_field_names)[id(current_move_from)];
          std::string field_name_to = id(chess_field_names)[id(current_move_to)];
          std::string fen_name_from = id(fen_position_last)[id(current_move_from)];
          std::string uci_move = field_name_from + field_name_to;

          // we have to add promotion to UCI
          bool move_or_take = (bool)(id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE");
          bool promotion_move = (bool)(fen_name_from  == "P" || fen_name_from  == "p" );
          if (move_or_take && promotion_move) {  

            // white
            if (id(white_to_move) && (field_name_to.find('8') != std::string::npos)) {
              // add promotion piece to uci notation
              uci_move += id(default_pawn_promotion_to);
              std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
            }

            // black
            if (!id(white_to_move) && (field_name_to.find('1') != std::string::npos)) {
              // add promotion piece to uci notation
              uci_move += id(default_pawn_promotion_to);
              std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
            }
          }
          
          id(current_move_uci) = uci_move;
          id(current_move_uci_sensor).update();

  - id: fen_position_last_arr_to_string
    mode: queued
    then:
      - lambda: |-
            // transform array to fen-string
            std::string raw_fen;
            int emptyCount = 0;            
            for (int row = 0; row < 8; ++row) {
                for (int col = 0; col < 8; ++col) {
                    std::string piece = id(fen_position_last)[row * 8 + col];
                    if (piece == "0") {
                        ++emptyCount;
                    } else {
                        if (emptyCount > 0) {
                            raw_fen += std::to_string(emptyCount);
                            emptyCount = 0;
                        }
                      raw_fen += piece;
                    }
                }
                if (emptyCount > 0) {
                    raw_fen += std::to_string(emptyCount);
                    emptyCount = 0;
                }
                if (row < 7) raw_fen += "/";
            }

            // color to move
            raw_fen += " " + id(fen_position_last)[64];

            // castling rights
            std::string castling_part = id(fen_position_last)[65] + id(fen_position_last)[66] + id(fen_position_last)[67] + id(fen_position_last)[68];
            if (castling_part.length() > 0 ) {
              raw_fen += " " +  castling_part;
            } else {
              raw_fen += " -";
            }            

            // en passant
            raw_fen += " " + id(fen_position_last)[69];

            // half move since last take
            raw_fen += " " + id(fen_position_last)[70];

            // full move
            raw_fen += " " + id(fen_position_last)[71];

            id(fen_position_last_string) = raw_fen;
            id(fen_position_last_string_sensor).update();

  - id: check_chess_rules
    mode: queued
    then:
      - lambda: |-
          // define flag          
          bool valid_check = false;
          id(last_move_pgn_additional) = "";
          
          std::string new_fen = id(fen_position_last_string);
          std::string new_uci = id(current_move_uci);

          // we use validator by https://github.com/rilpires/chess_fen_validator/blob/master/chess_validator.h
          chess_validator::TableState table_state;
          bool valid_fen = chess_validator::get_table_state( new_fen.c_str() , &table_state );
          if (valid_fen) {
            chess_validator::INVALID_REASON invalid = chess_validator::is_move_invalid( &table_state , new_uci.c_str() );
            if( invalid ){
                std::string fen_string = ", FEN = " + id(fen_position_last_string) + ", MOVE: " + new_uci;
                std::string invalid_reason = "";              
                switch(invalid){
                    case chess_validator::INVALID_FEN_STRING:
                        ESP_LOGW("Validator", "Invalid move... reason: INVALID_FEN_STRING %s",  fen_string.c_str() );
                        invalid_reason = "INVALID_FEN_STRING";
                        break;
                    case chess_validator::NOT_PLAYER_TURN:
                        ESP_LOGW("Validator", "Invalid move... reason: NOT_PLAYER_TURN %s",  fen_string.c_str() );
                        invalid_reason = "NOT_PLAYER_TURN";
                        break;
                    case chess_validator::NO_UNIT:
                        ESP_LOGW("Validator", "Invalid move... reason: NO_UNIT %s",  fen_string.c_str() );
                        break;
                    case chess_validator::SAME_PLACE:
                        ESP_LOGW("Validator", "Invalid move... reason: SAME_PLACE %s",  fen_string.c_str() );
                        break;
                    case chess_validator::CAPTURING_SAME_COLOR:
                        ESP_LOGW("Validator", "Invalid move... reason: CAPTURING_SAME_COLOR %s",  fen_string.c_str() );
                        invalid_reason = "CAPTURING_SAME_COLOR";
                        break;
                    case chess_validator::INVALID_UNIT_MOVE:
                        ESP_LOGW("Validator", "Invalid move... reason: INVALID_UNIT_MOVE %s",  fen_string.c_str() );
                        invalid_reason = "INVALID_UNIT_MOVE";
                        break;
                    case chess_validator::KING_IN_CHECK:
                        ESP_LOGW("Validator", "Invalid move... reason: KING_IN_CHECK %s",  fen_string.c_str() );
                        invalid_reason = "KING_IN_CHECK";
                        break;
                }
                if (invalid_reason != "") {
                  if (id(white_to_move)) {
                    id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + invalid_reason + "\"}";
                    id(oled_white_acitve_page) = 2;
                  } else {
                    id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + invalid_reason + "\"}";
                    id(oled_black_acitve_page) = 2;
                  }
                  id(redraw_displays).execute();
                }

            } else {

                // apply current move and check if any checks, mates, draws (we use here UCI due to missing promotion parameter)
                chess_validator::TableState new_table_state = chess_validator::apply_move( &table_state , new_uci.c_str() );
                new_fen = chess_validator::to_fen_string(&new_table_state);

                // king in check ?
                if (chess_validator::is_king_in_check(&new_table_state, new_table_state.next_color_to_play)) {
                    id(last_move_pgn_additional) = "+";
                }
                // kind in mate?
                if (chess_validator::is_check_mate(&new_table_state))
                {
                    id(last_move_pgn_additional) = "#";
                }
                // draw ?
                chess_validator::DRAW_REASON   draw  = chess_validator::get_draw_reason(&new_table_state);
                if (draw != chess_validator::DRAW_REASON::NO_DRAW) {
                    id(last_move_pgn_additional) = " 1/2-1/2";
                }

                valid_check = true;
            }
          }

          // reset flag if not valid
          id(valid_move) = valid_check;
          id(fen_position_new_string) = new_fen;
          id(fen_position_new_string_sensor).update();

  - id: calculate_position_differences
    then:
      - lambda: |-
          // loop over all 64 current and last positions and store differences to global variable
          int s = (id(white_to_move))? 1 : -1;
          for (int value = 0; value < 64; value++) {
            id(raw_position_differences)[value] = (id(raw_position_current)[value] - id(raw_position_last)[value])*s;
          }

          int sum = 0; // holds the sum of all differences
          int sum_abs = 0; // holds the sum of all abs differences
          int n_changes = 0; // holds the number of changed fields
          int n_pieces_last = 0; // holds number of pieces last
          int n_pieces_current = 0; // holds number of pieces current

          for (int value = 0; value < 64; value++) {
            sum += id(raw_position_differences)[value];
            int cur_pos_abs = abs(id(raw_position_differences)[value]);
            sum_abs += cur_pos_abs;
            n_changes += (int)((cur_pos_abs > 0) ? 1 : 0);
            if (id(raw_position_last)[value] != 0 ) {
              n_pieces_last += 1;
            }
            if (id(raw_position_current)[value] != 0) {
              n_pieces_current += 1;
            }
          }

          id(differences_n_pieces) = n_pieces_last - n_pieces_current;
          id(differences_sum) = sum;
          id(differences_sum_abs) = sum_abs;
          id(differences_n_changes) = n_changes;
  
  - id: reset_validator_flags
    then:
      - lambda: |-
          // reset flag
          id(current_move_uci) = "";
          id(current_move_from) = -1;
          id(current_move_to) = -1;
          id(fen_enpassant_index) = -1;
          // there is no moved piece
          id(moved_piece) = "";
          // reset valid move
          id(valid_move) = false;
          // reset move type
          id(current_move_type) = "";
          // reset add pgn
          id(last_move_pgn_additional) = "";

  - id: move_validator
    mode: queued 
    then:
      - lambda: |-
          if (id(game_running)) {
            // reset flags
            id(reset_validator_flags).execute();

            // we have to reset FEN, to allow move correction
            for (int i = 0; i < 72; i++) {
              id(fen_position_current)[i] = id(fen_position_last)[i];
            };

            if (id(debug_mode)) {
              id(debugger_sensor).publish_state("abs: " + std::to_string(id(differences_sum_abs)) + ", sum"  + std::to_string(id(differences_sum))  + ", n"  + std::to_string(id(differences_n_changes)) + ", pieces"  + std::to_string(id(differences_n_pieces)) );
            }

            // Update from / to indexes
            if (id(differences_n_pieces) == 0) { // move or castling

              // MOVE
              if (id(differences_sum_abs) == 2 && id(differences_sum) == 0 && id(differences_n_changes) == 2 ) {
                id(validate_move).execute();
              }

              // CASTLING
              if (id(differences_sum_abs) == 4 && id(differences_sum) == 0 && id(differences_n_changes) == 4 ) {
                id(validate_castling).execute();
              }
            } else if (id(differences_n_pieces) == 1) { // take or enpassant

              // TAKE
              if (id(differences_sum_abs) == 3 && id(differences_sum) == 1 && id(differences_n_changes) == 2 ) {
                id(validate_take).execute();
              }

              // EN PASSANT
              if (id(differences_sum_abs) == 3 && id(differences_sum) == 1 && id(differences_n_changes) == 3 ) {
                id(validate_enpassant).execute();
              }
            }

            // LICHESS MOVE
            if (id(valid_move) && id(lichess_game_running) && id(lichess_opponent_at_board).state == "no" && (id(white_to_move) && !id(lichess_is_my_color_white) || !id(white_to_move) && id(lichess_is_my_color_white))) {
              // we check here, if the move made and the opponents lichess move are the same, and press "finished-button" for the opponent
              id(valid_move) = (id(current_move_uci_lichess) == id(current_move_uci));
              if (id(valid_move)) { 
                if (id(lichess_is_my_color_white)) {
                  id(button_black_finished_script).execute();
                } else {
                  id(button_white_finished_script).execute();             
                }
              }
            }

            // ON SETTING START POSITION?
            if (id(differences_n_pieces) < -4) { // added five and more pieces to board
              // inform game is aborted
              id(inform_game_over).execute();
              // we stop the game and send png
              id(post_game_operation).execute();
              id(game_running) = false;
            }
          }

  - id: clear_display_messages
    mode: queued 
    then:
      - lambda: |-
          // if we had some messages in a non-lichess game, clear them at valid move 
          if (!id(lichess_game_running) && id(valid_move) && id(game_running)) {
            if (id(white_to_move) && id(oled_white_acitve_page) == 2) {
              id(oled_white_acitve_page) = 1;
            }
            if (!id(white_to_move) && id(oled_black_acitve_page) == 2) {
              id(oled_black_acitve_page) = 1;
            }
          }
 
  - id: validate_move
    then:
      - lambda: |-
          int from = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];

          // for the case of en passant, we have to exclude taking of "empty square" from "move"
          // algought, we have to wait, till the rook also moved at casteling
          // otherwise the move will be checked as valid, although the opponent pawn is still on the board
          bool pawn_move = (id(moved_piece) == "P" || id(moved_piece) == "p" );
          bool king_move = (id(moved_piece) == "K" || id(moved_piece) == "k" );
          bool take_enpassant = pawn_move  && (std::abs(from - to) == 7 || std::abs(from - to) == 9);
          bool king_castling = king_move && std::abs(from - to) == 2;

          // skip, till the opponent pawn is removed from board and we recognize the "enpassant - move"
          if (!take_enpassant && !king_castling && from > -1 && to > -1) { 

            id(current_move_from) = from;
            id(current_move_to) = to;
            id(current_move_type) = "MOVE";

            // if pawn move by 2 fields (16 indexes), we have to check en-passant for FEN
            if ( std::abs(from - to) == 16 && pawn_move)
            {
              std::vector<int> idx_to_check;
              if (id(white_to_move)) { // white
                if (from != 48) { // left diagonal (not a2 -> a4)
                  idx_to_check.push_back(to - 1);
                } 
                if (from != 55) { // right diagonal (not h2 -> h4)
                  idx_to_check.push_back(to + 1);
                }
                for (int i = 0; i < idx_to_check.size(); i++) {
                  // check if black pawns
                  if (id(fen_position_last)[idx_to_check[i]] == "p") {
                    id(fen_enpassant_index) = from - 8;
                    break;
                  }
                }
              } else { // black
                if (from != 8) { // left diagonal (not a7 -> a5)
                  idx_to_check.push_back(to - 1);
                } 
                if (from != 15) { // right diagonal (not h7 -> h5)
                  idx_to_check.push_back(to + 1);
                }
                for (int i = 0; i < idx_to_check.size(); i++) {
                  // check if black pawns
                  if (id(fen_position_last)[idx_to_check[i]] == "P") {
                    id(fen_enpassant_index) = from + 8;
                    break;
                  }
                }
              }
            }

            // prepare uci notation
            id(update_uci_notation).execute();
            // check if move is legal
            id(check_chess_rules).execute();
          }

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";

            id(update_chess_board).execute();  

            // run pgn move extractor 
            id(update_pgn).execute(); 
          }

  - id: validate_take
    then:
      - lambda: |-
          int from = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 2);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];

          if (id(moved_piece) != ""  && from > -1 && to > -1) {
            id(current_move_from) = from;
            id(current_move_to) = to;
            id(current_move_type) = "TAKE";

            // prepare uci notation
            id(update_uci_notation).execute();
            // check if move is legal
            id(check_chess_rules).execute();
          } 

          // still valid
          if (id(valid_move)) {
          // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";

            id(update_chess_board).execute();   

            // run pgn move extractor 
            id(update_pgn).execute();
          }

  - id: validate_castling
    then:
      - lambda: |-
          int from_k = -1;
          int to_k = -1;
          int from_r = -1;
          int to_r = -1;

          // white
          if (id(raw_position_differences)[60] == -1) {
            from_k = 60;
            if (id(raw_position_differences)[63] == -1) { // short
              from_r = 63;
              to_r = 61;
              to_k = 62;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[56] == -1) { // long
              from_r = 56;
              to_r = 59;
              to_k = 58;
              id(current_move_type) = "CASTLING_LONG";
            }
          }
          // black 
          if (id(raw_position_differences)[4] == -1) {
            from_k = 4;
            if (id(raw_position_differences)[7] == -1) { // short
              from_r = 7;
              to_r = 5;
              to_k = 6;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[0] == -1) { // long
              from_r = 0;
              to_r = 3;
              to_k = 2;
              id(current_move_type) = "CASTLING_LONG";
            }
          }

          // update global variables
          if (from_k > -1 && to_k > -1) {

            // store moved piece (we expect king)
            id(moved_piece) = id(fen_position_last)[from_k];

            // check, if the moved piece is a king
            if ((id(moved_piece) == "K" || id(moved_piece) == "k") ) {
              // king move only is set as from - to
              id(current_move_from) = from_k;
              id(current_move_to) = to_k;

              // prepare uci notation
              id(update_uci_notation).execute();
              // check if move is legal
              id(check_chess_rules).execute();
            } else {
              // reset moved piece if not the king
              id(moved_piece) = "";
            }
          }

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to_k] = id(fen_position_last)[from_k];
            id(fen_position_current)[from_k] = "0";            
            
            id(fen_position_current)[to_r] = id(fen_position_last)[from_r];   
            id(fen_position_current)[from_r] = "0"; 

            id(update_chess_board).execute();

            // run pgn move extractor 
            id(update_pgn).execute(); 
          }
        
  - id: validate_enpassant
    then:
      - lambda: |-
          int from = -1;
          int from_opponent = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
              if (id(raw_position_differences)[from - 1] == 1) {
                from_opponent = from - 1;  
              }
              if (id(raw_position_differences)[from + 1] == 1) {
                from_opponent = from + 1;  
              }
              // we deactivate the neighbour idx to find the goal
              id(raw_position_differences)[from_opponent]  = 0;
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];

          if (id(moved_piece) != ""  && from > -1 && to > -1) {
            id(current_move_from) = from;
            id(current_move_to) = to;          
            id(current_move_type) = "ENPASSANT";

            // prepare uci notation
            id(update_uci_notation).execute();
            // check if move is legal
            id(check_chess_rules).execute();
          }

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";
            id(fen_position_current)[from_opponent] = "0";

            id(update_chess_board).execute();
            
            // run pgn move extractor
            id(update_pgn).execute(); 
          }     

  - id: update_fen_additional_fields
    mode: queued
    then:
      - lambda: |-
          // update who to move
          id(fen_position_current)[64] = (id(white_to_move) ? "b" : "w");

          // update castling part
          if (std::string("KRkr").find(id(moved_piece)) != std::string::npos){ // Kind or rook move
            if (id(white_to_move) && (id(fen_position_current)[65] == "K" || id(fen_position_current)[65] == "Q") ) { // white
              // king
              if (id(moved_piece) == "K"){
                id(fen_position_current)[65] = "";
                id(fen_position_current)[66] = "";
              } else { // rook
                  // short
                  if (id(current_move_from) == 63) {
                    id(fen_position_current)[65] = "";
                  } else { // long
                    id(fen_position_current)[66] = "";
                  }
              }
            } else if (id(fen_position_current)[67] == "k" || id(fen_position_current)[68] == "q") {
              // king
              if (id(moved_piece) == "k"){
                id(fen_position_current)[67] = "";
                id(fen_position_current)[68] = "";
              } else { // rook
                  // short
                  if (id(current_move_from) == 7) {
                    id(fen_position_current)[67] = "";
                  } else { // long
                    id(fen_position_current)[68] = "";
                  }
              }
            }
          }

          //en passant field
          if (id(fen_enpassant_index) > 0) {
            id(fen_position_current)[69] = id(chess_field_names)[id(fen_enpassant_index)];
          } else {
            id(fen_position_current)[69] = "-";
          }

          // update fen move counters
          if (id(current_move_type) == "TAKE" || id(moved_piece) == "p" || id(moved_piece) == "P") {
            id(halfmove_or_capture_counter) = 0;
          } else {
            id(halfmove_or_capture_counter) += 1;
          }
          id(fen_position_current)[70] = std::to_string(id(halfmove_or_capture_counter));
          id(fen_position_current)[71] = id(white_to_move) ? std::to_string((int)(id(halfmove_counter) / 2.) + 1) : std::to_string((int)(id(halfmove_counter) / 2.) + 2);

  - id: update_pgn
    mode: queued
    then:
      - lambda: |-
            // create pgn notation (internal)
            std::string pgn_move = "";
            
            if (id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") {            
              
              // from FEN-position to upper case
              std::string fen_from = id(fen_position_last)[id(current_move_from)];
              std::transform(fen_from.begin(), fen_from.end(), fen_from.begin(), ::toupper);

              // get type of piece has been moved
              bool p_move = (bool)(fen_from == "P");
              bool q_move = (bool)(fen_from == "Q");
              bool q_1_move = (bool)(q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1));
              bool pkb_move = (bool)(p_move || fen_from == "K" || fen_from == "B");
              bool kb_move = (bool)(fen_from == "K" || fen_from == "B");

              // we dont need P in notation
              pgn_move = (p_move) ? "" : fen_from;

              //for pawns, king and bishops we dont need to use "from" field (and queens, as long 1 on the board) 
              if (id(current_move_type) == "MOVE" ) { 
                if (pkb_move || q_1_move) {
                  // pgn without from field
                  pgn_move += id(chess_field_names)[id(current_move_to)];
                } else {
                  // pgn with from field
                  pgn_move += id(chess_field_names)[id(current_move_from)] + id(chess_field_names)[id(current_move_to)];
                }
              }

              // if we take, add "x" to pgn
              if (id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") {
                if (kb_move || (q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1))) {
                  pgn_move += "x" + id(chess_field_names)[id(current_move_to)];
                } else {  
                  pgn_move += id(chess_field_names)[id(current_move_from)] + "x" + id(chess_field_names)[id(current_move_to)];
                }  
              }

              // PAWN PROMOTION
              // for move and take by a pawn we have to check the promotion
              if (p_move ) {                                 
                // white
                if (id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('8') != std::string::npos)) {
                  // add promotion piece
                  pgn_move += "=" + id(default_pawn_promotion_to);  
                  // update fen by promoted piece 
                  id(fen_position_current)[id(current_move_to)] = id(default_pawn_promotion_to); 
                }
                // black
                if (!id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('1') != std::string::npos)) {
                  
                  // add promotion piece 
                  pgn_move += "=" + id(default_pawn_promotion_to);
                  // update fen by promoted piece (for black we have to lower it)
                  std::string promote_to = id(default_pawn_promotion_to);
                  std::transform(promote_to.begin(), promote_to.end(), promote_to.begin(), ::tolower);
                  id(fen_position_current)[id(current_move_to)] = promote_to;
                }
              }
            }

            // CASTLING
            if (id(current_move_type) == "CASTLING_SHORT" ) {
                pgn_move += "O-O";
            } 
            if (id(current_move_type) == "CASTLING_LONG" ) {
                pgn_move += "O-O-O";
            }

            // check, mate, draw
            pgn_move +=  id(last_move_pgn_additional);

            id(last_move_pgn_take_back) = id(last_move_pgn);
            id(last_move_pgn) = pgn_move;
            id(last_move_pgn_sensor).update();  

  - id: compare_raw_position
    then:
      - lambda: |-
          id(changed_position) = false;
          for (int i = 0; i < 64; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_last)[i])
            {
              id(changed_position) = true;
              break;
            }
          }


  - id: update_raw_position_current
    mode: queued
    then:
      - lambda: |-
          // We want to calculate mean voltage drift from the values without pieces
          const float n_empty_fields_init = 0.0;
          float n_empty_fields = n_empty_fields_init;
          float sum_voltage_drift = 0.0;

          // Read all 64 hall sensor values
          for (int value = 0; value < 64; value++) {

            // extract values from arrays
            float curr_field = id(voltage_field_current)[value];

            // Simplified sign and position detection
            int sign = (curr_field > 0) ? 1 : (curr_field < 0) ? -1 : 0;
            int field_occupied =  (fabsf(curr_field) > id(voltage_field_detection_threshold)[value]) ? 1 : 0;

            if (field_occupied == 0) {
              // we have to substract the drift, to get uncorrected value
              sum_voltage_drift += curr_field + id(voltage_field_drift);
              n_empty_fields += 1.00;
            }
            // set position -1, 0 or 1
            id(raw_position_current)[value] = field_occupied * sign;
          }

          // calc mean deviation
          if (n_empty_fields > n_empty_fields_init) {
            id(voltage_field_drift) = sum_voltage_drift / n_empty_fields;
          }


  - id: update_all_hall_sensors
    mode: queued
    then:
      - lambda: |-
          // Define a array of size 64 to hold the ADC values
          std::array<float, 64> adc_values;

          // Read all 16 ADC-Channels and store them in the array
          for (int value = 0; value < 16; value++) {

            if (value & 0b000001) {
              id(output_s1).turn_on();
            } else {
              id(output_s1).turn_off();
            }

            if (value & 0b000010) {
              id(output_s2).turn_on();
            } else {
              id(output_s2).turn_off();
            }

            if (value & 0b000100) {
              id(output_s3).turn_on();
            } else {
              id(output_s3).turn_off();
            }

            if (value & 0b001000) {
              id(output_s4).turn_on();
            } else {
              id(output_s4).turn_off();
            }

            // all outputs are set

            // let the multiplexer select the sensor to be read
            delay($delay_before_adc_reading);  

            // let the ADC reads the sampels
            id(current_hall_sensor_1).update(); // update adc value
            id(current_hall_sensor_2).update(); // update adc value
            id(current_hall_sensor_3).update(); // update adc value
            id(current_hall_sensor_4).update(); // update adc value

            int value_4_0 = value*4;
            int value_4_1 = value_4_0 + 1;
            int value_4_2 = value_4_0 + 2;
            int value_4_3 = value_4_0 + 3;

            // read and write values into array
            adc_values[value_4_0] = id(current_hall_sensor_1).state;
            adc_values[value_4_1] = id(current_hall_sensor_2).state;
            adc_values[value_4_2] = id(current_hall_sensor_3).state;
            adc_values[value_4_3] = id(current_hall_sensor_4).state;
          }

          // Once all 64 values are read, update the global array
          for (int i = 0; i < 64; i++) {
            id(voltage_field_current)[i] = adc_values[id(hall_sensor_order)[i]] - id(voltage_field_offset)[i] - id(voltage_field_drift);
          }

          if(id(debug_mode)) {
            // id(update_array_text).execute();
          }


  - id: beep_short
    then:
      - lambda: |-
          id(beep_switch).turn_on();
          delay(50);
          id(beep_switch).turn_off();

  - id: beep_long
    then:
      - lambda: |-
          id(beep_switch).turn_on();
          delay(150);
          id(beep_switch).turn_off();
  - id: check_opponent_at_board_select
    then:
      - lambda: |- 
          if ( id(lichess_opponent_at_board).state == "yes" && (id(lichess_opponent).state == "random" || (id(lichess_opponent).state).compare(0, 3, "AI_") == 0) ) {
            // not possible to play "on board"
            auto call = id(lichess_opponent_at_board).make_call();
            call.set_option("no");
            call.perform();          
          }

  - id: lichess_make_move
    then:
      - lambda: |- 
          if (id(current_move_uci) != "") {                                 
            // do lichess calls and updates 
            if (id(lichess_game_running) ) {
              // let lichess know about my move
              std::string move_body = "{\"type\": \"makeMove\", \"move\": \"" + id(current_move_uci) + "\"}";
              if( (id(white_to_move) && id(lichess_is_my_color_white)) || (!id(white_to_move) && !id(lichess_is_my_color_white))) {   
                // send the move to lichess           
                id(lichess_api_call).publish_state(move_body);              
              } else if( id(lichess_opponent_at_board).state == "yes") {
                // switch to oppoents token
                std::string token_body = "{\"type\": \"overwriteToken\", \"token\": \"" + id(chessboard_token_opponent) + "\"}";
                id(lichess_api_call).publish_state(token_body);
                delay(100); // do a short delay 
                // make a move for the opponent
                id(lichess_api_call).publish_state(move_body); 
                delay(100); // do a short delay 
                // switch token back
                token_body = "{\"type\": \"overwriteToken\", \"token\": \"" + id(chessboard_token_current) + "\"}";
                id(lichess_api_call).publish_state(token_body);                    
              }                
            }
          }  

  - id: update_lichess_token
    then:
      - lambda: |-
          // update own token
          auto index = id(lichess_account).active_index();
          if (index.value() == 0) {
            id(chessboard_token_current) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_current) = id(chessboard_token_b);
          } else if (index.value() == 2) {
            id(chessboard_token_current) = id(chessboard_token_c);
          } else {
            id(chessboard_token_current) = id(chessboard_token_c);
          }

          // update opponents token
          index = id(lichess_opponent).active_index();
          if (index.value() == 0) {
            id(chessboard_token_opponent) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_opponent) = id(chessboard_token_b);
          } else if (index.value() == 2) {
            id(chessboard_token_opponent) = id(chessboard_token_c);
          } else {
            id(chessboard_token_opponent) = "";
          }

          id(lichess_token).update();

  - id: lichess_create_new_game
    mode: single
    then:
      - lambda: |-
          // not during the gave
          if (id(initial_position_set).state) {
            // stop timer, if running
            id(game_running) = false;
            // update lichess token, if not selected yet
            id(update_lichess_token).execute();
            // open the event stream
            id(lichess_stream_events).publish_state("ON");
            // Create JSON object
            StaticJsonDocument<250> root;  
            root["type"] = "createGame";   
            root["color"] = id(lichess_seek_color).state;     
            root["time_m"] = float(float(id(time_control_duration)) / 60.);
            root["time_s"] = int(round(float(id(time_control_duration)) / 15.)*15) ; // closes value to a multiple of 15
            root["increment"] = int(id(time_control_increment));            
            if (id(lichess_seek_rated).state == "rated") {
              root["rated"] = true;
            } else {
              root["rated"] = false;
            }
            root["opponentname"] = id(lichess_opponent).state;

            // the shortest seek posible is 10+0, so we set this time, if shorter time - control is choosen
            if (id(lichess_opponent).state == "random" && id(time_control_duration) < 600 ){              
              ESP_LOGW("Lichess", "Invalid time control. Set the clock to 10+0.");
              auto call = id(chess_time_control).make_call();
              call.set_option("Rapid (10+0)");
              call.perform();              
              root["time_m"] = 10;
              root["time_s"] = 600;
              root["increment"] = 0;
            }

            // Convert JSON to string
            std::string json_string;
            serializeJson(root, json_string);

            // just for better representation in web-server
            std::string search = ",";
            std::string replace = ", ";            
            size_t pos = 0;
            while ((pos = json_string.find(search, pos)) != std::string::npos) {
                json_string.replace(pos, search.length(), replace);
                pos += replace.length(); 
            }

            delay(1000);  // Wait 1s to stream be open

            // force changed state, to be able to call the same request 
            id(lichess_api_call).publish_state("{}"); 
            id(lichess_api_call).publish_state(json_string);

            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"waiting for new game ...\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"waiting for new game ...\", \"line_1\": \"" + id(chess_time_control).state + "\"}"; 
          } else {
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"Not initial position\"}";            
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"Not initial position\"}";                    
          }

          id(oled_white_acitve_page) = 2;
          id(oled_black_acitve_page) = 2;  
          id(redraw_displays).execute();  


  - id: lichess_handle_new_event
    mode: queued
    then:
      - lambda: |-
          std::string json_str = id(lichess_last_event_in).state;

          StaticJsonDocument<255> root;
          deserializeJson(root, json_str);

          // ############# new game started #############
          if (root.containsKey("type") && root.containsKey("color") && root["type"].as<std::string>() == "gameStart"){

            // rise flag we are in lichess game
            id(lichess_game_running) = true;
            id(game_running) = true;
            id(white_to_move) = true;
            // we could have some pgn_additionals from last game
            id(pgn_history) = ""; 
            id(last_move_pgn_additional) = "";

            // extract opponents name to be shown on display
            std::string opponent =  root["opponent"].as<std::string>();
            std::string me = id(lichess_account).state;
            std::string game_id = root["gameId"].as<std::string>();

            // we start board stream
            id(lichess_game_id).publish_state(game_id);

            // we check the white color
            if ( root["color"].as<std::string>() == "white"){ 
              id(lichess_is_my_color_white) = true;
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + opponent + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            }
            // we check the white color
            if (root["color"].as<std::string>() == "black"){
              id(lichess_is_my_color_white) = false;
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + opponent + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            }

            id(lichess_opponent_name) = opponent;     
            id(oled_show_page_message).execute();
          }

          // ############# game finished #############
          if (root.containsKey("type") && root["type"].as<std::string>() == "gameFinish" && root.containsKey("gameId") && root["gameId"].as<std::string>() == id(lichess_game_id).state){
            // for the case, multiple games are running, we check the current gameId
            
              // white won ?
              if (root["win"].as<std::string>() == "w"){
                id(last_move_pgn_additional) = " 1-0"; 
              }

              // black won ?
              if (root["win"].as<std::string>() == "b"){
                id(last_move_pgn_additional) = " 0-1";
              }

              if (root["status"].as<std::string>() == "draw"){
                id(last_move_pgn_additional) = " 1/2-1/2";
              }

              // close the event stream
              id(lichess_stream_events).publish_state("OFF");
              id(lichess_game_id).publish_state("idle");

              id(inform_game_over).execute();
              id(game_running) = false;
          }

          

  - id: lichess_handle_last_move
    mode: queued
    then:
      - lambda: |-
          std::string json_str = id(lichess_last_move_in).state;

          StaticJsonDocument<300> root;
          deserializeJson(root, json_str);

          // ############# opponent gone #############
          if (root["type"].as<std::string>() == "opponentGone" && root["gone"].as<bool>() == true  && root["claimWinInSeconds"].as<int>() == 0 ){
            delay(1000);  // Wait 1s to sync
            // claim victory
            id(lichess_api_call).publish_state("{}"); 
            id(lichess_api_call).publish_state("{\"type\": \"claim-victory\"}");            
          }

          // ############# move on board #############
          if (root["type"].as<std::string>() == "gameState"){
            
            // let the player know about the last move of opponent
            std::string last_move = root["last"].as<std::string>();
            std::string from = last_move.substr(0, 2);
            std::string to = last_move.substr(2, 2);
            
            std::string moved_piece = id(fen_position_last)[id(chess_field_indexes)[from]];
            std::transform(moved_piece.begin(), moved_piece.end(), moved_piece.begin(), ::toupper);

            if (moved_piece == "P") {
              moved_piece = "";
            } else {
              moved_piece += ":";
            }

            // get number of moves
            int n = root["n"].as<int>();           
            bool is_my_turn = (bool)( (n % 2) == int(id(lichess_is_my_color_white)));            

            if (!is_my_turn) { // we want the opponents move
              if( id(lichess_opponent_at_board).state == "no") {
                // opponent is white and its turn
                if (!id(lichess_is_my_color_white)){ 
                  id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"" + moved_piece +  last_move + "\"}";                
                  id(oled_black_acitve_page) = 2;
                  id(beep_short).execute();       
                } 
                // opponent is black and its turn
                if (id(lichess_is_my_color_white)){  
                  id(display_message_white) = "{\"n_lines\": 1, \"line_0\":  \""+ moved_piece  + last_move + "\"}";
                  id(oled_white_acitve_page) = 2;
                  id(beep_short).execute();
                }
              } 
            }

            // store lichess move
            id(current_move_uci_lichess) = last_move;

            // if my turn, show the clock
            if (id(white_to_move) && is_my_turn){ // I'm white and my turn
              id(oled_white_acitve_page) = 1;
            } 
            
            if (!id(white_to_move) && is_my_turn){  // I'm black and my turn
              id(oled_black_acitve_page) = 1;
            }
            
            // update chessboard clock by values from lichess
            std::string wclk = root["wclk"].as<std::string>();
            std::string bclk = root["bclk"].as<std::string>();

            // set white clock
            size_t pos = wclk.find('+'); // Find the "+" character
            if (pos != std::string::npos) {
                std::string first_part = wclk.substr(0, pos); // Extract first part
                id(time_control_timer_white) = std::stoi(first_part); 
                id(timer_white).update();
            }

            // set black clock
            pos = bclk.find('+'); // Find the "+" character
            if (pos != std::string::npos) {
                std::string first_part = bclk.substr(0, pos); // Extract first part
                id(time_control_timer_black) = std::stoi(first_part);
                id(timer_black).update();
            }   
           
            // draw offer ?
            if ( (root["wdraw"].as<int>() == 1 && !id(lichess_is_my_color_white)) || (root["bdraw"].as<int>() == 1 && id(lichess_is_my_color_white)) ) {
              if (!id(lichess_is_my_color_white)) {
                id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"DRAW?\"}";
                id(oled_black_acitve_page) = 2;
              } else {
                id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"DRAW?\"}";
                id(oled_white_acitve_page) = 2;
              } 
              id(beep_long).execute();             
            }

            // take back offer ?
            if ( (root["wback"].as<int>() == 1 && !id(lichess_is_my_color_white)) || (root["bback"].as<int>() == 1 && id(lichess_is_my_color_white)) ) {
              if (!id(lichess_is_my_color_white)) {
                id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"Takeback?\"}";
                id(oled_black_acitve_page) = 2;
              } else {
                id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"Takeback?\"}";
                id(oled_white_acitve_page) = 2;
              }
              id(beep_long).execute();   
            }                        
          }

          id(redraw_displays).execute();

  - id: oled_show_page_clock
    then:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.show_main:   my_menu
            - display_menu.hide:  my_menu
      - lambda: |-
            id(oled_white_acitve_page) = 1;
            id(oled_black_acitve_page) = 1;
            id(redraw_displays).execute();

  - id: oled_show_page_menu
    then:
      - if:
          condition:
            not:
              display_menu.is_active: my_menu
          then:
            - display_menu.show:  my_menu    
      - lambda: |-
            id(oled_white_acitve_page) = 0;
            id(oled_black_acitve_page) = 0;
            id(redraw_displays).execute();

  - id: oled_show_page_message
    then:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.show_main:   my_menu
            - display_menu.hide:  my_menu
      - lambda: |-
            id(oled_white_acitve_page) = 2;
            id(oled_black_acitve_page) = 2;
            id(redraw_displays).execute();
  
  - id: led_update_initial_position_set
    then:
      - lambda: |-
          // if game not running only (or menu)
          if (!id(game_running)) {
            // turn all leds off
            id(led_all_turn_off).execute();
            // black -> red if not set
            if (id(initial_position_set_black)) {
              id(led_black_blue).execute();              
            } else {
              id(led_black_red).execute();
            }
            // white -> red if not set
            if (id(initial_position_set_white)) {              
              id(led_white_blue).execute();
            } else {
              id(led_white_red).execute();
            }
          }

  - id: led_update_color_to_move
    then:
      - lambda: |-
          // update only if game is running
          if (id(game_running)) {
            // white to move
            if (id(white_to_move)) { 
              id(led_black_turn_off).execute();           
              id(led_white_blue).execute();              
            } else { // black to move
              id(led_white_turn_off).execute();
              id(led_black_blue).execute();
            }
          }
          
  - id: led_update_valid_move
    then:
      - lambda: |-
          // update only if game is running
          if (id(game_running)) {
            // turn all leds off
            id(led_all_turn_off).execute();            
            // if no valid move found, rise flag
            if (id(valid_move)) {
              // update leds
              if (id(white_to_move)) {
                id(led_white_green).execute();
              } else {
                id(led_black_green).execute();           
              }
            } else {
              if (id(white_to_move)) {
                id(led_white_red).execute();
              } else {
                id(led_black_red).execute();               
              }
            }
          }

  - id: led_white_red
    then: 
      - lambda: |-
          // r
          if (!id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_on();
          }
          // g
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          // b
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }
 
  - id: led_white_green
    then: 
      - lambda: |-
          // r
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          // g
          if (!id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_on();
          } 
          // b
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }

  - id: led_white_blue
    then: 
      - lambda: |-
          // r
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          // g
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          // b
          if (!id(led_white_to_move).state) {
            id(led_white_to_move).turn_on();
          }

  - id: led_black_red
    then: 
      - lambda: |-
          // r
          if (!id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_on();
          }
          // g
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          } 
          // b
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }
 
  - id: led_black_green
    then: 
      - lambda: |-
          // r
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          // g
          if (!id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_on();
          } 
          // b
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }

  - id: led_black_blue
    then: 
      - lambda: |-
          // r
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          // g
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          } 
          // b
          if (!id(led_black_to_move).state) {
            id(led_black_to_move).turn_on();
          }

  - id: led_all_turn_off
    then:
      - lambda: |-
          id(led_white_turn_off).execute();
          id(led_black_turn_off).execute(); 

  - id: led_white_turn_off
    then:
      - lambda: |-
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          
  - id: led_black_turn_off
    then:
      - lambda: |-
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          }
