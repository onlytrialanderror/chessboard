esphome:
  name: chessboard
  friendly_name: chessboard

  includes:
    - chess_validator.h
  

  # Do some initialition work
  on_boot:
    - priority: 400
      then:
      - script.execute: reset_all_values 
    


esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: WARN

api:
  reboot_timeout: 0s

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True

  ap:
    ssid: "chessboard"
    password: "chessboard"

# HTTP request component
http_request:
  timeout: 10s
  verify_ssl: false 

captive_portal:

# Enable web server
web_server:
  port: 80
  include_internal: False
  version: 3
  log: false
  ota: false
  local: true
  sorting_groups:
    - id: sorting_group_settings
      name: "Game Settings"
      sorting_weight: 10
    - id: sorting_group_board
      name: "Board"
      sorting_weight: 20
    - id: sorting_group_pgn
      name: "PGN"
      sorting_weight: 30
    - id: sorting_group_sensors
      name: "Sensors"
      sorting_weight: 50
    - id: sorting_group_simulation
      name: "DEBUG"
      sorting_weight: 100
    - id: sorting_group_lichess
      name: "Lichess"
      sorting_weight: 40
    - id: sorting_group_system
      name: "System"
      sorting_weight: 70
time:
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Berlin"  


substitutions:
  adc_n_sampels: '25'
  attenuation_value: 12dB
  hall_sensor_intervall_game: 400ms
  hall_sensor_intervall_idle: 1s
  delay_before_adc_reading: '15'

i2c:
  sda: GPIO21
  scl: GPIO22
  id: i2c0
  scan: true
  frequency: 100kHz 
  # max frequency of pcf8574 is 100kHz 
  

tca9548a:
  - address: 0x70
    id: i2c_mux_b
    i2c_id: i2c0
    channels:
      - bus_id: i2c_mux_b_display
        channel: 7
      - bus_id: i2c_mux_b_buttons
        channel: 2

pcf8574:
  - id: 'pcf8574_b'
    address: 0x20
    i2c_id: i2c_mux_b_buttons
    pcf8575: false
  - id: 'pcf8574_w'
    address: 0x20
    i2c_id: i2c0
    pcf8575: false

display:

  - platform: ssd1306_i2c
    id: oled_white
    model: "SSD1306 128x32"
    flip_y: False
    flip_x: False
    address: 0x3C
    i2c_id: i2c0
    lambda: |-
      const auto display_width = it.get_width();
      const auto display_height = it.get_height();

      if (id(my_menu).is_active()) {
        it.menu(0, 0, id(my_menu), display_width, display_height);
      } else {
        std::string json_str = id(display_message_white);
        if (json_str == "") {
          std::string time_to_show_w = id(timer_white).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_w.c_str());

          std::string time_to_show_b = id(timer_black).state;
          it.printf(85, 0, id(roboto_12), time_to_show_b.c_str());

          std::string move_to_show = id(last_move_black);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());
        } else {          
          
          StaticJsonDocument<100> root;
          deserializeJson(root, json_str);

          if (root.containsKey("n_lines")) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }

        }
      }

  - platform: ssd1306_i2c
    id: oled_black
    flip_y: False
    flip_x: False
    model: "SSD1306 128x32"
    address: 0x3C
    i2c_id: i2c_mux_b_display
    lambda: |-
      const auto display_width = it.get_width();
      const auto display_height = it.get_height();

      if (id(my_menu).is_active()) {
        it.menu(0, 0, id(my_menu), display_width, display_height);
      } else {
        std::string json_str = id(display_message_black);
        if (json_str == "") {
          std::string time_to_show_b = id(timer_black).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_b.c_str());

          std::string time_to_show_w = id(timer_white).state;
          it.printf(85, 0, id(roboto_12), time_to_show_w.c_str());

          std::string move_to_show = id(last_move_white);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());
        } else {
          
          StaticJsonDocument<100> root;
          deserializeJson(root, json_str);

          if (root.containsKey("n_lines")) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }

        }
      }


font:
  - file: "gfonts://Roboto"
    id: roboto_10
    size: 10
  - file: "gfonts://Roboto"
    id: roboto_12
    size: 12
  - file: "gfonts://Roboto"
    id: roboto_14
    size: 14
  - file: "gfonts://Roboto"
    id: roboto_24
    size: 24
  - file: "gfonts://Roboto"
    id: roboto_30
    size: 30
  - file: "gfonts://Roboto"
    id: roboto_32
    size: 32

globals:

  # some constants
  - id: chess_field_names
    type: std::array<std::string, 64>
    initial_value: |-
      {
        "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
        "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
        "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
        "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
        "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
        "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
        "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
        "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1"
      }

  - id: chess_symbols
    type: std::map<char, std::string>
    initial_value: |- 
      /*
        Standard spaces (" ") can be too narrow. Instead, use:
        Non-Breaking Space (\u00A0) → " "
        Thin Space (\u2009) → " "
        En Space (\u2002) → " "
        Full-Width Space (\u3000) → "　"
        ♔	U+2654	White Chess King
        ♕	U+2655	White Chess Queen
        ♖	U+2656	White Chess Rook
        ♗	U+2657	White Chess Bishop
        ♘	U+2658	White Chess Knight
        ♙	U+2659	White Chess Pawn
        ♚	U+265A	Black Chess King
        ♛	U+265B	Black Chess Queen
        ♜	U+265C	Black Chess Rook
        ♝	U+265D	Black Chess Bishop
        ♞	U+265E	Black Chess Knight
        ♟	U+265F	Black Chess Pawn
      */
      {
        {'K', "\u2002\u2654\u2002"},
        {'Q', "\u2002\u2655\u2002"},
        {'R', "\u2002\u2656\u2002"},
        {'B', "\u2002\u2657\u2002"},
        {'N', "\u2002\u2658\u2002"},
        {'P', "\u2002\u2659\u2002"},
        {'k', "\u2002\u265A\u2002"},
        {'q', "\u2002\u265B\u2002"},
        {'r', "\u2002\u265C\u2002"},
        {'b', "\u2002\u265D\u2002"},
        {'n', "\u2002\u265E\u2002"},
        {'p', "\u2002\u265F\u2002"},
        {'0', "\u2002\u3000\u2002"}
      }

  - id: chess_symbols_telegram
    type: std::map<char, std::string>
    initial_value: |- 
      /*
        Standard spaces (" ") can be too narrow. Instead, use:
        Non-Breaking Space (\u00A0) → " "
        Thin Space (\u2009) → " "
        En Space (\u2002) → " "
        Full-Width Space (\u3000) → "　"
        ♔	U+2654	White Chess King
        ♕	U+2655	White Chess Queen
        ♖	U+2656	White Chess Rook
        ♗	U+2657	White Chess Bishop
        ♘	U+2658	White Chess Knight
        ♙	U+2659	White Chess Pawn
        ♚	U+265A	Black Chess King
        ♛	U+265B	Black Chess Queen
        ♜	U+265C	Black Chess Rook
        ♝	U+265D	Black Chess Bishop
        ♞	U+265E	Black Chess Knight
        ♟	U+265F	Black Chess Pawn
         	U+2002	En Space
         	U+2003	Em Space
         	U+2004	Three-Per-Em Space
         	U+2005	Four-Per-Em Space
         	U+2006	Six-Per-Em Space
         	U+2007	Figure Space
         	U+2008	Punctuation Space
         	U+2009	Thin Space
         	U+200A	Hair Space
         	U+202F	Narrow No-Break Space (NNBSP)
         	U+205F	Medium Mathematical Space (MMSP)
      */
      {
        {'K', "\u2009\u200A\u200A\u200A\u200A\u2654\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'k', "\u2009\u200A\u200A\u200A\u200A\u265A\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'Q', "\u200A\u200A\u200A\u200A\u200A\u200A\u2655\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'q', "\u200A\u200A\u200A\u200A\u200A\u200A\u265B\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'R', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u2656\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'r', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u265C\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'B', "\u200A\u200A\u200A\u200A\u200A\u200A\u2657\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'b', "\u200A\u200A\u200A\u200A\u200A\u200A\u265D\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'N', "\u200A\u200A\u200A\u200A\u200A\u200A\u2658\u200A\u200A\u200A\u200A\u200A\u200A"},
        {'n', "\u200A\u200A\u200A\u200A\u200A\u200A\u265E\u200A\u200A\u200A\u200A\u200A\u200A"},

        {'P', "\u200A\u200A\u200A\u200A\u200A\u200A\u2659\u200A\u200A\u200A\u200A\u200A\u200A\u200A"},    
        {'p', "\u200A\u200A\u200A\u200A\u265F\u200A\u200A\u200A\u200A"},

        {'0', "\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A\u200A"}
      }
  # order of hall sensors from A8 to H1
  - id: hall_sensor_order
    type: std::array<int, 64>
    initial_value: |-
      {
        23,  7, 11, 27, 10, 30, 62  58,
        19,  3, 14, 31, 26, 46, 14, 42,
        43, 51, 59, 39, 54, 34, 2,  6,
        47, 55, 63, 35, 38, 18, 50, 21,
        41, 25, 9,  49, 8,  28, 60, 44,
        33,  1, 17, 57, 12, 56, 24, 40,
        21, 37, 53, 13, 52, 32,  0, 16,
        29, 61, 45,  5, 48,  4, 36, 20
      }

  # Variables for FEN
  - id: fen_black
    type: std::array<std::string, 6>
    initial_value: |-
      {
        "p","n","b","q","r","k"
      }

  - id: fen_white
    type: std::array<std::string, 6>
    initial_value: |-
      {
        "P","N","B","Q","R","K"
      }

  # Variables for FEN
  - id: fen_position_init
    type: std::array<std::string, 72>
    initial_value: |-
      {
        "r","n","b","q","k","b","n","r",
        "p","p","p","p","p","p","p","p",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "0","0","0","0","0","0","0","0",
        "P","P","P","P","P","P","P","P",
        "R","N","B","Q","K","B","N","R",
        "w","K","Q","k","q", "-", "0", "1"
      }

  - id: fen_position_last
    type: std::array<std::string, 72>
    initial_value: '{""}'

  - id: fen_position_last_string
    type: std::string
    initial_value: '"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"'

  - id: fen_position_current
    type: std::array<std::string, 72>
    initial_value: '{""}'

  - id: fen_position_chessboard
    type: std::string
    initial_value: '""'

  - id: fen_enpassant_index
    type: int
    initial_value: '-1'

  - id: fen_position_take_back
    type: std::array<std::string, 72>
    initial_value: '{""}'
  
  # Variables for RAW-position
  - id: raw_position_init
    type: std::array<int, 64>
    initial_value: |-
      {
        -1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1
      }

  - id: raw_position_take_back
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_last
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_current
    type: std::array<int, 64>
    initial_value: '{0}'

  - id: raw_position_differences
    type: std::array<int, 64>
    initial_value: '{0}'

  # Variables for voltage-field
  - id: voltage_field_offset
    type: std::array<float, 64>
    initial_value: |-
      {
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,
        0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00
      }

  - id: voltage_field_detection_threshold
    type: std::array<float, 64>
    initial_value: |-
      {
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20
      }



  - id: voltage_field_current
    type: std::array<float, 64>
    initial_value: '{0.0}'

  - id: pgn_history
    type: std::string
    initial_value: ''    

  - id: pgn_history_take_back
    type: std::string
    initial_value: '' 

  - id: pgn_full
    type: std::string
    initial_value: ''

  - id: valid_move
    type: bool
    initial_value: 'false'

  - id: white_to_move
    type: bool
    initial_value: 'true'

  - id: game_running
    type: bool
    initial_value: 'false'

  - id: lichess_game_running
    type: bool
    initial_value: 'false'

  - id: moved_piece
    type: std::string
    initial_value: ''  

  - id: halfmove_counter
    type: int
    initial_value: '0'

  - id: halfmove_or_capture_counter
    type: int
    initial_value: '0'

  - id: last_move_pgn_take_back
    type: std::string
    initial_value: ''

  - id: last_move_pgn
    type: std::string
    initial_value: ''

  - id: last_move_pgn_additional
    type: std::string
    initial_value: ''

  - id: current_move_from
    type: int
    initial_value: '0'

  - id: current_move_to
    type: int
    initial_value: '0'

  - id: current_move_type
    type: std::string
    initial_value: ''

  - id: current_move_uci
    type: std::string
    initial_value: ''

  - id: current_move_uci_lichess
    type: std::string
    initial_value: ''

  - id: time_control_duration
    type: int
    initial_value: '900'

  - id: time_control_increment
    type: int
    initial_value: '10'

  - id: time_control_timer_black
    type: int
    initial_value: '900'

  - id: time_control_timer_white
    type: int
    initial_value: '900'

  - id: n_queens_white
    type: int
    initial_value: '1'

  - id: n_queens_black
    type: int
    initial_value: '1'

  - id: default_pawn_promotion_to
    type: std::string
    initial_value: '"Q"' 

  - id: chessboard_token_a
    type: std::string
    initial_value: !secret chessboard_token_a
  - id: chessboard_token_b
    type: std::string
    initial_value: !secret chessboard_token_b
  - id: chessboard_token_c
    type: std::string
    initial_value: !secret chessboard_token_c
  - id: chessboard_token_current
    type: std::string
    initial_value: ""
  - id: chessboard_token_opponent
    type: std::string
    initial_value: ""

  - id: lichess_is_my_turn
    type: bool
    initial_value: 'false'

  - id: lichess_my_color
    type: std::string
    initial_value: '""'

  - id: lichess_opponent_name
    type: std::string
    initial_value: '""'

  - id: last_move_white
    type: std::string
    initial_value: '""'

  - id: last_move_black
    type: std::string
    initial_value: '""'

  - id: display_message_white
    type: std::string
    initial_value: '"{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"Rapid (15+10)\"}"'

  - id: display_message_black
    type: std::string
    initial_value: '"{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"Rapid (15+10)\"}"'

# we updating all the time the values of hall sensors
interval:
  - interval: $hall_sensor_intervall_game
    then:
      - lambda: |-
          if (id(game_running)) {
            id(update_all_hall_sensors).execute();
            id(update_raw_position_current).execute();
            id(compare_raw_position).execute();
          }
  - interval: $hall_sensor_intervall_idle
    then:
      - lambda: |-
          if (!id(game_running)) {
            id(update_all_hall_sensors).execute();
            id(update_raw_position_current).execute();
            id(compare_raw_position).execute();
            id(lichess_game_id).update();
          }
  - interval: 1000ms
    then:
      - script.execute: update_timer
      - script.execute: check_opponent_at_board_select

# Declare a LCD menu
graphical_display_menu:
  id: my_menu
  # display: oled_test
  font: roboto_10
  active: false
  mode: rotary
  on_enter:
    then:
      lambda: |-
        if (id(halfmove_counter) > 0) {
          // stop the clock during a game
          id(game_running) = false;
          // the game can be also started by the pause button
          id(led_update_move_over).execute();
          // reset display messages, if any
          id(display_message_black) = "";
          id(display_message_white) = "";
        } 
  on_leave:
    then:
      lambda: |-
        if (id(halfmove_counter) > 0) {
          // start the clock during a game
          id(game_running) = true;
          // the game can be also started by the pause button
          id(led_update_move_over).execute();
        } 
  on_redraw:
    then:
      - component.update: oled_white
      #- component.update: oled_black
  items:
    - type: command
      text: 'PGN SEND'
      on_value:
        then:
          - lambda: |-
              id(send_telegram_message).execute();
    - type: select
      immediate_edit: false
      text: 'TIMER'
      select: chess_time_control
    - type: select
      immediate_edit: false
      text: 'PROMOTION'
      select: pawn_promotion
    - type: command
      text: 'TAKE BACK'
      on_value:
        then:
          - lambda: |-
              id(take_back).execute();
    - type: menu
      text: 'LICHESS'
      items:
        - type: command
          text: 'New game'
          on_value:
            then:
              - lambda: |-
                  id(lichess_new_game_button).press();
        - type: command
          text: 'Resign'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"resign\"}");
        - type: command
          text: 'Claim victory'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"claim-victory\"}");
        - type: command
          text: 'Draw (yes)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"draw\", \"parameter\": \"yes\"}");
        - type: command
          text: 'Draw (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"draw\", \"parameter\": \"no\"}");
        - type: command
          text: 'Takeback (yes)'
          on_value:
            then:
              - lambda: |-
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"takeback\", \"parameter\": \"yes\"}");
        - type: command
          text: 'Takeback (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"takeback\", \"parameter\": \"no\"}");
        - type: command
          text: 'Abort game'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(lichess_api_call).publish_state("{}"); 
                  id(lichess_api_call).publish_state("{\"type\": \"abort\"}");
        - type: select
          immediate_edit: false
          text: 'User'
          select: lichess_account
        - type: select
          immediate_edit: false
          text: 'Opponent'
          select: lichess_opponent
        - type: select
          immediate_edit: False
          text: 'Opponent at board'
          select: lichess_opponent_at_board
        - type: back
          text: 'Back'
    - type: command
      text: 'Restart Board'
      on_value:
        then:
          - lambda: |-
              id(device_factory_reset).press();

# Define internal outputs
output:
  # outputs for analog multiplexer
  - platform: gpio
    pin: GPIO14
    id: output_s1
  - platform: gpio
    pin: GPIO25
    id: output_s2
  - platform: gpio
    pin: GPIO26
    id: output_s3
  - platform: gpio
    pin: GPIO27
    id: output_s4
# beep
  - platform: gpio
    id: beep_switch
    pin:
      number: 4
      mode:
        output: true
      inverted: false

switch:

# LED color to move
  - platform: gpio
    id: led_white_to_move
    icon: mdi:led-on
    name: White to move
    pin:
      pcf8574: pcf8574_w
      number: 2
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 1

  - platform: gpio
    id: led_black_to_move
    icon: mdi:led-on
    name: Black to move
    pin:
      pcf8574: pcf8574_b
      number: 2
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 3

  - platform: gpio
    id: led_white_nonvalid_move
    icon: mdi:led-on
    name: White (non valid move)
    pin:
      pcf8574: pcf8574_w
      number: 0
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 5

  - platform: gpio
    id: led_white_valid_move
    icon: mdi:led-on
    name: White (valid move)
    pin:
      pcf8574: pcf8574_w
      number: 1
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 2

  - platform: gpio
    id: led_black_nonvalid_move
    icon: mdi:led-on
    name: Black (non valid move)
    pin:
      pcf8574: pcf8574_b
      number: 0
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 6

  - platform: gpio
    id: led_black_valid_move
    icon: mdi:led-on
    name: Black (valid move)
    pin:
      pcf8574: pcf8574_b
      number: 1
      mode:
        output: true
      inverted: true
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 4

button:
  - platform: factory_reset
    name: Restart with Factory Default Settings
    id: device_factory_reset
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 100
  - platform: template
    name: "PGN to telegram"
    id: pgn_to_telegram
    on_press: 
      then:
        lambda: |-
          id(send_telegram_message).execute();
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: -1
  - platform: template
    name: New Lichess Game
    id: lichess_new_game_button
    on_press:
      then:
        - lambda: |-
            id(lichess_create_new_game).execute();
            id(simulate_cancel).press();
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"waiting for new game ...\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"waiting for new game ...\", \"line_1\": \"" + id(chess_time_control).state + "\"}";           
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: -1
  - platform: template
    name: simulate button pause
    id: simulate_button_pause
    on_press:
      then:
        - lambda: |-
            id(game_running) = !id(game_running);
            id(led_update_move_over).execute(); 
            if (id(halfmove_counter) == 0) {
              // let displays show the time control
              id(display_message_white) = "";
              id(display_message_black) = "";
            }           
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 10
  - platform: template
    name: simulate_up
    id: simulate_up
    on_press:
      then:
        - display_menu.up: my_menu
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 12
  - platform: template
    name: simulate_down
    id: simulate_down
    on_press:
      then:
        - display_menu.down: my_menu
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 13
  - platform: template
    name: simulate_set
    id: simulate_set
    on_press:
      then:
        - if:
              condition:
                display_menu.is_active: my_menu
              then:
                - display_menu.enter: my_menu
              else:
                - display_menu.show:  my_menu
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 14
  - platform: template
    name: simulate_cancel
    id: simulate_cancel
    on_press:
      then:
        - display_menu.show_main:   my_menu
        - display_menu.hide:  my_menu 
        - lambda: |-
            id(display_message_black) = "";
            id(display_message_white) = "";    
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 15
  - platform: template
    name: simulate_take_back
    id: simulate_take_back
    on_press:
      then:
        - lambda: |-
            id(take_back).execute();        
    web_server:
      sorting_group_id: sorting_group_simulation
      sorting_weight: 16


binary_sensor:
  - platform: gpio
    name: "White finished"
    id: button_white_finished
    pin:
      pcf8574: pcf8574_w
      number: 3
      mode:
        input: true
      inverted: true
    on_press:
      then:
        - lambda: |-
            // only during the gave
            if (id(game_running) && id(white_to_move) ) {
              // if our turn, we store the move and let opponent play
                id(store_move).execute();                
            }
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 1
  - platform: gpio
    pin:
      pcf8574: pcf8574_b
      number: 3
      mode:
        input: true
      inverted: true
    name: "Black finished"
    id: button_black_finished
    on_press:
      then:
        - lambda: |-
            // only during the gave
            if (id(game_running)) {
              // if our turn, we store the move and let opponent play
              if (id(!white_to_move))
              {
                id(store_move).execute();
              }
            } else if (id(halfmove_counter) == 0) {
              // at the begin of the game black can start the clock by button
              id(game_running) = true;
              // the game can be also started by the pause button
              id(led_update_move_over).execute();
            }  

    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 2
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Pause"
    id: button_pause
    on_press:
      then:
        - lambda: |-
            id(game_running) = !id(game_running);
            id(led_update_move_over).execute();
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 3
  - platform: gpio
    pin:
      number: GPIO17
      mode: INPUT_PULLUP
      inverted: true
    name: "Back"
    id: button_back
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 4
  - platform: gpio
    pin:
      number: GPIO16
      mode: INPUT_PULLUP
      inverted: true
    name: "Up"
    id: button_up
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 5
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 6
      mode:
        input: true
      inverted: true
    name: "Down"
    id: button_down
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 6
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "Set"
    id: button_set
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 7
  - platform: template
    name: initial_position_set
    id: initial_position_set
    internal: true
    lambda: |-
      bool init_position = true;
      for (int i = 0; i < 64; i++) {
        if (id(raw_position_current)[i]  != id(raw_position_init)[i])
        {
          init_position = false;
          break;
        }
      }
      return init_position;
    on_press:
      then:
        - lambda: |-
            if (id(halfmove_counter) > 0) {
              id(send_telegram_message).execute();
            }
            
            id(reset_all_values).execute();
            // notfiy -> ready for new game

select:
  - platform: template
    name: "Time Control"
    id: chess_time_control
    optimistic: true
    options:
      - "Blitz (3+0)"
      - "Blitz (3+2)"
      - "Blitz (5+0)"
      - "Blitz (5+3)"
      - "Rapid (10+0)"
      - "Rapid (10+5)"
      - "Rapid (15+10)"
      - "Classical (30+0)"
      - "Classical (60+0)"
      - "Classical (90+30)"
    initial_option: "Rapid (15+10)"
    on_value: 
      then:
        - lambda: |-
            // not during the game
            if (id(halfmove_counter) == 0) {
              if (x == "Blitz (3+0)") {
                // Set time control to Blitz (3+0)
                id(time_control_duration) = 180;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (3+2)") {
                // Set time control to Blitz (3+2)
                id(time_control_duration) = 180;
                id(time_control_increment) = 2;
              } else if (x == "Blitz (5+0)") {
                // Set time control to Blitz (5+0)
                id(time_control_duration) = 300;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (5+3)") {
                // Set time control to Blitz (5+3)
                id(time_control_duration) = 300;
                id(time_control_increment) = 3;
              } else if (x == "Rapid (10+0)") {
                // Set time control to Rapid (10+0)
                id(time_control_duration) = 600;
                id(time_control_increment) = 0;
              } else if (x == "Rapid (10+5)") {
                // Set time control to Rapid (10+5)
                id(time_control_duration) = 600;
                id(time_control_increment) = 5;
              } else if (x == "Rapid (15+10)") {
                // Set time control to Rapid (15+10)
                id(time_control_duration) = 900;
                id(time_control_increment) = 10;
              } else if (x == "Classical (30+0)") {
                // Set time control to Classical (30+0)
                id(time_control_duration) = 1800;
                id(time_control_increment) = 0;
              } else if (x == "Classical (60+0)") {
                // Set time control to Classical (60+0)
                id(time_control_duration) = 3600;
                id(time_control_increment) = 0;
              } else if (x == "Classical (90+30)") {
                // Set time control to Classical (90+30)
                id(time_control_duration) = 5400;
                id(time_control_increment) = 30;
              }

              id(time_control_timer_black) = id(time_control_duration);
              id(time_control_timer_white) = id(time_control_duration);

              id(timer_black).update();
              id(timer_white).update();

            } else {
              // select previos selected option
            }

            // overwrite display message, if we are in init state
            if (id(display_message_white).find("white player") != std::string::npos) {
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"white player\", \"line_1\": \"" + x + "\"}";
            }

            if (id(display_message_black).find("black player") != std::string::npos) {
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"black player\", \"line_1\": \"" + x + "\"}";
            }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 1
  - platform: template
    name: "Promotion to"
    id: pawn_promotion
    optimistic: true
    options:
      - "Queen"
      - "Rook"
      - "Bishop"
      - "Knight"
    initial_option: "Queen"
    on_value: 
      then:
        lambda: |-
          if (x == "Queen") {
            // Set promotion to Queen
            id(default_pawn_promotion_to) = "Q";
          } else if (x == "Rook") {
            // Set promotion to Rook
            id(default_pawn_promotion_to) = "R";
          } else if (x == "Bishop") {
            // Set promotion to Bishop
            id(default_pawn_promotion_to) = "B";
          } else if (x == "Knight") {
            // Set promotion to Knight
            id(default_pawn_promotion_to) = "N";
          }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 2
  - platform: template
    name: "Account"
    id: lichess_account
    internal: False
    optimistic: true
    options:
      - !secret chessboard_player_a
      - !secret chessboard_player_b
      - !secret chessboard_player_c
    initial_option: !secret chessboard_player_c
    on_value: 
      then:
        lambda: |-
          id(update_lichess_token).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 1
  - platform: template
    name: "Opponent"
    id: lichess_opponent
    internal: False
    optimistic: true
    options:
      - !secret chessboard_opponent_a
      - !secret chessboard_opponent_b
      - !secret chessboard_opponent_c
      - "random"
      - "AI_1"
      - "AI_2"
      - "AI_3"
      - "AI_4"
      - "AI_5"
      - "AI_6"
      - "AI_7"
      - "AI_8"
    initial_option: AI_1
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 2
  - platform: template
    name: "Seek Color"
    id: lichess_seek_color
    internal: False
    optimistic: true
    options:
      - "random"
      - "white"
      - "black"
    initial_option: "random"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 3
  - platform: template
    name: "Seek Rated"
    id: lichess_seek_rated
    internal: False
    optimistic: true
    options:
      - "rated"
      - "not rated"
    initial_option: "not rated"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 4
  - platform: template
    name: "Opponent at board"
    id: lichess_opponent_at_board
    internal: False
    optimistic: true
    options:
      - "yes"
      - "no"
    initial_option: "no"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 6
sensor:
  - platform: adc
    pin: GPIO34
    name: current_hall_sensor_1
    id: current_hall_sensor_1
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO35
    name: current_hall_sensor_2
    id: current_hall_sensor_2
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO36
    name: current_hall_sensor_3
    id: current_hall_sensor_3
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO39
    name: current_hall_sensor_4
    id: current_hall_sensor_4
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never

text_sensor:

  # used just to define out-sensor for ha to be set as ha-input sensor
  - platform: template
    name: "Lichess Last Move (out)"
    id: lichess_last_move
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 7

  - platform: homeassistant
    name: "Lichess Last Move"
    id: lichess_last_move_in
    entity_id: sensor.chessboard_lichess_last_move_out
    internal: false
    on_value:
      then:
        - lambda: |-
            id(lichess_handle_last_move).execute();
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 4

  # used just to define out-sensor for ha to be set as ha-input sensor
  - platform: template
    name: "Lichess Last Event (out)"
    id: lichess_last_event
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 6

  - platform: homeassistant
    name: "Lichess Last Event"
    id: lichess_last_event_in
    entity_id: sensor.chessboard_lichess_last_event_out
    internal: false
    on_value:
      then:
        - lambda: |-
            id(lichess_handle_new_event).execute();
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 3

  - platform: template
    name: "Lichess Stream Events"
    id: lichess_stream_events
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 1

  - platform: template
    name: "Lichess Game Id"
    id: lichess_game_id
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 7

  - platform: template
    name: "Lichess Api Call"
    id: lichess_api_call
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 2

  - platform: template
    name: "Lichess Token"
    id: lichess_token
    lambda: >- 
      return id(chessboard_token_current);
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 5

  - platform: template
    name: "Hall Array Part Black"
    id: array_part_1
    internal: false
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 10
  - platform: template
    name: "Hall Array Part White"
    id: array_part_2
    internal: false
    web_server:
      sorting_group_id: sorting_group_sensors
      sorting_weight: 11
  - platform: template
    name: "Timer (white)"
    id: timer_white
    lambda: |-
      if (id(time_control_timer_white) > 0 ) {
        int minutes = id(time_control_timer_white) / 60;
        int seconds = id(time_control_timer_white) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";
        return e;
      }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 3
  - platform: template
    name: "Timer (black)"
    id: timer_black
    lambda: |-
      if (id(time_control_timer_black) > 0 ) {
        int minutes = id(time_control_timer_black) / 60;
        int seconds = id(time_control_timer_black) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";
        return e;
      }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 4


  - platform: template
    id: last_move_pgn_sensor
    name: "PGN Move"
    lambda: |-
      std::string pgn_move = id(last_move_pgn);
      if (pgn_move.length() > 0 ) {
        int fullmove = (int)(id(halfmove_counter) / 2.) + 1;
        if (id(halfmove_counter) % 2 == 0) {
            pgn_move += " ...";
        } else {
          pgn_move = "... " + pgn_move; 
        }
        pgn_move = std::to_string(fullmove) + ". " + pgn_move;
      }
      return pgn_move;
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 0
  - platform: template
    id: pgn_history_1
    name: "PGN_1"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      return cutted_history.substr(0, 255);
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 1
  - platform: template
    id: pgn_history_2
    name: "PGN_2"
    lambda: |-
      std::string cutted_history = id(pgn_history);      
      if (cutted_history.length() > 255) {
        return cutted_history.substr(255, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 2
  - platform: template
    id: pgn_history_3
    name: "PGN_3"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*2;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 3
  - platform: template
    id: pgn_history_4
    name: "PGN_4"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*3;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 4
  - platform: template
    id: pgn_history_5
    name: "PGN_5"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*4;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 5
  - platform: template
    id: pgn_history_6
    name: "PGN_6"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*5;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 6
  - platform: template
    id: pgn_history_7
    name: "PGN_7"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*6;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 7
  - platform: template
    id: pgn_history_8
    name: "PGN_8"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*7;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 8
  - platform: template
    id: pgn_history_9
    name: "PGN_9"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*8;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 9

  - platform: template
    name: "8"
    id: line_8
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 1

  - platform: template
    name: "7"
    id: line_7
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 2

  - platform: template
    name: "6"
    id: line_6
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 3

  - platform: template
    name: "5"
    id: line_5
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 4

  - platform: template
    name: "4"
    id: line_4
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 5

  - platform: template
    name: "3"
    id: line_3
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 6

  - platform: template
    name: "2"
    id: line_2
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 7

  - platform: template
    name: "1"
    id: line_1
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 8

script:
  - id: update_array_text
    mode: queued
    then:
      - lambda: |-
          std::string part1;
          std::string part2;
          std::string* target = &part1;

          for (size_t i = 0; i < 64; i++) {
            // Round to 2 decimal places
            int rounded = static_cast<int>(id(voltage_field_current)[i] * 100);
            float rounded_val = rounded / 100.0f;

            char buffer[6]; // Max "3.99\0"
            snprintf(buffer, sizeof(buffer), "%.2f", rounded_val);
            if (rounded >= 0) {
              *target += '+';
            }
            *target += buffer;
            *target += ((i + 1) % 8 == 0) ? '\n' : ' ';

            if (i == 31) {
              target = &part2; // Switch to second sensor
            }
          }

          id(array_part_1).publish_state(part1);
          id(array_part_2).publish_state(part2);

  - id: take_back
    then:
      - lambda: |-
          // one take back only
          if (id(pgn_history) != id(pgn_history_take_back)) {

            // if promotion to queen, we have to reduce the number of queens
            if (id(last_move_pgn).find("=Q") != std::string::npos) {
              if (id(white_to_move) && id(n_queens_white) > 1 ) {
                id(n_queens_white) -= 1;
              } else  if (!id(white_to_move) && id(n_queens_black) > 1) {
                  id(n_queens_black) -= 1;
              }
            }

            // toggle who to move
            id(white_to_move) = !id(white_to_move);

            // replace last fen by take back
            for (int i = 0; i < 72; i++) {
              id(fen_position_current)[i] = id(fen_position_last)[i];
              id(fen_position_last)[i] = id(fen_position_take_back)[i];
            };

            // replace last position by take back
            for (int i = 0; i < 64; i++) {              
              id(raw_position_current)[i] = id(raw_position_last)[i];  
              id(raw_position_last)[i] = id(raw_position_take_back)[i]; 
            };

            // counter back
            id(halfmove_counter) -= 1;

            // pgn history
            int previous_length = id(pgn_history).length();
            id(pgn_history) = id(pgn_history_take_back);
            id(last_move_pgn) = id(last_move_pgn_take_back);

            // update led
            id(led_update_move_over).execute();

            // update pgn sensors
            id(pgn_history_1).update();
            // update furhter sensors (take previous length)
            if ( previous_length > 255) {
              id(pgn_history_2).update();  
            }
            if ( previous_length > 510) {
              id(pgn_history_3).update();  
            }
            if ( previous_length > 765) {
              id(pgn_history_4).update();  
            }
            if ( previous_length > 1020) {
              id(pgn_history_5).update();  
            }
            if ( previous_length > 1275) {
              id(pgn_history_6).update();  
            }
            if ( previous_length > 1530) {
              id(pgn_history_7).update();  
            }
            if ( previous_length > 1785) {
              id(pgn_history_8).update();  
            }
            if ( previous_length > 2040) {
              id(pgn_history_9).update();  
            }
                
            // update further sensors
            id(update_chess_board).execute();
            id(last_move_pgn_sensor).update();
            // update fen string
            id(fen_position_last_arr_to_string).execute();
          }

  - id: update_chess_board
    then:
      - lambda: |-
            //  init some variables
            const std::string border_line = "---------------------------------------------------------------";
            int line_counter = 0;
            std::string line_representation = "|";
            id(fen_position_chessboard) = border_line + "\n|";

            // iterate over current fen raw position  
            for (int i=0; i<64; i++) {
              // extend current line
              // Select first char from fen string
              line_representation += id(chess_symbols)[id(fen_position_current)[i].at(0)] + "|";
              id(fen_position_chessboard) += id(chess_symbols_telegram)[id(fen_position_current)[i].at(0)] + "|";

              if ((i + 1) % 8 == 0) { // store line
                
                int line_counter = (int)(i / 8);

                // update line
                if (line_counter == 0)
                {
                  id(line_8).publish_state(line_representation);
                } else if (line_counter == 1)
                {
                  id(line_7).publish_state(line_representation);
                } else if (line_counter == 2)
                {
                  id(line_6).publish_state(line_representation);
                } else if (line_counter == 3)
                {
                  id(line_5).publish_state(line_representation);
                } else if (line_counter == 4)
                {
                  id(line_4).publish_state(line_representation);
                } else if (line_counter == 5)
                {
                  id(line_3).publish_state(line_representation);
                } else if (line_counter == 6)
                {
                  id(line_2).publish_state(line_representation);
                } else if (line_counter == 7)
                {
                  id(line_1).publish_state(line_representation);
                }

                if  (line_counter != 7) {
                  id(fen_position_chessboard) += "\n" + border_line + "\n|";
                } else {
                  id(fen_position_chessboard) += "\n" + border_line;
                }               
                line_representation = "|";

              } 
            }

  - id: update_timer
    then:
      - lambda: |-
          if ( id(game_running) ) // we are in the game or no pause pressed
          {
            if (id(white_to_move)) {
              if (id(time_control_timer_white) > 0 )
              {
                id(time_control_timer_white) -= 1;
                id(timer_white).update();
              }
            } else {
              if (id(time_control_timer_black) > 0 ) {
                id(time_control_timer_black) -= 1;
                id(timer_black).update();
              }
            }
          }

  - id: send_telegram_message
    then:
      - script.execute: create_full_pgn
      - http_request.post:
          url: !secret telegram_cheesboard_url
          headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_a
            text: !lambda |-
                return id(pgn_full);
              
      - http_request.post:
          url: !secret telegram_cheesboard_url
          headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_b
            text: !lambda |-
                return id(pgn_full);

  - id: create_full_pgn
    then:
      - lambda: |-
          auto time = id(sntp_time).now();

          std::string year = std::to_string(time.year);
          std::string month = std::to_string(time.month);
          std::string month_prefix = (time.month < 10 ? "0" : "");
          std::string day_prefix = (time.day_of_month < 10 ? "0" : "");
          std::string day = std::to_string(time.day_of_month);
          std::string hour_prefix = (time.hour < 10 ? "0" : "");
          std::string hour = std::to_string(time.hour);
          std::string minute_prefix = (time.minute < 10 ? "0" : "");
          std::string minute = std::to_string(time.minute);
          std::string second_prefix = (time.second < 10 ? "0" : "");
          std::string second = std::to_string(time.second);

          std::string pgn_header = "[Event \"Chessboard Game\"]\n";
          pgn_header += "[Date \"" + year + "." + month_prefix  + month + "." + day_prefix  + day  + "\"]\n";
          if (id(lichess_game_running)) {
            if (id(lichess_my_color) == "white") {
              pgn_header += "[White \"Chessboard-Player\"]\n";
              pgn_header += "[Black \"" + id(lichess_opponent_name) + "\"]\n";              
            } else {
              pgn_header += "[White \"" + id(lichess_opponent_name) + "\"]\n"; 
              pgn_header += "[Black \"Chessboard-Player\"]\n";              
            }
          } else {
            pgn_header += "[White \"Chessboard-Player A\"]\n";
            pgn_header += "[Black \"Chessboard-Player B\"]\n";
          }
          pgn_header += "[UTCDate \"" + year + "." + month_prefix  + month + "." +  day_prefix  + day + "\"]\n";
          pgn_header += "[UTCTime \"" + hour_prefix + hour + ":" + minute_prefix + minute + ":" + second_prefix + second + "\"]\n";
          pgn_header += "[Variant \"Standard\"]\n";
          pgn_header += "[TimeControl \"" + std::to_string(id(time_control_duration)) + "+" + std::to_string(id(time_control_increment))+ "\"]";

          pgn_header += "\n\n" + id(pgn_history);
          
          if (id(fen_position_chessboard) != "") {
            pgn_header += "\n{\n";
            pgn_header += id(fen_position_chessboard) + "\n}";
          }

          id(pgn_full) = pgn_header;

  - id: reset_all_values 
    then:
      - lambda: |-
          id(reset_fen_position).execute();
          id(reset_raw_position).execute();
          id(reset_voltage_field).execute();
          id(reset_pgn_values).execute();
          id(white_to_move) = true;
          id(led_update_move_over).execute();
          id(game_running) = false;
          
          id(halfmove_counter) = 0;
          id(halfmove_or_capture_counter) = 0;
          id(current_move_from) = 0;
          id(current_move_to) = 0;
          id(current_move_type) = "";
          id(current_move_uci) = "";
          id(valid_move) = false;
          id(moved_piece) = "";

          id(lichess_is_my_turn) = false;
          id(lichess_my_color) = "";

          id(sync_time_control).execute();
          id(time_control_timer_black) = id(time_control_duration);
          id(time_control_timer_white) = id(time_control_duration);
          
          id(n_queens_white) = 1;
          id(n_queens_black) = 1;

          id(timer_black).update();
          id(timer_white).update();

          id(lichess_last_move).publish_state(std::string(""));
          id(lichess_game_id).publish_state(std::string("idle"));
          id(lichess_token).update();
          id(lichess_game_running) = false;
          id(current_move_uci_lichess) = "";

  - id: update_pgn_history
    then:
      - lambda: |-
          // add current pgn to history
          if (id(white_to_move)) { // white
            std::string fullmove = std::to_string((int)(id(halfmove_counter) / 2.) + 1);
            id(pgn_history) = id(pgn_history) + fullmove + ". " + id(last_move_pgn);
          } else { // black
            id(pgn_history) = id(pgn_history) + " " + id(last_move_pgn) + "\n";
          }

          // allways update first pgn          
          id(pgn_history_1).update();
          // update furhter sensors (pgn can not be shorten in game)
          int curr_pgn_length = id(pgn_history).length();
          if ( curr_pgn_length > 255) {
            id(pgn_history_2).update();  
          }
          if ( curr_pgn_length > 510) {
            id(pgn_history_3).update();  
          }
          if ( curr_pgn_length > 765) {
            id(pgn_history_4).update();  
          }
          if ( curr_pgn_length > 1020) {
            id(pgn_history_5).update();  
          }
          if ( curr_pgn_length > 1275) {
            id(pgn_history_6).update();  
          }
          if ( curr_pgn_length > 1530) {
            id(pgn_history_7).update();  
          }
          if ( curr_pgn_length > 1785) {
            id(pgn_history_8).update();  
          }
          if ( curr_pgn_length > 2040) {
            id(pgn_history_9).update();  
          }

  - id: reset_pgn_values
    then:
      - lambda: |-
          id(last_move_pgn) = "";
          id(last_move_pgn_additional) = "";
          id(last_move_pgn_take_back) = "";
          id(pgn_history) = "";
          id(pgn_history_take_back) = "";
          id(pgn_full) = "";
          id(pgn_history_1).update();
          id(pgn_history_2).update();
          id(pgn_history_3).update();
          id(pgn_history_4).update();
          id(pgn_history_5).update();
          id(pgn_history_6).update();
          id(pgn_history_7).update();
          id(pgn_history_8).update();
          id(pgn_history_9).update();

          id(last_move_pgn_sensor).update();

  - id: reset_fen_position
    then:
      - lambda: |-
          for (int i = 0; i < 72; i++) {
            std::string curr_value = id(fen_position_init)[i];
            id(fen_position_take_back)[i] = curr_value;
            id(fen_position_last)[i] = curr_value;   
            id(fen_position_current)[i] = curr_value;          
          };
          id(update_chess_board).execute();
          id(fen_position_chessboard) = "";
          id(fen_position_last_arr_to_string).execute();

  - id: reset_raw_position
    then:
      - lambda: |-
          for (int i = 0; i < 64; i++) {
            int curr_value = id(raw_position_init)[i];
            id(raw_position_take_back)[i] = curr_value; 
            id(raw_position_last)[i] = curr_value;   
            id(raw_position_current)[i] = curr_value;          
          };

  - id: reset_voltage_field
    then:
      - lambda: |-
          for (int i = 0; i < 64; i++) {
            float curr_value = id(voltage_field_offset)[i];
            id(voltage_field_current)[i] = curr_value;   
          };

  - id: led_update_move_over
    then:
      - lambda: |-
          if (id(white_to_move)) { 
            if (!id(led_white_to_move).state && id(game_running)) {
              id(led_white_to_move).turn_on();
            }
            if (id(led_black_to_move).state || !id(game_running)) {
              id(led_black_to_move).turn_off();
            }
          } else { // black
            if (!id(led_black_to_move).state && id(game_running)) {
              id(led_black_to_move).turn_on();
            }
            if (id(led_white_to_move).state || !id(game_running)) {
              id(led_white_to_move).turn_off();
            }
          }
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          }
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          }

  - id: inform_game_over
    then:
      - lambda: |-
          // turn all led's off
          id(led_turn_all_off).execute();

          bool white_won = (bool)(id(last_move_pgn_additional) == " 1-0" || (id(last_move_pgn_additional) == "#" && id(white_to_move)));
          bool black_won = (bool)(id(last_move_pgn_additional) == " 0-1" || (id(last_move_pgn_additional) == "#" && !id(white_to_move)));
          bool draw = (bool)(id(last_move_pgn_additional) == " 1/2-1/2");

          if (white_won) { 
            id(led_white_valid_move).turn_on(); // green
            id(led_black_nonvalid_move).turn_on(); // red
            id(display_message_black) = "LOST";
            id(display_message_white) = "WINNER";
          }

          if (black_won) {
              id(led_black_valid_move).turn_on(); // green
              id(led_white_nonvalid_move).turn_on(); // red
              id(display_message_black) = "WINNER";
              id(display_message_white) = "LOST";
          }

          if (draw) {
            id(led_white_to_move).turn_on(); // blue
            id(led_black_to_move).turn_on(); // blue
            id(display_message_black) = "DRAW";
            id(display_message_white) = "DRAW";
          }

  - id: led_update_check_move
    then:
      - lambda: |-
          // if no valid move found, rise flag
          if (id(valid_move)) {
            // update leds
            if (id(white_to_move)) {
              id(led_white_nonvalid_move).turn_off();
              id(led_white_valid_move).turn_on();
              id(led_white_to_move).turn_off();
            } else {
              id(led_black_nonvalid_move).turn_off();
              id(led_black_valid_move).turn_on();  
              id(led_black_to_move).turn_off();            
            }
          } else {
            if (id(white_to_move)) {
              id(led_white_nonvalid_move).turn_on();
              id(led_white_valid_move).turn_off();
              id(led_white_to_move).turn_off();
            } else {
              id(led_black_nonvalid_move).turn_on();
              id(led_black_valid_move).turn_off();
              id(led_black_to_move).turn_off();                
            }
          }

  - id: led_turn_all_off
    then:
      - lambda: |-
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          }
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          }             

  - id: sync_time_control
    then:
      - lambda: |-
          auto call = id(chess_time_control).make_call();
          if (id(time_control_duration) == 120 && id(time_control_increment) == 1) {
            call.set_option("Bullet (2+1)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 0) {
            call.set_option("Blitz (3+0)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 2) {
            call.set_option("Blitz (3+2)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 0) {
            call.set_option("Blitz (5+0)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 3) {
            call.set_option("Blitz (5+3)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 0) {
            call.set_option("Rapid (10+0)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 5) {
            call.set_option("Rapid (10+5)");
          } else if (id(time_control_duration) == 900 && id(time_control_increment) == 10) {
            call.set_option("Rapid (15+10)");
          } else if (id(time_control_duration) == 1800 && id(time_control_increment) == 0) {
            call.set_option("Classical (30+0)");
          } else if (id(time_control_duration) == 3600 && id(time_control_increment) == 0) {
            call.set_option("Classical (60+0)");
          } else if (id(time_control_duration) == 5400 && id(time_control_increment) == 30) {
            call.set_option("Classical (90+30)");
          } else {
            call.set_option("Rapid (15+10)");  // Default option
          }
          call.perform();

  - id: store_move
    then:
      - lambda: |-
          // get current png move
          id(move_analyser).execute();
          // store move if valid only
          if (id(valid_move)) {
            // store previous pgn history
            id(pgn_history_take_back) = id(pgn_history);

            //update pgn sensors
            id(update_pgn_history).execute();

            // update fen move, castling, enpassant, move counts
            id(update_fen_additional_fields).execute();

            // update n queens
            id(update_number_of_queens).execute();

            // replace last fen by current fen
            for (int i = 0; i < 72; i++) {
              id(fen_position_take_back)[i] = id(fen_position_last)[i];
              id(fen_position_last)[i] = id(fen_position_current)[i];          
            };

            // update fen string current to last
            id(fen_position_last_arr_to_string).execute();

            // replace last position by current position
            for (int i = 0; i < 64; i++) {
              id(raw_position_take_back)[i] = id(raw_position_last)[i];
              id(raw_position_last)[i] = id(raw_position_current)[i];   
            };

            // do lichess calls and updates
            if (id(lichess_game_running) ) {
              // let lichess know about my move
              std::string move_body = "{\"type\": \"makeMove\", \"move\": \"" + id(current_move_uci) + "\"}";
              if(id(lichess_is_my_turn) == true) {   
                // send the move to lichess           
                id(lichess_api_call).publish_state(move_body);              
              } else {
                if( id(lichess_opponent_at_board).state == "yes") {
                  // switch to oppoents token
                  std::string token_body = "{\"type\": \"overwriteToken\", \"token\": \"" + id(chessboard_token_opponent) + "\"}";
                  id(lichess_api_call).publish_state(token_body);
                  delay(100); // do a short delay 
                  // make a move for the opponent
                  id(lichess_api_call).publish_state(move_body); 
                  delay(100); // do a short delay 
                  // switch token back
                  token_body = "{\"type\": \"overwriteToken\", \"token\": \"" + id(chessboard_token_current) + "\"}";
                  id(lichess_api_call).publish_state(token_body);
                }
              }
              // toggle turns
              id(lichess_is_my_turn) = !id(lichess_is_my_turn);
            }

            // reset display messages, if any
            id(display_message_black) = "";
            id(display_message_white) = "";

            // update last move
            if (id(white_to_move)) {
              id(last_move_white) = id(current_move_uci);
            } else {
              id(last_move_black) = id(current_move_uci);
            }

            // game finished on board ?
            if (id(last_move_pgn_additional) == "#" || id(last_move_pgn_additional) == " 1/2-1/2" ){
              id(game_running) = false;
              // game over
              id(inform_game_over).execute();
            } else {              
              // update timer
              id(time_control_add_increment).execute();
              // toggle white_to_move
              id(white_to_move) = !id(white_to_move);
              // increase coutner of halfmoves
              id(halfmove_counter) += 1;
              // there is no moved piece
              id(moved_piece) = "";
              // reset valid move
              id(valid_move) = false;
              // reset move type
              id(current_move_type) = "";
              // reset led for next move
              id(led_update_move_over).execute();   
            }
          }

  - id: update_number_of_queens
    then:
      - lambda: |-
          if (id(last_move_pgn).find("=Q") != std::string::npos){
            // encrease number of queens
            if (id(white_to_move)) {
              id(n_queens_white) += 1;
            } else {
              id(n_queens_black) += 1;
            }            
          }
          // decrease number of queens
          if (id(current_move_type) == "TAKE") {
            std::string fen_name_to = id(fen_position_last)[id(current_move_to)];
            if (fen_name_to == "q") {
              id(n_queens_black) -= 1;
            }
            if (fen_name_to == "Q") {
              id(n_queens_white) -= 1;
            }
          }
  
  - id: time_control_add_increment
    then:
      - lambda: |-
          if (id(white_to_move)){
            id(time_control_timer_white) += id(time_control_increment);
          } else {
            id(time_control_timer_black) += id(time_control_increment);
          }

  - id: update_uci_notation
    then:
      - lambda: |-
          // create uci move for lichess
          std::string field_name_from = id(chess_field_names)[id(current_move_from)];
          std::string field_name_to = id(chess_field_names)[id(current_move_to)];
          std::string fen_name_from = id(fen_position_last)[id(current_move_from)];
          std::string uci_move = field_name_from + field_name_to;

          // we have to add promotion to UCI
          bool move_or_take = (bool)(id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE");
          bool promotion_move = (bool)(fen_name_from  == "P" || fen_name_from  == "p" );
          if (move_or_take && promotion_move) {  

            // white
            if (id(white_to_move) && (field_name_to.find('8') != std::string::npos)) {
              // add promotion piece to uci notation
              uci_move += id(default_pawn_promotion_to);
              std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
            }

            // black
            if (!id(white_to_move) && (field_name_to.find('1') != std::string::npos)) {
              // add promotion piece to uci notation
              uci_move += id(default_pawn_promotion_to);
              std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
            }
          }
          
          id(current_move_uci) = uci_move;

  - id: fen_position_last_arr_to_string
    then:
      - lambda: |-
            // transform array to fen-string
            std::string raw_fen;
            int emptyCount = 0;            
            for (int row = 0; row < 8; ++row) {
                for (int col = 0; col < 8; ++col) {
                    std::string piece = id(fen_position_last)[row * 8 + col];
                    if (piece == "0") {
                        ++emptyCount;
                    } else {
                        if (emptyCount > 0) {
                            raw_fen += std::to_string(emptyCount);
                            emptyCount = 0;
                        }
                      raw_fen += piece;
                    }
                }
                if (emptyCount > 0) {
                    raw_fen += std::to_string(emptyCount);
                    emptyCount = 0;
                }
                if (row < 7) raw_fen += "/";
            }

            // color to move
            raw_fen += " " + id(fen_position_last)[64];

            // castling rights
            raw_fen += " " + id(fen_position_last)[65] + id(fen_position_last)[66] + id(fen_position_last)[67] + id(fen_position_last)[68];

            // en passant
            raw_fen += " " + id(fen_position_last)[69];

            // half move since last take
            raw_fen += " " + id(fen_position_last)[70];

            // full move
            raw_fen += " " + id(fen_position_last)[71];

            id(fen_position_last_string) = raw_fen;

  - id: check_chess_rules
    then:
      - lambda: |-
          // define flag          
          bool valid_check = false;
          id(last_move_pgn_additional) = "";

          // we use validator by https://github.com/rilpires/chess_fen_validator/blob/master/chess_validator.h
          chess_validator::TableState table_state;
          chess_validator::get_table_state( id(fen_position_last_string).c_str() , &table_state );
          chess_validator::INVALID_REASON invalid = chess_validator::is_move_invalid( &table_state , id(current_move_from), id(current_move_to) );
          if( invalid ){
              std::string fen_string = ", FEN = " + id(fen_position_last_string) + ", MOVE: " + id(current_move_uci);              
              switch(invalid){
                  case chess_validator::INVALID_FEN_STRING:
                      ESP_LOGW("Validator", "Invalid move... reason: INVALID_FEN_STRING %s",  fen_string.c_str() );
                      break;
                  case chess_validator::NOT_PLAYER_TURN:
                      ESP_LOGW("Validator", "Invalid move... reason: NOT_PLAYER_TURN %s",  fen_string.c_str() );
                      break;
                  case chess_validator::NO_UNIT:
                      ESP_LOGW("Validator", "Invalid move... reason: NO_UNIT %s",  fen_string.c_str() );
                      break;
                  case chess_validator::SAME_PLACE:
                      ESP_LOGW("Validator", "Invalid move... reason: SAME_PLACE %s",  fen_string.c_str() );
                      break;
                  case chess_validator::CAPTURING_SAME_COLOR:
                      ESP_LOGW("Validator", "Invalid move... reason: CAPTURING_SAME_COLOR %s",  fen_string.c_str() );
                      break;
                  case chess_validator::INVALID_UNIT_MOVE:
                      ESP_LOGW("Validator", "Invalid move... reason: INVALID_UNIT_MOVE %s",  fen_string.c_str() );
                      break;
                  case chess_validator::KING_IN_CHECK:
                      ESP_LOGW("Validator", "Invalid move... reason: KING_IN_CHECK %s",  fen_string.c_str() );
                      break;
              }
          } else {

              // apply current move and check if any checks, mates, draws (we use here UCI due to missing promotion parameter)
              chess_validator::TableState new_table_state = chess_validator::apply_move( &table_state , id(current_move_uci).c_str() );

              // king in check ?
              if (chess_validator::is_king_in_check(&new_table_state, new_table_state.next_color_to_play)) {
                  id(last_move_pgn_additional) = "+";
              }
              // kind in mate?
              if (chess_validator::is_check_mate(&new_table_state))
              {
                  id(last_move_pgn_additional) = "#";
              }
              // draw ?
              chess_validator::DRAW_REASON   draw  = chess_validator::get_draw_reason(&new_table_state);
              if (draw != chess_validator::DRAW_REASON::NO_DRAW) {
                  id(last_move_pgn_additional) = " 1/2-1/2";
              }

              valid_check = true;
          }

          // reset flag if not valid
          id(valid_move) = valid_check;

  - id: move_analyser
    then:
      - lambda: |-
          // reset flag
          id(valid_move) = false;
          id(fen_enpassant_index) = -1;

          // loop over all 64 current and last positions and store differences to global variable
          int s = (id(white_to_move))? 1 : -1;
          for (int value = 0; value < 64; value++) {
            id(raw_position_differences)[value] = (id(raw_position_current)[value] - id(raw_position_last)[value])*s;
          }

          int sum = 0; // holds the sum of all differences
          int sum_abs = 0; // holds the sum of all abs differences
          int counter_changes = 0; // holds the number of changed fields

          for (int value = 0; value < 64; value++) {
            sum += id(raw_position_differences)[value];
            int cur_pos_abs = abs(id(raw_position_differences)[value]);
            sum_abs += cur_pos_abs;
            counter_changes += (int)((cur_pos_abs > 0) ? 1 : 0);
          }

          // MOVE
          if (sum_abs == 2 && sum == 0 && counter_changes == 2 ) {
            id(perform_move).execute();
          }

          // TAKE
          if (sum_abs == 3 && sum == 1 && counter_changes == 2 ) {
            id(perform_take).execute();
          }

          // CASTLING
          if (sum_abs == 4 && sum == 0 && counter_changes == 4 && (id(raw_position_differences)[60] == -1 || id(raw_position_differences)[4] == -1) ) {
            id(perform_castling).execute();
          }

          // EN PASSANT
          if (sum_abs == 3 && sum == 1 && counter_changes == 3 ) {
            id(perform_enpassant).execute();
          }

          // we check here, if the move made and the opponents lichess move are the same
          if (id(lichess_game_running) && !id(lichess_is_my_turn) && id(lichess_opponent_at_board).state == "no") {
            id(valid_move) = (bool)(id(current_move_uci_lichess) == id(current_move_uci));
          }

          // update led's
          id(led_update_check_move).execute();

          // store valid move of the opponent
          if (id(lichess_game_running) && !id(lichess_is_my_turn) && id(valid_move) && id(lichess_opponent_at_board).state == "no") {
            if (id(lichess_my_color) == "white") {
              id(button_black_finished).publish_state(true);
              id(button_black_finished).publish_state(false);
            } else {
              id(button_white_finished).publish_state(true);
              id(button_white_finished).publish_state(false);              
            }
          }

  - id: perform_move
    then:
      - lambda: |-
          int from = 0;
          int to = 0;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];
          id(current_move_from) = from;
          id(current_move_to) = to;
          id(current_move_type) = "MOVE";

          // prepare uci notation
          id(update_uci_notation).execute();
          // check if move is legal
          id(check_chess_rules).execute();

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";

            id(update_chess_board).execute();  

            // run pgn move extractor 
            id(update_pgn).execute(); 
          }

  - id: perform_take
    then:
      - lambda: |-
          int from = 0;
          int to = 0;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 2);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];
          id(current_move_from) = from;
          id(current_move_to) = to;
          id(current_move_type) = "TAKE";

          // prepare uci notation
          id(update_uci_notation).execute();
          // check if move is legal
          id(check_chess_rules).execute();

          // still valid
          if (id(valid_move)) {
          // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";

            id(update_chess_board).execute();   

            // run pgn move extractor 
            id(update_pgn).execute();
          }

  - id: perform_castling
    then:
      - lambda: |-
          int from_k = 0;
          int to_k = 0;
          int from_r = 0;
          int to_r = 0;

          // white
          if (id(raw_position_differences)[60] == -1) {
            from_k = 60;
            if (id(raw_position_differences)[63] == -1) { // short
              from_r = 63;
              to_r = 61;
              to_k = 62;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[56] == -1) { // long
              from_r = 56;
              to_r = 59;
              to_k = 58;
              id(current_move_type) = "CASTLING_LONG";
            }
          }
          // black 
          if (id(raw_position_differences)[4] == -1) {
            from_k = 4;
            if (id(raw_position_differences)[7] == -1) { // short
              from_r = 7;
              to_r = 5;
              to_k = 6;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[0] == -1) { // long
              from_r = 0;
              to_r = 3;
              to_k = 2;
              id(current_move_type) = "CASTLING_LONG";
            }
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from_k];

          // king move only is set as from - to
          id(current_move_from) = from_k;
          id(current_move_to) = to_k;

          // prepare uci notation
          id(update_uci_notation).execute();
          // check if move is legal
          id(check_chess_rules).execute();

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to_k] = id(fen_position_last)[from_k];
            id(fen_position_current)[from_k] = "0";            
            
            id(fen_position_current)[to_r] = id(fen_position_last)[from_r];   
            id(fen_position_current)[from_r] = "0"; 

            id(update_chess_board).execute();

            // run pgn move extractor 
            id(update_pgn).execute(); 
          }
        
  - id: perform_enpassant
    then:
      - lambda: |-
          int from = 0;
          int from_opponent = 0;
          int to = 0;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
              if (id(raw_position_differences)[from - 1] == 1) {
                from_opponent = from - 1;  
              }
              if (id(raw_position_differences)[from + 1] == 1) {
                from_opponent = from + 1;  
              }
              // we deactivate the neighbour idx to find the goal
              id(raw_position_differences)[from_opponent]  = 0;
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          // update global variables
          id(moved_piece) = id(fen_position_last)[from];
          id(current_move_from) = from;
          id(current_move_to) = to;
          id(fen_enpassant_index) = from_opponent;
          id(current_move_type) = "ENPASSANT";

          // prepare uci notation
          id(update_uci_notation).execute();
          // check if move is legal
          id(check_chess_rules).execute();

          // still valid
          if (id(valid_move)) {

            // update fen
            id(fen_position_current)[to] = id(fen_position_last)[from];
            id(fen_position_current)[from] = "0";
            id(fen_position_current)[from_opponent] = "0";

            id(update_chess_board).execute();
            
            // run pgn move extractor
            id(update_pgn).execute(); 
          }     

  - id: update_fen_additional_fields
    then:
      - lambda: |-
          // update who to move
          id(fen_position_current)[64] = (id(white_to_move) ? "b" : "w");

          // update castling part
          if (std::string("KRkr").find(id(moved_piece)) != std::string::npos){
            if (id(white_to_move)) { // white
              // king
              if (id(moved_piece) == "K"){
                id(fen_position_current)[65] = "-";
                id(fen_position_current)[66] = "-";
              } else { // rook
                  // short
                  if (id(current_move_from) == 63) {
                    id(fen_position_current)[65] = "-";
                  } else { // long
                    id(fen_position_current)[66] = "-";
                  }
              }
            } else {
              // king
              if (id(moved_piece) == "k"){
                id(fen_position_current)[67] = "-";
                id(fen_position_current)[68] = "-";
              } else { // rook
                  // short
                  if (id(current_move_from) == 7) {
                    id(fen_position_current)[67] = "-";
                  } else { // long
                    id(fen_position_current)[68] = "-";
                  }
              }
            }
          }

          //en passant field
          if (id(current_move_type) == "ENPASSANT") {
            id(fen_position_current)[69] = id(chess_field_names)[id(fen_enpassant_index)];
          } else {
            id(fen_position_current)[69] = "-";
          }

          // update fen move counters
          if (id(current_move_type) == "TAKE" || id(moved_piece) == "p" || id(moved_piece) == "P") {
            id(halfmove_or_capture_counter) = 0;
          } else {
            id(halfmove_or_capture_counter) += 1;
          }
          id(fen_position_current)[70] = std::to_string(id(halfmove_or_capture_counter));
          id(fen_position_current)[71] = id(white_to_move) ? std::to_string((int)(id(halfmove_counter) / 2.) + 1) : std::to_string((int)(id(halfmove_counter) / 2.) + 2);

  - id: update_pgn
    then:
      - lambda: |-
            // create pgn notation (internal)
            std::string pgn_move = "";
            
            if (id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") {            
              
              // from FEN-position to upper case
              std::string fen_from = id(fen_position_last)[id(current_move_from)];
              std::transform(fen_from.begin(), fen_from.end(), fen_from.begin(), ::toupper);

              // get type of piece has been moved
              bool p_move = (bool)(fen_from == "P");
              bool q_move = (bool)(fen_from == "Q");
              bool q_1_move = (bool)(q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1));
              bool pkb_move = (bool)(p_move || fen_from == "K" || fen_from == "B");
              bool kb_move = (bool)(fen_from == "K" || fen_from == "B");

              // we dont need P in notation
              pgn_move = (p_move) ? "" : fen_from;

              //for pawns, king and bishops we dont need to use "from" field (and queens, as long 1 on the board) 
              if (id(current_move_type) == "MOVE" ) { 
                if (pkb_move || q_1_move) {
                  // pgn without from field
                  pgn_move += id(chess_field_names)[id(current_move_to)];
                } else {
                  // pgn with from field
                  pgn_move += id(chess_field_names)[id(current_move_from)] + id(chess_field_names)[id(current_move_to)];
                }
              }

              // if we take, add "x" to pgn
              if (id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") {
                if (kb_move || (q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1))) {
                  pgn_move += "x" + id(chess_field_names)[id(current_move_to)];
                } else {  
                  pgn_move += id(chess_field_names)[id(current_move_from)] + "x" + id(chess_field_names)[id(current_move_to)];
                }  
              }

              // PAWN PROMOTION
              // for move and take by a pawn we have to check the promotion
              if (p_move ) {                                 
                // white
                if (id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('8') != std::string::npos)) {
                  // add promotion piece
                  pgn_move += "=" + id(default_pawn_promotion_to);  
                  // update fen by promoted piece 
                  id(fen_position_current)[id(current_move_to)] = id(default_pawn_promotion_to); 
                }
                // black
                if (!id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('1') != std::string::npos)) {
                  
                  // add promotion piece 
                  pgn_move += "=" + id(default_pawn_promotion_to);
                  // update fen by promoted piece (for black we have to lower it)
                  std::string promote_to = id(default_pawn_promotion_to);
                  std::transform(promote_to.begin(), promote_to.end(), promote_to.begin(), ::tolower);
                  id(fen_position_current)[id(current_move_to)] = promote_to;
                }
              }
            }

            // CASTLING
            if (id(current_move_type) == "CASTLING_SHORT" ) {
                pgn_move += "O-O";
            } 
            if (id(current_move_type) == "CASTLING_LONG" ) {
                pgn_move += "O-O-O";
            }

            // check, mate, draw
            pgn_move +=  id(last_move_pgn_additional);

            id(last_move_pgn_take_back) = id(last_move_pgn);
            id(last_move_pgn) = pgn_move;
            id(last_move_pgn_sensor).update();  

  - id: compare_raw_position
    then:
      - lambda: |-
          bool changed_position = false;
          for (int i = 0; i < 64; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_last)[i])
            {
              changed_position = true;
              break;
            }
          }
          if (changed_position) {
            id(move_analyser).execute();
          } else {
            // same position, we check if we have to reset the led
            id(led_update_move_over).execute();
          }

  - id: update_raw_position_current
    then:
      - lambda: |-
          // Define a array of size 64 to hold positions
          std::array<int, 64> pos_values;

          // Read all 64 hall sensor values
          for (int value = 0; value < 64; value++) {

            // extract values from arrays
            float curr_field = id(voltage_field_current)[value];

            // Simplified sign and position detection
            int sign = (curr_field > 0) ? 1 : (curr_field < 0) ? -1 : 0;
            int curr_position = (fabsf(curr_field) > id(voltage_field_detection_threshold)[value]) ? 1 : 0;

            // set position -1, 0 or 1
            pos_values[value] = curr_position * sign;
          }

          // Once all 64 values are read, update the global array
          for (int value = 0; value < 64; value++) {
            id(raw_position_current)[value] = pos_values[value];
          }


  - id: update_all_hall_sensors
    then:
      - lambda: |-
          // Define a array of size 64 to hold the ADC values
          std::array<float, 64> adc_values;

          // Read all 16 ADC-Channels and store them in the array
          for (int value = 0; value < 16; value++) {

            if (value & 0b000001) {
              id(output_s1).turn_on();
            } else {
              id(output_s1).turn_off();
            }

            if (value & 0b000010) {
              id(output_s2).turn_on();
            } else {
              id(output_s2).turn_off();
            }

            if (value & 0b000100) {
              id(output_s3).turn_on();
            } else {
              id(output_s3).turn_off();
            }

            if (value & 0b001000) {
              id(output_s4).turn_on();
            } else {
              id(output_s4).turn_off();
            }

            // all outputs are set

            delay($delay_before_adc_reading);  // let the multiplexer select the sensor to be read
            // (update in the same order as switched channels)
            id(current_hall_sensor_1).update(); // update adc value
            id(current_hall_sensor_2).update(); // update adc value
            id(current_hall_sensor_3).update(); // update adc value
            id(current_hall_sensor_4).update(); // update adc value

            int value_4_0 = value*4;
            int value_4_1 = value_4_0 + 1;
            int value_4_2 = value_4_0 + 2;
            int value_4_3 = value_4_0 + 3;

            // read and write values into array
            adc_values[value_4_0] = id(current_hall_sensor_1).state;
            adc_values[value_4_1] = id(current_hall_sensor_2).state;
            adc_values[value_4_2] = id(current_hall_sensor_3).state;
            adc_values[value_4_3] = id(current_hall_sensor_4).state;
          }

          // Once all 64 values are read, update the global array
          for (int i = 0; i < 64; i++) {
            id(voltage_field_current)[i] = adc_values[id(hall_sensor_order)[i]] - id(voltage_field_offset)[i];
          }

          // debug: show voltage
          id(update_array_text).execute();
  - id: beep_short
    then:
      - lambda: |-
          id(beep_switch).turn_on();
          sleep(100);
          id(beep_switch).turn_off();

  - id: beep_long
    then:
      - lambda: |-
          id(beep_switch).turn_on();
          sleep(250);
          id(beep_switch).turn_off();
  - id: check_opponent_at_board_select
    then:
      - lambda: |- 
          if ( id(lichess_opponent_at_board).state == "yes" && (id(lichess_opponent).state == "random" || (id(lichess_opponent).state).compare(0, 3, "AI_") == 0) ) {
            // not possible to play "on board"
            auto call = id(lichess_opponent_at_board).make_call();
            call.set_option("no");
            call.perform();          
          }
  - id: update_lichess_token
    then:
      - lambda: |-
          // update own token
          auto index = id(lichess_account).active_index();
          if (index.value() == 0) {
            id(chessboard_token_current) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_current) = id(chessboard_token_b);
          } else if (index.value() == 2) {
            id(chessboard_token_current) = id(chessboard_token_c);
          } else {
            id(chessboard_token_current) = id(chessboard_token_c);
          }

          // update opponents token
          index = id(lichess_opponent).active_index();
          if (index.value() == 0) {
            id(chessboard_token_opponent) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_opponent) = id(chessboard_token_b);
          } else if (index.value() == 2) {
            id(chessboard_token_opponent) = id(chessboard_token_c);
          } else {
            id(chessboard_token_opponent) = "";
          }

          id(lichess_token).update();

  - id: lichess_create_new_game
    then:
      - lambda: |-
          // not during the gave
          //if (!id(game_running) && id(initial_position_set).state==true) { // currently deactivated
          if (true) {
            // update lichess token, if not selected yet
            id(update_lichess_token).execute();
            // open the event stream
            id(lichess_stream_events).publish_state("ON");
            // Create JSON object
            StaticJsonDocument<250> root;  
            root["type"] = "createGame";   
            root["color"] = id(lichess_seek_color).state;     
            root["time_m"] = float(float(id(time_control_duration)) / 60.);
            root["time_s"] = int(round(float(id(time_control_duration)) / 15.)*15) ; // closes value to a multiple of 15
            root["increment"] = int(id(time_control_increment));            
            if (id(lichess_seek_rated).state == "rated") {
              root["rated"] = true;
            } else {
              root["rated"] = false;
            }
            root["opponentname"] = id(lichess_opponent).state;
            

            // the shortest seek posible is 10+0, so we set this time, if shorter time - control is choosen
            if (id(lichess_opponent).state == "random" && id(time_control_duration) < 600 ){              
              ESP_LOGW("Lichess", "Invalid time control. Set the clock to 10+0.");
              auto call = id(chess_time_control).make_call();
              call.set_option("Rapid (10+0)");
              call.perform();              
              root["time_m"] = 10;
              root["time_s"] = 600;
              root["increment"] = 0;
            }

            // Convert JSON to string
            std::string json_string;
            serializeJson(root, json_string);

            // just for better representation in web-server
            std::string search = ",";
            std::string replace = ", ";            
            size_t pos = 0;
            while ((pos = json_string.find(search, pos)) != std::string::npos) {
                json_string.replace(pos, search.length(), replace);
                pos += replace.length(); 
            }

            delay(1000);  // Wait 1s to stream be open

            // force changed state, to be able to call the same request 
            id(lichess_api_call).publish_state("{}"); 
            id(lichess_api_call).publish_state(json_string);
          }


  - id: lichess_handle_new_event
    then:
      - lambda: |-
          std::string json_str = id(lichess_last_event_in).state;

          StaticJsonDocument<250> root;
          deserializeJson(root, json_str);

          if (root.containsKey("type") && root["type"].as<std::string>() == "gameStart"){

            // rise flag we are in lichess game
            id(lichess_game_running) = true;

            // extract opponents name to be shown on display
            id(lichess_opponent_name) = root["opponent"].as<std::string>();
            std::string me = id(lichess_account).state;

            // we start board stream
            id(lichess_game_id).publish_state(root["gameId"].as<std::string>());
            // we check the white color
            if (root["color"].as<std::string>() == "white"){
              id(white_to_move) = true;
              id(lichess_is_my_turn) = root["isMyTurn"].as<bool>();
              id(lichess_my_color) = "white";
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + id(lichess_opponent_name) + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            }
            // we check the white color
            if (root["color"].as<std::string>() == "black"){
              id(white_to_move) = false;
              id(lichess_is_my_turn) = root["isMyTurn"].as<bool>();
              id(lichess_my_color) = "black";
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + id(lichess_opponent_name) + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).state + "\"}";
            }        
          }

          if (root.containsKey("type") && root["type"].as<std::string>() == "gameFinish"){
            
            // white won ?
            if (root["win"].as<std::string>() == "w"){
              id(last_move_pgn_additional) = " 1-0";
            }

            // black won ?
            if (root["win"].as<std::string>() == "b"){
              id(last_move_pgn_additional) = " 0-1";
            }

            if (root["status"].as<std::string>() == "draw"){
              id(last_move_pgn_additional) = " 1/2-1/2";
            }

            id(inform_game_over).execute();

            id(game_running) = false;
            id(lichess_game_running) = false;
            id(lichess_is_my_turn) = false;
            
            // close the event stream
            id(lichess_stream_events).publish_state("OFF");
            id(lichess_game_id).publish_state("idle");
          }

  - id: lichess_handle_last_move
    then:
      - lambda: |-
          std::string json_str = id(lichess_last_move_in).state;

          StaticJsonDocument<250> root;
          deserializeJson(root, json_str);

          // opponent gone
          if (root["type"].as<std::string>() == "opponentGone" && root["gone"].as<bool>() == true  && root["claimWinInSeconds"].as<int>() == 0 ){
            delay(1000);  // Wait 1s to sync
            // claim victory
            id(lichess_api_call).publish_state("{}"); 
            id(lichess_api_call).publish_state("{\"type\": \"claim-victory\"}");            
          }

          // overwrite clock by lichess time
          if (root["type"].as<std::string>() == "gameState"){
            
            // let the player know about the last move of opponent
            id(current_move_uci_lichess) = root["last"].as<std::string>();

            if (id(halfmove_counter) > 1) {
              // at any gameState reset previous display messages
              id(display_message_white) = "";
              id(display_message_black) = "";
            }

            if( id(lichess_opponent_at_board).state == "no") {
              if (id(white_to_move) && id(lichess_my_color) == "black"){
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + id(lichess_opponent_name) + "\", \"line_1\": \"Move: " + id(current_move_uci_lichess) + "\"}";
                id(beep_short).execute();       
              } 
              
              if (!id(white_to_move) && id(lichess_my_color) == "white"){
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + id(lichess_opponent_name) + "\", \"line_1\": " + id(current_move_uci_lichess) + "\"}";
                id(beep_short).execute();
              }
            } 

            // update chessboard clock by values from lichess
            std::string wclk = root["wclk"].as<std::string>();
            std::string bclk = root["bclk"].as<std::string>();

            // set white clock
            size_t pos = wclk.find('+'); // Find the "+" character
            if (pos != std::string::npos) {
                std::string first_part = wclk.substr(0, pos); // Extract first part
                id(time_control_timer_white) = std::stoi(first_part); 
            }

            // set black clock
            pos = bclk.find('+'); // Find the "+" character
            if (pos != std::string::npos) {
                std::string first_part = bclk.substr(0, pos); // Extract first part
                id(time_control_timer_black) = std::stoi(first_part);
            }    
            
            // Draw offer
            if ( (root["wdraw"].as<int>() == 1 && id(lichess_my_color) == "black") || (root["bdraw"].as<int>() == 1 && id(lichess_my_color) == "white") ) {
              if (id(lichess_my_color) == "black") {
                id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"DRAW?\"}";
              } else {
                id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"DRAW?\"}";
              } 
              id(beep_short).execute();             
            }

            // TakeBack offer
            if ( (root["wback"].as<int>() == 1 && id(lichess_my_color) == "black") || (root["bback"].as<int>() == 1 && id(lichess_my_color) == "white") ) {
              if (id(lichess_my_color) == "black") {
                id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"Takeback?\"}";
              } else {
                id(display_message_white) = "{\"n_lines\": 1, \"line_0\": \"Takeback?\"}";
              }
              id(beep_short).execute();   
            }
          }

          




