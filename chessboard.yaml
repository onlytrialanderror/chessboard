esphome:
  name: chessboard
  friendly_name: chessboard

  includes:
    - chess_validator.h
  

  # Do some initialition work
  on_boot:
    - priority: 400
      then:
      - script.execute: reset_current_game_values 
    - priority: 700
      then:
        - lambda: |-
            id(reset_display_message).execute();
            id(lichess_tournament_id).publish_state("idle");
            id(perform_lichess_api_call).execute("debug", "Chessboard started");

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: ERROR

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True

  ap:
    ssid: "chessboard"
    password: "chessboard"

# HTTP request component
http_request:
  timeout: 10s
  verify_ssl: false 

mqtt:
  id: mqtt_client
  discovery: true
  broker: !secret mqtt_broker
  username: !secret mqtt_user
  password: !secret mqtt_password

captive_portal:

# Enable web server
web_server:
  port: 80
  include_internal: False
  version: 3
  log: false
  ota: false
  local: true
  sorting_groups:
    - id: sorting_group_settings
      name: "Game Settings"
      sorting_weight: 10
    - id: sorting_group_board
      name: "Board"
      sorting_weight: 20
    - id: sorting_group_pgn
      name: "PGN / FEN"
      sorting_weight: 30
    - id: sorting_group_lichess
      name: "Lichess"
      sorting_weight: 40
    - id: sorting_group_system
      name: "System"
      sorting_weight: 70
time:
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Berlin"  


substitutions:
  # shorter delay and high amount of samples works best
  adc_n_sampels: '40' 
  attenuation_value: 12dB
  hall_sensor_intervall_game: 300ms 
  hall_sensor_intervall_idle: 500ms
  delay_before_adc_reading: '2' 
  debug_sensor_hide: true

i2c:
  sda: GPIO21
  scl: GPIO22
  id: i2c0
  scan: false
  frequency: 200kHz 
  # max frequency of pcf8574 is 100kHz, we try higher frequencies for faster display update
  

tca9548a:
  - address: 0x70
    id: i2c_mux_b
    i2c_id: i2c0
    channels:
      - bus_id: i2c_mux_b_display
        channel: 7
      - bus_id: i2c_mux_b_buttons
        channel: 2

  - address: 0x77
    id: i2c_mux_w
    i2c_id: i2c0
    channels:
      - bus_id: i2c_mux_w_display
        channel: 7

pcf8574:
  - id: 'pcf8574_b'
    address: 0x20
    i2c_id: i2c_mux_b_buttons
    pcf8575: false
  - id: 'pcf8574_w'
    address: 0x27
    i2c_id: i2c0
    pcf8575: false

font:
  - file: "gfonts://Roboto"
    id: roboto_10
    size: 10
  - file: "gfonts://Roboto"
    id: roboto_12
    size: 12
  - file: "gfonts://Roboto"
    id: roboto_24
    size: 24
  - file: "gfonts://Roboto"
    id: roboto_30
    size: 30


globals:

  # Array of chessboard field names in algebraic notation (a8-h1)
  - id: chess_field_names
    type: std::array<std::string, 64>
    initial_value: |-
      {
        "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
        "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
        "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
        "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
        "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
        "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
        "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
        "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1"
      }

  # Map from field name (e.g. "e4") to index (0-63)
  - id: chess_field_indexes
    type: std::map<std::string, int>
    initial_value: |-
      {
        {"a8", 0}, {"b8", 1}, {"c8", 2}, {"d8", 3}, {"e8", 4}, {"f8", 5}, {"g8", 6}, {"h8", 7},
        {"a7", 8}, {"b7", 9}, {"c7", 10}, {"d7", 11}, {"e7", 12}, {"f7", 13}, {"g7", 14}, {"h7", 15},
        {"a6", 16}, {"b6", 17}, {"c6", 18}, {"d6", 19}, {"e6", 20}, {"f6", 21}, {"g6", 22}, {"h6", 23},
        {"a5", 24}, {"b5", 25}, {"c5", 26}, {"d5", 27}, {"e5", 28}, {"f5", 29}, {"g5", 30}, {"h5", 31},
        {"a4", 32}, {"b4", 33}, {"c4", 34}, {"d4", 35}, {"e4", 36}, {"f4", 37}, {"g4", 38}, {"h4", 39},
        {"a3", 40}, {"b3", 41}, {"c3", 42}, {"d3", 43}, {"e3", 44}, {"f3", 45}, {"g3", 46}, {"h3", 47},
        {"a2", 48}, {"b2", 49}, {"c2", 50}, {"d2", 51}, {"e2", 52}, {"f2", 53}, {"g2", 54}, {"h2", 55},
        {"a1", 56}, {"b1", 57}, {"c1", 58}, {"d1", 59}, {"e1", 60}, {"f1", 61}, {"g1", 62}, {"h1", 63}
      }

  # Unicode symbols for chess pieces and empty squares (for display)
  - id: chess_symbols
    type: std::map<char, std::string>
    initial_value: |- 
      /*
        Standard spaces (" ") can be too narrow. Instead, use:
        Non-Breaking Space (\u00A0) → " "
        Thin Space (\u2009) → " "
        En Space (\u2002) → " "
        Full-Width Space (\u3000) → "　"
        ♔	U+2654	White Chess King
        ♕	U+2655	White Chess Queen
        ♖	U+2656	White Chess Rook
        ♗	U+2657	White Chess Bishop
        ♘	U+2658	White Chess Knight
        ♙	U+2659	White Chess Pawn
        ♚	U+265A	Black Chess King
        ♛	U+265B	Black Chess Queen
        ♜	U+265C	Black Chess Rook
        ♝	U+265D	Black Chess Bishop
        ♞	U+265E	Black Chess Knight
        ♟	U+265F	Black Chess Pawn
      */
      {
        {'K', "\u2002\u2654\u2002"},
        {'Q', "\u2002\u2655\u2002"},
        {'R', "\u2002\u2656\u2002"},
        {'B', "\u2002\u2657\u2002"},
        {'N', "\u2002\u2658\u2002"},
        {'P', "\u2002\u2659\u2002"},
        {'k', "\u2002\u265A\u2002"},
        {'q', "\u2002\u265B\u2002"},
        {'r', "\u2002\u265C\u2002"},
        {'b', "\u2002\u265D\u2002"},
        {'n', "\u2002\u265E\u2002"},
        {'p', "\u2002\u265F\u2002"},
        {'0', "\u2002\u3000\u2002"},
        {'x', "x"}
      }

  # Order of hall sensors mapped to chessboard squares (hardware mapping)
  - id: hall_sensor_order
    type: std::array<int, 64>
    initial_value: |-
      {
        23,  7, 11, 27, 10, 30, 62, 58,
        19,  3, 15, 31, 26, 46, 14, 42,
        43, 51, 59, 39, 54, 34, 2,  6,
        47, 55, 63, 35, 38, 18, 50, 22,
        41, 25, 9,  49, 8,  28, 60, 44,
        33,  1, 17, 57, 12, 56, 24, 40,
        21, 37, 53, 13, 52, 32,  0, 16,
        29, 61, 45,  5, 48,  4, 36, 20
      }

  # Per-field calibration offset for hall sensor voltage readings
  - id: voltage_field_offset
    type: std::array<float, 64>
    initial_value: |-
      {
        2.39, 2.54, 2.50, 2.46, 2.43, 2.53, 2.42, 2.38,
        2.48, 2.45, 2.50, 2.44, 2.48, 2.44, 2.43, 2.43,
        2.52, 2.47, 2.42, 2.43, 2.45, 2.51, 2.45, 2.47,
        2.46, 2.44, 2.53, 2.55, 2.35, 2.41, 2.39, 2.50, 
        2.40, 2.39, 2.55, 2.46, 2.38, 2.41, 2.43, 2.49,
        2.48, 2.46, 2.40, 2.50, 2.52, 2.42, 2.51, 2.45,
        2.50, 2.44, 2.45, 2.53, 2.54, 2.55, 2.46, 2.47,
        2.42, 2.45, 2.53, 2.51, 2.47, 2.43, 2.53, 2.42
      }

  # Per-field threshold for detecting piece presence (voltage)
  - id: voltage_field_detection_threshold
    type: std::array<float, 64>
    initial_value: |-
      {
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20,
        0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20, 0.20
      }

  # Global drift value for voltage readings (for calibration)
  - id: voltage_field_drift
    type: float
    initial_value: '0.00'

  # Initial FEN position as array (standard chess starting position)
  - id: fen_position_init
    type: std::array<char, 76>
    initial_value: |-
      {
        'r','n','b','q','k','b','n','r',
        'p','p','p','p','p','p','p','p',
        '0','0','0','0','0','0','0','0',
        '0','0','0','0','0','0','0','0',
        '0','0','0','0','0','0','0','0',
        '0','0','0','0','0','0','0','0',
        'P','P','P','P','P','P','P','P',
        'R','N','B','Q','K','B','N','R',
        'w','K','Q','k','q', 
        '-', '-', 
        '0', '0',
        '0', '0', '1'
      }

  # Previous FEN position as array (for move validation)
  - id: fen_position_previous
    type: std::array<char, 76>

  # Previous FEN as string (for display and validation)
  - id: fen_position_previous_string
    type: std::string
    initial_value: '""'

  # Current FEN as string (for display and validation)
  - id: fen_position_current_string
    type: std::string
    initial_value: '""'

  # Current FEN position as array
  - id: fen_position_current
    type: std::array<char, 76>

  # History of FEN positions (for threefold repetition detection)
  - id: fen_position_history
    type: std::vector<std::string>

  # Index for en passant target square in FEN (-1 if not set)
  - id: fen_enpassant_index
    type: int
    initial_value: '-1'

  # Initial raw board position (piece presence, not FEN)
  - id: raw_position_init
    type: std::array<int, 64>
    initial_value: |-
      {
        -1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1
      }

  # Previous raw board position (for move validation)
  - id: raw_position_previous
    type: std::array<int, 64>

  # Last valid raw board position (for move correction)
  - id: raw_position_last_valid
    type: std::array<int, 64>

  # Current raw board position (piece presence)
  - id: raw_position_current
    type: std::array<int, 64>

  # Differences between current and previous raw positions (for move detection)
  - id: raw_position_differences
    type: std::array<int, 64>

  # Current voltage readings from all hall sensors
  - id: voltage_field_current
    type: std::array<float, 64>

  # PGN move history as string (all moves in PGN format)
  - id: pgn_history
    type: std::string
    initial_value: '""'    

  # Full PGN including headers (for export/sharing)
  - id: full_pgn
    type: std::string
    initial_value: '""'

  # Flag: was the last move valid?
  - id: valid_move
    type: bool
    initial_value: 'false'

  # Flag: is it white's turn to move?
  - id: white_to_move
    type: bool
    initial_value: 'true'

  # Flag: is a game currently running?
  - id: game_running
    type: bool
    initial_value: 'false'

  # Flag: should the current move be stored?
  - id: move_to_store_flag
    type: bool
    initial_value: 'false'

  # Flag: did the board position change?
  - id: changed_position
    type: bool
    initial_value: 'false'

  # Flag: did the last valid position change?
  - id: changed_last_valid_position
    type: bool
    initial_value: 'false'

  # Flag: is a Lichess game running?
  - id: lichess_game_running
    type: bool
    initial_value: 'false'

  # Flag: is this board playing as white on Lichess?
  - id: lichess_is_my_color_white
    type: bool
    initial_value: 'true'

  # Name of the Lichess opponent (for display)
  - id: lichess_opponent_name
    type: std::string
    initial_value: '""'

  # JSON data from Lichess API (main account info)
  - id: lichess_main_json
    type: std::string
    initial_value: '""'

  # JSON data from Lichess API (tournament info)
  - id: lichess_tournament_json
    type: std::string
    initial_value: '""'

  # The piece that was moved in the last move (FEN char)
  - id: moved_piece
    type: char
    initial_value: "'0'"  

  # The piece that was on the target square (FEN char)
  - id: target_piece
    type: char
    initial_value: "'0'"  

  # State of the initial position (0 = none, 1 = black, 2 = white, 3 = both set)
  - id: initial_position_state
    type: int
    initial_value: '0'

  # Halfmove counter (for FEN and move validation)
  - id: halfmove_counter
    type: int
    initial_value: '0'

  # Counter for halfmoves or captures (for FEN)
  - id: halfmove_or_capture_counter
    type: int
    initial_value: '0'

  # Last move in PGN notation (e.g. "e4", "Nf3")
  - id: last_move_pgn
    type: std::string
    initial_value: '""'

  # Additional PGN info for last move (e.g. check "+", mate "#")
  - id: last_move_pgn_additional
    type: std::string
    initial_value: '""'

  # Result of the game ("1-0", "0-1", "1/2-1/2", etc.)
  - id: game_result
    type: std::string
    initial_value: '""'

  # Index of the square the current move is from (-1 if not set)
  - id: current_move_from
    type: int
    initial_value: '0'

  # Index of the square the current move is to (-1 if not set)
  - id: current_move_to
    type: int
    initial_value: '0'

  # Type of the current move ("MOVE", "TAKE", "CASTLING_SHORT", etc.)
  - id: current_move_type
    type: std::string
    initial_value: '""'

  # Current move in UCI notation (e.g. "e2e4")
  - id: current_move_uci
    type: std::string
    initial_value: '""'

  # Last move received from Lichess in UCI notation
  - id: current_move_uci_lichess
    type: std::string
    initial_value: '""'

  # Time control duration in seconds (e.g. 900 for 15 minutes)
  - id: time_control_duration
    type: int
    initial_value: '900'

  # Time increment per move in seconds
  - id: time_control_increment
    type: int
    initial_value: '10'

  # Remaining time for black in seconds
  - id: time_control_timer_black
    type: int
    initial_value: '900'

  # Remaining time for white in seconds
  - id: time_control_timer_white
    type: int
    initial_value: '900'

  # Number of white queens on the board (for promotion tracking)
  - id: n_queens_white
    type: int
    initial_value: '1'

  # Number of black queens on the board (for promotion tracking)
  - id: n_queens_black
    type: int
    initial_value: '1'

  # Default piece to promote pawns to ("Q", "R", "B", "N")
  - id: default_pawn_promotion_to
    type: std::string
    initial_value: '"Q"'

  # Secret key for encryption (used for Lichess tokens)
  - id: secret_key
    type: std::string
    initial_value: !secret chessboard_secret_key

  # Encrypted message buffer (for secure token transmission)
  - id: encrypted_message
    type: std::string
    initial_value: '""'

  # Lichess API tokens for different players (A, B, C)
  - id: chessboard_token_a
    type: std::string
    initial_value: !secret chessboard_token_a
  - id: chessboard_token_b
    type: std::string
    initial_value: !secret chessboard_token_b
  - id: chessboard_token_c
    type: std::string
    initial_value: !secret chessboard_token_c

  # Currently active Lichess token (encrypted)
  - id: chessboard_token_current
    type: std::string
    initial_value: ""
  # Opponent's Lichess token (encrypted)
  - id: chessboard_token_opponent
    type: std::string
    initial_value: ""

  # Last move made by white (UCI)
  - id: last_move_white
    type: std::string
    initial_value: '""'

  # Last move made by black (UCI)
  - id: last_move_black
    type: std::string
    initial_value: '""'

  # Display message for white player (JSON string)
  - id: display_message_white
    type: std::string
    initial_value: '""'

  # Display message for black player (JSON string)
  - id: display_message_black
    type: std::string
    initial_value: '""'

  # OLED display page for white (0 = menu, 1 = clock, 2 = message)
  - id: oled_white_acitve_page
    type: int
    initial_value: '2'

  # OLED display page for black (0 = menu, 1 = clock, 2 = message)
  - id: oled_black_acitve_page
    type: int
    initial_value: '2'

  # Sum of differences between current and previous positions (for move detection)
  - id: differences_sum
    type: int
    initial_value: '0'

  # Sum of absolute differences between current and previous positions
  - id: differences_sum_abs
    type: int
    initial_value: '0'

  # Number of changed squares between current and previous positions
  - id: differences_n_changes
    type: int
    initial_value: '0'

  # Number of pieces difference between previous and current positions
  - id: differences_n_pieces
    type: int
    initial_value: '0'

  # Number of black pieces difference
  - id: differences_n_black_pieces
    type: int
    initial_value: '0'

  # Number of white pieces difference
  - id: differences_n_white_pieces
    type: int
    initial_value: '0'

  # Debug mode flag (enables extra logging and sensors)
  - id: debug_mode
    type: bool
    initial_value: 'false'

  # Arrays for storing loop durations and voltage stats for debugging
  - id: loop_durations_hall
    type: uint32_t[11]
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0}'

  - id: loop_durations_calc
    type: uint32_t[11]
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0}'

  - id: loop_min_voltage_occupied
    type: float[11]
    initial_value: '{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}'

  - id: loop_max_voltage_non_occupied
    type: float[11]
    initial_value: '{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}'

  - id: loop_max_deviation_field_idx
    type: int[11]
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0}'

  # Index for median calculation in debug arrays
  - id: median_array_index
    type: int
    initial_value: '0'

  # Counter for invalid moves (for correction logic)
  - id: invalid_move_counter
    type: int
    initial_value: '-1'

  # Is move validator enabled?
  - id: validator_enabled
    type: bool
    initial_value: 'true'

  # Is the Lichess opponent at the board (OTB)?
  - id: lichess_opponent_at_board
    type: bool
    initial_value: 'false'

  - id: lichess_queue
    type: std::deque<std::string>
    restore_value: no
    initial_value: 'std::deque<std::string>()'

  - id: lichess_draining
    type: bool
    restore_value: no
    initial_value: 'false'


# we updating all the time the values of hall sensors
interval:
  - interval: $hall_sensor_intervall_game
    then:
      - if:
          condition:
            lambda: 'return id(game_running);'
          then:
            - script.execute: main_loop
            - lambda: |-
                id(median_array_index) = (id(median_array_index) + 1) % 11;
  - interval: $hall_sensor_intervall_idle
    then:
      - if:
          condition:
            lambda: 'return !id(game_running);'
          then:
            - script.execute: update_all_hall_sensors
            - script.execute: update_raw_position_current
            - script.execute: initial_position_state_update
            - script.execute: led_update_initial_position_state
            - lambda: |-
                id(median_array_index) = (id(median_array_index) + 1) % 11;
  - interval: 1000ms
    then:
      - script.execute: update_timer
      - script.execute: check_opponent_otb_select

display:
  - platform: ssd1306_i2c
    id: oled_white
    model: "SSD1306 128x32"
    flip_y: False
    flip_x: False
    address: 0x3C
    i2c_id: i2c_mux_w_display
    update_interval: 60s
    lambda: |-
      // 0 - menu, 1 - clock, 2 - message
      if (id(oled_white_acitve_page) == 1) { // clock

          std::string time_to_show_w = id(timer_white).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_w.c_str());

          std::string time_to_show_b = id(timer_black).state;
          it.printf(85, 0, id(roboto_12), time_to_show_b.c_str());

          std::string move_to_show = id(last_move_black);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());

      } else if (id(oled_white_acitve_page) == 0) { // menu

          const auto display_width = it.get_width();
          const auto display_height = it.get_height();
          it.menu(0, 0, id(my_menu), display_width, display_height);

        } else {  // message

          std::string json_str = id(display_message_white);
          JsonDocument root;
          deserializeJson(root, json_str);

          if (root["n_lines"].is<int>()) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }
        }

  - platform: ssd1306_i2c
    id: oled_black
    flip_y: False
    flip_x: False
    model: "SSD1306 128x32"
    address: 0x3C
    i2c_id: i2c_mux_b_display
    update_interval: 60s
    lambda: |-
      // 0 - menu, 1 - clock, 2 - message
      if (id(oled_black_acitve_page) == 1) {  // clock

          std::string time_to_show_b = id(timer_black).state + "|";
          it.printf(0, 0, id(roboto_30), time_to_show_b.c_str());

          std::string time_to_show_w = id(timer_white).state;
          it.printf(85, 0, id(roboto_12), time_to_show_w.c_str());

          std::string move_to_show = id(last_move_white);
          it.printf(85, 18, id(roboto_12), move_to_show.c_str());

      } else if (id(oled_black_acitve_page) == 0) { // menu

          const auto display_width = it.get_width();
          const auto display_height = it.get_height();
          it.menu(0, 0, id(my_menu), display_width, display_height);

        } else { // message

          std::string json_str = id(display_message_black);          
          JsonDocument root;
          deserializeJson(root, json_str);

          if (root["n_lines"].is<int>()) {
            if (root["n_lines"].as<int>() == 2) {
              std::string line_0 = root["line_0"].as<std::string>();
              std::string line_1 = root["line_1"].as<std::string>();
              it.printf(0, 0,  id(roboto_12), line_0.c_str());
              it.printf(0, 18, id(roboto_12), line_1.c_str());
            }
            if (root["n_lines"].as<int>() == 1) {
              std::string line_0 = root["line_0"].as<std::string>();
              it.printf(0, 0, id(roboto_24), line_0.c_str());              
            }
          }
        }

# Declare a LCD menu
graphical_display_menu:
  id: my_menu
  # display: oled_test
  font: roboto_10
  active: false
  mode: rotary
  on_redraw:
    then:
      - lambda: |-
          id(redraw_displays).execute();
  items:
    - type: menu
      text: 'LICHESS'
      items:
        - type: command
          text: 'Start new game'
          on_value:
            then:
              - display_menu.hide:  my_menu 
              - lambda: |-
                  id(lichess_create_new_game).execute();
        - type: command
          text: 'Preset: Lichess OTB'
          on_value:
            then:
              - lambda: |-
                  // set main player
                  auto call_1 = id(lichess_account).make_call();
                  call_1.set_option(id(lichess_account).at(1).value());
                  call_1.perform();
                  // set opponent
                  auto call_2 = id(lichess_opponent).make_call();
                  call_2.set_option(id(lichess_opponent).at(0).value());
                  call_2.perform();
                  // set otb
                  auto call_3 = id(lichess_opponent_at_board_select).make_call();
                  call_3.set_option("yes");
                  call_3.perform();            
                  // set if rated
                  auto call_4 = id(lichess_seek_rated).make_call();
                  call_4.set_option("not rated");
                  call_4.perform();
                  // start lichess game
                  id(lichess_create_new_game).execute();

        - type: command
          text: 'Preset: Wait Daily Arena'
          on_value:
            then:
              - lambda: |-
                  // set opponent
                  auto call_1 = id(lichess_opponent).make_call();
                  call_1.set_option("random");
                  call_1.perform();
                  // set otb
                  auto call_2 = id(lichess_opponent_at_board_select).make_call();
                  call_2.set_option("no");
                  call_2.perform();            
                  // set if rated
                  auto call_3 = id(lichess_seek_rated).make_call();
                  call_3.set_option("rated");
                  call_3.perform();
                  // set arena clock
                  auto call_4 = id(lichess_tournament).make_call();
                  call_4.set_option("Daily");
                  call_4.perform();
                  // set arena clock
                  auto call_5 = id(lichess_tournament_speed).make_call();
                  call_5.set_option("Rapid (10+0)");
                  call_5.perform();
                  // join or new
                  auto call_6 = id(lichess_tournament_start).make_call();
                  call_6.set_option("Wait for next");
                  call_6.perform();
                  // start lichess game
                  id(lichess_arena_join_new_tournament).execute();

        - type: command
          text: 'Preset: Join Daily Arena'
          on_value:
            then:
              - lambda: |-
                  // set opponent
                  auto call_1 = id(lichess_opponent).make_call();
                  call_1.set_option("random");
                  call_1.perform();
                  // set otb
                  auto call_2 = id(lichess_opponent_at_board_select).make_call();
                  call_2.set_option("no");
                  call_2.perform();            
                  // set if rated
                  auto call_3 = id(lichess_seek_rated).make_call();
                  call_3.set_option("rated");
                  call_3.perform();
                  // set arena clock
                  auto call_4 = id(lichess_tournament).make_call();
                  call_4.set_option("Daily");
                  call_4.perform();
                  // set arena clock
                  auto call_5 = id(lichess_tournament_speed).make_call();
                  call_5.set_option("Rapid (10+0)");
                  call_5.perform();
                  // join or new
                  auto call_6 = id(lichess_tournament_start).make_call();
                  call_6.set_option("Join now");
                  call_6.perform();
                  // start lichess game
                  id(lichess_arena_join_new_tournament).execute();

        - type: select
          immediate_edit: false
          text: 'User'
          select: lichess_account
        - type: select
          immediate_edit: false
          text: 'Opponent'
          select: lichess_opponent
        - type: select
          immediate_edit: False
          text: 'Rated'
          select: lichess_seek_rated
        - type: select
          immediate_edit: False
          text: 'Opponent at board'
          select: lichess_opponent_at_board_select
        - type: command
          text: 'Resign'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"resign\"}");
                  id(oled_show_page_clock).execute();                  
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Resign Opponent'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"resignOpponent\"}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Draw both (otb)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"draw\", \"parameter\": true}");
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"drawOpponent\", \"parameter\": true}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Draw (yes)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"draw\", \"parameter\": true}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Draw (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"draw\", \"parameter\": false}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Claim victory'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"claim-victory\"}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 

        - type: command
          text: 'Takeback (yes)'
          on_value:
            then:
              - lambda: |-
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"takeback\", \"parameter\": \"yes\"}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Takeback (no)'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"takeback\", \"parameter\": \"no\"}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Abort game'
          on_value:
            then:
              - lambda: |-
                  // force changed state, to be able to call the same request 
                  id(perform_lichess_api_call).execute("api_call", "{\"type\": \"abort\"}");
                  id(oled_show_page_clock).execute();
              - display_menu.hide:  my_menu 
        - type: command
          text: 'Join arena'
          on_value:
            then:
              - display_menu.hide:  my_menu 
              - lambda: |-
                  id(lichess_arena_join_new_tournament).execute();
        - type: command
          text: 'Quit arena'
          on_value: 
            then:
              - lambda: |-
                  id(lichess_arena_quit_tournament).execute();
        - type: select
          immediate_edit: False
          text: 'Tournament'
          select: lichess_tournament
        - type: select
          immediate_edit: False
          text: 'Speed'
          select: lichess_tournament_speed
        - type: select
          immediate_edit: False
          text: 'Start'
          select: lichess_tournament_start
        - type: back
          text: 'Back'
    - type: command
      text: 'PGN SEND'
      on_value:
        then:
          - lambda: |-
              id(send_telegram_message).execute();
    - type: select
      immediate_edit: false
      text: 'TIMER'
      select: chess_time_control
    - type: select
      immediate_edit: false
      text: 'PROMOTION'
      select: pawn_promotion
    - type: select
      immediate_edit: false
      text: 'Move validator'
      select: chess_move_validator
    - type: command
      text: 'Reset game'
      on_value:
        then:
          - lambda: |-
              id(reset_current_game_values).execute();
    - type: command
      text: 'Restart Board'
      on_value:
        then:
          - lambda: |-
              id(device_factory_reset).press();

# Define internal outputs
output:
  # outputs for analog multiplexer
  - platform: gpio
    pin: GPIO14
    id: output_s1
  - platform: gpio
    pin: GPIO25
    id: output_s2
  - platform: gpio
    pin: GPIO26
    id: output_s3
  - platform: gpio
    pin: GPIO27
    id: output_s4
# beep
  - platform: gpio
    id: beep_switch
    pin:
      number: 4
      mode:
        output: true
      inverted: false

switch:

# LED color to move
  - platform: gpio
    id: led_white_to_move
    icon: mdi:led-on
    name: White to move
    pin:
      pcf8574: pcf8574_w
      number: 5
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_to_move
    icon: mdi:led-on
    name: Black to move
    pin:
      pcf8574: pcf8574_b
      number: 2
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_white_nonvalid_move
    icon: mdi:led-on
    name: White (non valid move)
    pin:
      pcf8574: pcf8574_w
      number: 7
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_white_valid_move
    icon: mdi:led-on
    name: White (valid move)
    pin:
      pcf8574: pcf8574_w
      number: 6
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_nonvalid_move
    icon: mdi:led-on
    name: Black (non valid move)
    pin:
      pcf8574: pcf8574_b
      number: 0
      mode:
        output: true
      inverted: true
    internal: true

  - platform: gpio
    id: led_black_valid_move
    icon: mdi:led-on
    name: Black (valid move)
    pin:
      pcf8574: pcf8574_b
      number: 1
      mode:
        output: true
      inverted: true
    internal: true

button:
  - platform: factory_reset
    name: Restart with Factory Default Settings
    id: device_factory_reset
    entity_category: "diagnostic"
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 100
  - platform: template
    name: "PGN to telegram"
    id: pgn_to_telegram
    on_press: 
      then:
        lambda: |-
          id(send_telegram_message).execute();
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: -1
  - platform: template
    name: New Lichess Game
    id: lichess_new_game_button
    on_press:
      then:
        - lambda: |-
            id(lichess_create_new_game).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 0
  - platform: template
    name: Join Arena Tournament
    id: lichess_new_arena_button
    on_press:
      then:
        - lambda: |-
            id(lichess_arena_join_new_tournament).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 8


binary_sensor:
  - platform: gpio
    name: "White finished"
    id: button_white_finished
    pin:
      pcf8574: pcf8574_w
      number: 4
      mode:
        input: true
      inverted: true
    on_press:
      then:
        - lambda: |-
            id(button_white_finished_script).execute();
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_b
      number: 3
      mode:
        input: true
      inverted: true
    name: "Black finished"
    id: button_black_finished
    on_press:
      then:
        - lambda: |-
            id(button_black_finished_script).execute();
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 0
      mode:
        input: true
      inverted: true
    name: "Back"
    id: button_back
    internal: true
    on_press:
      then:
        - display_menu.show_main:   my_menu
        - display_menu.hide:  my_menu 
        - lambda: |-
            if (id(halfmove_counter) > 0) {
              // start the clock during a game
              id(game_running) = true;
              // the game can be also started by the pause button
              id(led_update_color_to_move).execute();
              id(oled_show_page_clock).execute();
            } else {
              id(oled_show_page_message).execute();
            }

  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 1
      mode:
        input: true
      inverted: true
    name: "Up"
    id: button_up
    on_press:
      then:
        - display_menu.up: my_menu
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 2
      mode:
        input: true
      inverted: true
    name: "Down"
    id: button_down
    on_press:
      then:
        - display_menu.down: my_menu
    internal: true
  - platform: gpio
    pin:
      pcf8574: pcf8574_w
      number: 3
      mode:
        input: true
      inverted: true
    name: "Set"
    id: button_set
    on_press:
      then:
        - if:
              condition:
                display_menu.is_active: my_menu
              then:
                - display_menu.enter: my_menu
              else:
                - display_menu.show:  my_menu
                - lambda: |-
                    id(game_running) = false;
                    // read hall sensors
                    id(update_all_hall_sensors).execute();          
                    // transform voltage to position flags (-1, 0, 1)
                    id(update_raw_position_current).execute();
                    // update variables, if black & white init-positions are set
                    id(initial_position_state_update).execute();
                    id(led_update_initial_position_state).execute(); 
                    id(oled_show_page_menu).execute();
    internal: true

select:
  - platform: template
    name: "Time Control"
    id: chess_time_control
    optimistic: true
    options:
      - "Blitz (3+0)"
      - "Blitz (3+2)"
      - "Blitz (5+0)"
      - "Blitz (5+3)"
      - "Rapid (10+0)"
      - "Rapid (10+5)"
      - "Rapid (15+10)"
      - "Classical (20+10)"
      - "Classical (30+0)"
      - "Classical (60+0)"
      - "Classical (90+30)"
    initial_option: "Rapid (15+10)"
    on_value: 
      then:
        - lambda: |-
            // not during the game
            if (id(halfmove_counter) == 0) {
              if (x == "Blitz (3+0)") {
                // Set time control to Blitz (3+0)
                id(time_control_duration) = 180;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (3+2)") {
                // Set time control to Blitz (3+2)
                id(time_control_duration) = 180;
                id(time_control_increment) = 2;
              } else if (x == "Blitz (5+0)") {
                // Set time control to Blitz (5+0)
                id(time_control_duration) = 300;
                id(time_control_increment) = 0;
              } else if (x == "Blitz (5+3)") {
                // Set time control to Blitz (5+3)
                id(time_control_duration) = 300;
                id(time_control_increment) = 3;
              } else if (x == "Rapid (10+0)") {
                // Set time control to Rapid (10+0)
                id(time_control_duration) = 600;
                id(time_control_increment) = 0;
              } else if (x == "Rapid (10+5)") {
                // Set time control to Rapid (10+5)
                id(time_control_duration) = 600;
                id(time_control_increment) = 5;
              } else if (x == "Rapid (15+10)") {
                // Set time control to Rapid (15+10)
                id(time_control_duration) = 900;
                id(time_control_increment) = 10;
              } else if (x == "Classical (20+10)") {
                // Set time control to Classical (20+10)
                id(time_control_duration) = 1200;
                id(time_control_increment) = 10;
              }else if (x == "Classical (30+0)") {
                // Set time control to Classical (30+0)
                id(time_control_duration) = 1800;
                id(time_control_increment) = 0;
              } else if (x == "Classical (60+0)") {
                // Set time control to Classical (60+0)
                id(time_control_duration) = 3600;
                id(time_control_increment) = 0;
              } else if (x == "Classical (90+30)") {
                // Set time control to Classical (90+30)
                id(time_control_duration) = 5400;
                id(time_control_increment) = 30;
              }

              id(time_control_timer_black) = id(time_control_duration);
              id(time_control_timer_white) = id(time_control_duration);

              id(timer_black).update();
              id(timer_white).update();

            } else {
              // select previos selected option
            }

            // overwrite display message, if we are in init state
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"" + x + "\"}";
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"" + x + "\"}";
            // we dont need to activate the message screen here, just overwrite values
            id(redraw_displays).execute();
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 1
  - platform: template
    name: "Promotion to"
    id: pawn_promotion
    optimistic: true
    options:
      - "Queen"
      - "Rook"
      - "Bishop"
      - "Knight"
    initial_option: "Queen"
    on_value: 
      then:
        lambda: |-
          if (x == "Queen") {
            // Set promotion to Queen
            id(default_pawn_promotion_to) = "Q";
          } else if (x == "Rook") {
            // Set promotion to Rook
            id(default_pawn_promotion_to) = "R";
          } else if (x == "Bishop") {
            // Set promotion to Bishop
            id(default_pawn_promotion_to) = "B";
          } else if (x == "Knight") {
            // Set promotion to Knight
            id(default_pawn_promotion_to) = "N";
          }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 2
  - platform: template
    name: "Account"
    id: lichess_account
    internal: False
    optimistic: true
    options:
      - !secret chessboard_player_a
      - !secret chessboard_player_b
      - !secret chessboard_player_c
    initial_option: !secret chessboard_player_b
    on_value: 
      then:
        lambda: |-
          id(update_lichess_token).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 1
  - platform: template
    name: "Opponent"
    id: lichess_opponent
    internal: False
    optimistic: true
    options:
      - !secret chessboard_opponent_a
      - !secret chessboard_opponent_b
      - "random"
      - "AI_1"
      - "AI_2"
      - "AI_3"
      - "AI_4"
      - "AI_5"
      - "AI_6"
      - "AI_7"
      - "AI_8"
      - !secret chessboard_opponent_c
      - !secret chessboard_opponent_d
      - !secret chessboard_opponent_e
      - !secret chessboard_opponent_f
    initial_option: random
    on_value: 
      then:
        lambda: |-
          id(update_lichess_token).execute();
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 3
  - platform: template
    name: "Color"
    id: lichess_seek_color
    internal: False
    optimistic: true
    options:
      - "random"
      - "white"
      - "black"
    initial_option: "random"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 5
  - platform: template
    name: "Rated"
    id: lichess_seek_rated
    internal: False
    optimistic: true
    options:
      - "rated"
      - "not rated"
    initial_option: "rated"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 6
  - platform: template
    name: "Arena type"
    id: lichess_tournament
    internal: False
    optimistic: true
    options:
      - "Hourly"
      - "Daily"
      - "≤1300"
      - "≤1500"
      - "≤1700"
      - "≤2000"
      - "Eastern"
      - "Weekly"
      - "Monthly"
      - "Yearly"
    initial_option: "Hourly"
    on_value: 
      then:
        lambda: |-
          id(lichess_tournament_json_update).execute(x, id(lichess_tournament_speed).current_option(), id(lichess_tournament_start).current_option());
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 9
  - platform: template
    name: "Arena speed"
    id: lichess_tournament_speed
    internal: False
    optimistic: true
    options:
      - "Rapid (10+0)"
      - "Classical (20+10)"
      - "Blitz (5+0)"
    initial_option: "Rapid (10+0)"
    on_value: 
      then:
        lambda: |-           
          // we create json of the tournament
          id(lichess_tournament_json_update).execute(id(lichess_tournament).current_option(), x, id(lichess_tournament_start).current_option());
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 10
  - platform: template
    name: "Arena start"
    id: lichess_tournament_start
    internal: False
    optimistic: true
    options:
      - "Join now"
      - "Wait for next"
    initial_option: "Wait for next"
    on_value: 
      then:
        lambda: |-           
          // we create json of the tournament
          id(lichess_tournament_json_update).execute(id(lichess_tournament).current_option(), id(lichess_tournament_speed).current_option(), x);
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 11
  - platform: template
    name: "Opponent at board"
    id: lichess_opponent_at_board_select
    internal: False
    optimistic: true
    options:
      - "yes"
      - "no"
    on_value: 
      then:
        lambda: |-
          if (x == "yes") {
            id(lichess_opponent_at_board) = true;
          } else {
            id(lichess_opponent_at_board) = false;
          }  
    initial_option: "no"
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 4
  - platform: template
    name: "Move validator"
    id: chess_move_validator
    internal: False
    optimistic: true
    options:
      - "enabled"
      - "disabled"
    initial_option: "enabled"
    on_value: 
      then:
        lambda: |-
          if (x == "disabled") {
            id(validator_enabled) = false;
          } else {
            id(validator_enabled) = true;
          }   
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: -1
  - platform: template
    name: "Debugger"
    id: debugger_selector
    internal: False
    optimistic: true
    options:
      - "enabled"
      - "disabled"
    initial_option: "disabled"
    on_value: 
      then:
        lambda: |-
          if (x == "enabled") {
            id(debug_mode) = true;
          } else {
            id(debug_mode) = false;
          }   
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: -1
sensor:
  - platform: adc
    pin: GPIO34
    name: current_hall_sensor_1
    id: current_hall_sensor_1
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO35
    name: current_hall_sensor_2
    id: current_hall_sensor_2
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO36
    name: current_hall_sensor_3
    id: current_hall_sensor_3
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never
  - platform: adc
    pin: GPIO39
    name: current_hall_sensor_4
    id: current_hall_sensor_4
    internal: true
    attenuation: $attenuation_value
    samples: $adc_n_sampels
    update_interval: never

  - platform: template
    name: "Loop Duration Hall"
    id: median_duration_hall
    unit_of_measurement: "ms"
    update_interval: 3s
    internal: $debug_sensor_hide
    accuracy_decimals: 0
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 8
    lambda: |-
      if (id(debug_mode)){
          // Make a local copy and sort
          uint32_t sorted[11];
          memcpy(sorted, id(loop_durations_hall), sizeof(sorted));
          std::sort(sorted, sorted + 11);
          // Median (middle value of sorted list)
          return sorted[5];
      } else {
        return uint32_t(0);
      }
  - platform: template
    name: "Loop Duration Calc"
    id: median_duration_calc
    unit_of_measurement: "ms"
    update_interval: 3s
    accuracy_decimals: 0
    internal: $debug_sensor_hide
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 9
    lambda: |-
      if (id(debug_mode)){
          // Make a local copy and sort
          uint32_t sorted[11];
          memcpy(sorted, id(loop_durations_calc), sizeof(sorted));
          std::sort(sorted, sorted + 11);
          // Median (middle value of sorted list)
          return sorted[5];
      } else {
        return uint32_t(0);
      }
  - platform: template
    name: "Hall min voltage occupied"
    id: hall_min_voltage_occupied
    unit_of_measurement: "V"
    accuracy_decimals: 2
    update_interval: 3s
    internal: $debug_sensor_hide
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 10
    lambda: |-
      if (id(debug_mode)){
          // Make a local copy and sort
          float sorted[11];
          memcpy(sorted, id(loop_min_voltage_occupied), sizeof(sorted));
          std::sort(sorted, sorted + 11);
          // Median (middle value of sorted list)
          return sorted[5];
      } else {
        return float(0.0);
      }

  - platform: template
    name: "Hall max deviation non occupied"
    id: hall_max_voltage_non_occupied
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 3s
    internal: $debug_sensor_hide
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 11
    lambda: |-
      if (id(debug_mode)){
          // Make a local copy and sort by abs
          float sorted[11];
          memcpy(sorted, id(loop_max_voltage_non_occupied), sizeof(sorted));
          std::sort(std::begin(sorted), std::end(sorted), [](int a, int b) {
            return abs(a) > abs(b);
          });
          return sorted[0]; 
      } else {
        return float(0.0);
      }

  - platform: template
    name: "Voltage Drift"
    id: voltage_drift
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 3s
    internal: $debug_sensor_hide
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 10
    lambda: |-
        return id(voltage_field_drift);



text_sensor:

  - platform: mqtt_subscribe
    name: "Lichess response"
    id: lichess_response
    topic: chessboard/response
    internal: true
    on_value:
      then:
        - lambda: |-
            // push every message into queue
            id(lichess_queue).push_back(std::string(x.c_str()));

            // start draining if not already draining
            if (!id(lichess_draining)) {
              id(lichess_draining) = true;
              id(lichess_drain_queue).execute();
            }

    # used just to define out-sensor for ha to be set as ha-input sensor
  - platform: template
    name: "Hall max deviation field"
    id: hall_max_deviation_field
    update_interval: 3s
    internal: $debug_sensor_hide
    web_server:
      sorting_group_id: sorting_group_system
      sorting_weight: 12
    lambda: |-
          // Find field-name
          // Make a local copy and sort
          int sorted_idx[11];
          memcpy(sorted_idx, id(loop_max_deviation_field_idx), sizeof(sorted_idx));
          std::sort(sorted_idx, sorted_idx + 11);
          // Median (middle value of sorted list)
          int max_deviation_idx = sorted_idx[5];
          std::string max_deviation_field = "-";
          if (max_deviation_idx > -1){
            max_deviation_field = id(chess_field_names)[max_deviation_idx];
          }
          return max_deviation_field;

  - platform: template
    name: "Lichess Game Id"
    id: lichess_game_id
    update_interval: never
    internal: False
    on_value:
      then:
        - lambda: |-
            id(perform_lichess_api_call).execute("game_id", x);
        - delay: 1s
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 7

  - platform: template
    name: "Lichess Arena Id"
    id: lichess_tournament_id
    internal: False
    update_interval: never
    on_value:
      then:
        - lambda: |-
            id(perform_lichess_api_call).execute("lichess_tournament_id", x);
    web_server:
      sorting_group_id: sorting_group_lichess
      sorting_weight: 12

  - platform: template
    name: FEN
    id: fen_position_previous_string_sensor
    internal: False
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 12
    lambda: |-
      return id(fen_position_previous_string);
  
  - platform: template
    name: "Timer (white)"
    id: timer_white
    update_interval: never
    lambda: |-
      if (id(time_control_timer_white) > 0 ) {
        int minutes = id(time_control_timer_white) / 60;
        int seconds = id(time_control_timer_white) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";        
        return e;
      }
    on_value:
      then:
        - lambda: |-
            if (x == "--:--") {
              if (id(game_running)) {
                id(game_running) = false;
                id(beep_long).execute();
              }
              id(game_result) = "0-1";
            }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 3
  - platform: template
    name: "Timer (black)"
    id: timer_black
    update_interval: never
    lambda: |-
      if (id(time_control_timer_black) > 0 ) {
        int minutes = id(time_control_timer_black) / 60;
        int seconds = id(time_control_timer_black) % 60;
        char buffer[6];
        sprintf(buffer, "%02d:%02d", minutes, seconds);
        return {buffer};
      } else {
        std::string e = "--:--";
        return e;
      }
    on_value:
      then:
        - lambda: |-
            if (x == "--:--") {
              if (id(game_running)) {
                id(game_running) = false;
                id(beep_long).execute();
              }
              id(game_result) = "1-0";
            }
    web_server:
      sorting_group_id: sorting_group_settings
      sorting_weight: 4


  - platform: template
    id: last_move_pgn_sensor
    name: "PGN Move"
    lambda: |-
      std::string pgn_move = id(last_move_pgn);
      if (pgn_move.length() > 0 ) {
        int fullmove = (int)(id(halfmove_counter) / 2.) + 1;
        if (id(halfmove_counter) % 2 == 0) {
            pgn_move += " ...";
        } else {
          pgn_move = "... " + pgn_move; 
        }
        pgn_move = std::to_string(fullmove) + ". " + pgn_move;
      }
      return pgn_move;
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 0
  - platform: template
    id: pgn_history_1
    name: "PGN_1"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      return cutted_history.substr(0, 255);
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 1
  - platform: template
    id: pgn_history_2
    name: "PGN_2"
    lambda: |-
      std::string cutted_history = id(pgn_history);      
      if (cutted_history.length() > 255) {
        return cutted_history.substr(255, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 2
  - platform: template
    id: pgn_history_3
    name: "PGN_3"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*2;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 3
  - platform: template
    id: pgn_history_4
    name: "PGN_4"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*3;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 4
  - platform: template
    id: pgn_history_5
    name: "PGN_5"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*4;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 5
  - platform: template
    id: pgn_history_6
    name: "PGN_6"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*5;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 6
  - platform: template
    id: pgn_history_7
    name: "PGN_7"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*6;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 7
  - platform: template
    id: pgn_history_8
    name: "PGN_8"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*7;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 8
  - platform: template
    id: pgn_history_9
    name: "PGN_9"
    lambda: |-
      std::string cutted_history = id(pgn_history);
      int shift = 255*8;
      if (cutted_history.length() > shift) {
        return cutted_history.substr(shift, 255);  // Safe substring
      } else {
        std::string empty_string = "";
        return empty_string;  // Return an empty string if too short
      }
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_pgn
      sorting_weight: 9

  - platform: template
    name: "8"
    id: line_8
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 1

  - platform: template
    name: "7"
    id: line_7
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 2

  - platform: template
    name: "6"
    id: line_6
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 3

  - platform: template
    name: "5"
    id: line_5
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 4

  - platform: template
    name: "4"
    id: line_4
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 5

  - platform: template
    name: "3"
    id: line_3
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 6

  - platform: template
    name: "2"
    id: line_2
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 7

  - platform: template
    name: "1"
    id: line_1
    update_interval: never
    web_server:
      sorting_group_id: sorting_group_board
      sorting_weight: 8

script:
  - id: main_loop    # to avoid long queues, we skip the iteration if not finished till next call
    mode: single 
    then:
      - lambda: |-
          uint32_t tic = millis();
          // read hall sensors
          id(update_all_hall_sensors).execute();   
          // Store in circular buffer
          id(loop_durations_hall)[id(median_array_index)] = millis() - tic;
          tic = millis(); 
          // transform voltage to position flags (-1, 0, 1)
          id(update_raw_position_current).execute();
          // check, if we have new position in comparison to the previous
          id(compare_raw_position).execute();
          // if any changes in position
          if (id(changed_position) || id(move_to_store_flag)) {
            // check, if we have new position in comparison to the last valid
            id(compare_last_valid_position).execute();
            // we check changed positions only
            if (id(changed_last_valid_position)) {
              // calculate differences in position, to be able to calculate the move
              id(calculate_position_differences).execute();
              // transform position - differences to a move (coordinate from - to)
              id(move_validator).execute(); // update from, to, uci, valid_flag, new_fen
              // update led's valid / non valid move
              id(led_update_valid_move).execute();
              // we check, if we should store the move (i.e. button pressed, or lichess-move is applied)
            }
            id(store_move).execute(id(game_result));            
          } else {            
            // reset flags
            id(reset_validator_flags).execute();
            // same position, turn on blue
            id(led_update_color_to_move).execute();
          }
          // reset display messages, if any
          id(clear_display_messages).execute();
          // Store in circular buffer
          id(loop_durations_calc)[id(median_array_index)] = millis() - tic;
                 
  - id: button_black_finished_script
    mode: single
    then: 
      - lambda: |-
          // only during the gave
          if (id(game_running)) {
            // if our turn, we store the move and let opponent play
            if (!id(white_to_move) && id(valid_move)) {                
                id(move_to_store_flag) = true;
            }
          } else if (id(halfmove_counter) == 0) {
            // at the begin of the game black can start the clock by button
            id(game_running) = true;
            // the game can be also started by the pause button
            id(led_update_color_to_move).execute();
            // show timer
            id(oled_show_page_clock).execute();
          } 

  - id: button_white_finished_script
    mode: single
    then: 
      - lambda: |-
            // only during the gave
            if (id(game_running)){
              // if our turn, we store the move and let opponent play
              if (id(white_to_move) && id(valid_move)) {
                id(move_to_store_flag) = true; 
              }
            // we assume here, initial-position-set is updated by the idle iteration loop
            } else if (!id(game_running) && id(white_to_move) && !id(lichess_game_running) && id(halfmove_counter) == 0 && id(initial_position_state) == 3) { 
                // if initial position, white can also start the the clock
                id(game_running) = true;
                // update LEDs
                id(led_update_color_to_move).execute();
                // show timer
                id(oled_show_page_clock).execute();
            }

  - id: take_back
    then:
      - lambda: |-
          // one take back only
          if (id(pgn_history) != "") {

            // if promotion to queen, we have to reduce the number of queens
            if (id(last_move_pgn).find("=Q") != std::string::npos) {
              if (id(white_to_move) && id(n_queens_white) > 1 ) {
                id(n_queens_white) -= 1;
              } else  if (!id(white_to_move) && id(n_queens_black) > 1) {
                  id(n_queens_black) -= 1;
              }
            }

            // toggle who to move
            id(white_to_move) = !id(white_to_move);

            // replace last fen by take back
            std::memcpy(id(fen_position_current).data(), id(fen_position_previous).data(), sizeof(char)*76);

            // replace last position by take back
            std::memcpy(id(raw_position_current).data(), id(raw_position_previous).data(), sizeof(int)*64);


            // counter back
            id(halfmove_counter) -= 1;

            // pgn history
            int previous_length = id(pgn_history).length();

            // update led
            id(led_update_color_to_move).execute();

            // update pgn sensors
            id(pgn_history_1).update();
            // update furhter sensors (take previous length)
            if ( previous_length > 255) {
              id(pgn_history_2).update();  
            }
            if ( previous_length > 510) {
              id(pgn_history_3).update();  
            }
            if ( previous_length > 765) {
              id(pgn_history_4).update();  
            }
            if ( previous_length > 1020) {
              id(pgn_history_5).update();  
            }
            if ( previous_length > 1275) {
              id(pgn_history_6).update();  
            }
            if ( previous_length > 1530) {
              id(pgn_history_7).update();  
            }
            if ( previous_length > 1785) {
              id(pgn_history_8).update();  
            }
            if ( previous_length > 2040) {
              id(pgn_history_9).update();  
            }
                
            // update further sensors
            id(update_chess_board).execute();
            id(last_move_pgn_sensor).update();
            // update fen string
            id(fen_array_to_string).execute();
          }

  - id: update_chess_board
    mode: queued
    then:
      - lambda: |-
            //  init some variables
            const std::string border_line = "---------------------------------------------------------------";
            int line_counter = 0;
            std::string line_representation = "|";

            // iterate over current fen raw position  
            for (int i=0; i<64; i++) {
              // extend current line
              char curr_fen_char = 'x';
              if (id(fen_position_current)[i] != '\0'){
                curr_fen_char = id(fen_position_current)[i];
              }
              line_representation += id(chess_symbols)[curr_fen_char] + "|";

              if ((i + 1) % 8 == 0) { // store line
                
                int line_counter = (int)(i / 8);

                // update line
                if (line_counter == 0)
                {
                  id(line_8).publish_state(line_representation);
                } else if (line_counter == 1)
                {
                  id(line_7).publish_state(line_representation);
                } else if (line_counter == 2)
                {
                  id(line_6).publish_state(line_representation);
                } else if (line_counter == 3)
                {
                  id(line_5).publish_state(line_representation);
                } else if (line_counter == 4)
                {
                  id(line_4).publish_state(line_representation);
                } else if (line_counter == 5)
                {
                  id(line_3).publish_state(line_representation);
                } else if (line_counter == 6)
                {
                  id(line_2).publish_state(line_representation);
                } else if (line_counter == 7)
                {
                  id(line_1).publish_state(line_representation);
                }
             
                line_representation = "|";
              } 
            }

  - id: update_timer
    mode: queued
    then:
      - lambda: |-
          if ( id(game_running) ) // we are in the game or no pause pressed
          {
            if (id(white_to_move)) {
              if (id(time_control_timer_white) > 0 )
              {
                id(time_control_timer_white) -= 1;
                id(timer_white).update();
              }
            } else {
              if (id(time_control_timer_black) > 0 ) {
                id(time_control_timer_black) -= 1;
                id(timer_black).update();
              }
            }
            id(oled_white).update();
            id(oled_black).update();
          }

  - id: send_telegram_message
    then:
      - script.execute: create_full_pgn
      - script.wait: create_full_pgn
      - if:
          condition:
            - lambda: 'return id(halfmove_counter) > 0;'
          then:
            - script.execute: telegram_pgn_chessboard_a
            - script.wait: telegram_pgn_chessboard_a
            - script.execute: telegram_pgn_chessboard_b
            - script.wait: telegram_pgn_chessboard_b
            - script.execute: beep_short

  - id: telegram_pgn_chessboard_a
    then:
      - http_request.post:
          url: !secret telegram_cheesboard_url
          request_headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_a
            text: !lambda |-                
                return id(full_pgn);

  - id: telegram_pgn_chessboard_b
    then:
      - http_request.post:
          url: !secret telegram_cheesboard_url
          request_headers:
            Content-Type: application/json
          json:
            chat_id: !secret telegram_cheesboard_chat_id_b
            text: !lambda |-                
                return id(full_pgn);

  - id: create_full_pgn
    mode: queued
    then:
      - lambda: |-
          auto time = id(sntp_time).now();

          auto format_two_digits = [](int val) -> std::string {
            return (val < 10 ? "0" : "") + std::to_string(val);
          };

          std::string year   = std::to_string(time.year);
          std::string month  = format_two_digits(time.month);
          std::string day    = format_two_digits(time.day_of_month);
          std::string hour   = format_two_digits(time.hour);
          std::string minute = format_two_digits(time.minute);
          std::string second = format_two_digits(time.second);

          std::string header = "[Event \"Chessboard Game\"]\n";
          header += "[Date \"" + year + "." + month + "." + day + "\"]\n";
          header += "[White \"Chessboard-Player A\"]\n";
          header += "[Black \"Chessboard-Player B\"]\n";
          header += "[UTCDate \"" + year + "." + month + "." + day + "\"]\n";
          header += "[UTCTime \"" + hour + ":" + minute + ":" + second + "\"]\n";
          header += "[Variant \"Standard\"]\n";
          header += "[TimeControl \"" + std::to_string(id(time_control_duration)) +
                    "+" + std::to_string(id(time_control_increment)) + "\"]";
          std::string full_message = header + "\n" + id(pgn_history);
          id(full_pgn) = full_message;

  - id: post_game_operation
    then:
      - lambda: |-
          if (id(halfmove_counter) > 0 && !id(lichess_game_running)) {
              id(send_telegram_message).execute();
          }            

  - id: initial_position_state_update
    then:
      - lambda: |-
          int initial_position_previous = id(initial_position_state);
          // 0 - non, 1 - black, 2 - white, 3 - both set
          int initial_position_current = 0b11; // 3      
          // check black
          for (int i = 0; i < 16; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_init)[i])
            {
              initial_position_current = 0b10; // 2
              break;
            }
          }
          // here 2 or 3
          // check white
          for (int i = 48; i < 64; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_init)[i])
            {
              initial_position_current &= 0b01; // 0 or 1
              break;
            }
          }

          id(initial_position_state) = initial_position_current; 

          // do some stuff at changed init - position - state
          if (initial_position_previous != initial_position_current) {
            
            // 0 - non, 1 - black, 2 - white, 3 - both are set

            // both colors are in init position            
            if (initial_position_current == 0b11) { 
              // intial position set, reset game
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Initial position set\", \"line_1\": \"Reseting game ...\"}";
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"Initial position set\", \"line_1\": \"Reseting game ...\"}";
              id(oled_show_page_message).execute(); 
              delay(2000);
              // reset all values
              id(reset_current_game_values).execute();
              id(reset_display_message).execute();
              // if we are in arena, we want to rejoin
              id(lichess_arena_join_by_id).execute();
            }

            // white only: 2
            if (initial_position_current == 0b10) { 
              // intial position set, reset game
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"Initial position set\", \"line_1\": \"Waiting for black ...\"}";
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"Set initial position\"}";
              id(oled_show_page_message).execute();              
            }

            // black only: 1
            if (initial_position_current == 0b01) { 
              // intial position set, reset game
              id(display_message_black) ="{\"n_lines\": 2, \"line_0\": \"Initial position set\", \"line_1\": \"Waiting for white ...\"}"; 
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"Set initial position\"}";
              id(oled_show_page_message).execute();
            }

            // both not in intial position and menu is not active
            if (initial_position_current == 0b00 && !id(my_menu).is_active()) {
              // if menu is not active, inform the init position to be set
              id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"Set initial position\"}";
              id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"Set initial position\"}";
              id(oled_show_page_message).execute();
            }              
          }

  - id: reset_current_game_values 
    then:
      - lambda: |-
          id(led_all_turn_off).execute(); 
          id(reset_fen_position).execute();
          id(reset_raw_position).execute();
          id(reset_pgn_values).execute();
          id(white_to_move) = true;
          id(game_running) = false;
          id(lichess_is_my_color_white) = true;
          id(lichess_game_running) = false;                   
          id(move_to_store_flag) = false;          
          id(halfmove_counter) = 0;
          id(halfmove_or_capture_counter) = 0;
          id(last_move_white) = "";
          id(last_move_black) = "";          
          id(sync_time_control).execute();
          id(time_control_timer_black) = id(time_control_duration);
          id(time_control_timer_white) = id(time_control_duration);  
          id(timer_black).update();
          id(timer_white).update();        
          id(n_queens_white) = 1;
          id(n_queens_black) = 1;   
          id(invalid_move_counter) = -1;   
          id(update_lichess_token).execute();    
          id(lichess_game_id).publish_state(std::string("idle"));
          id(current_move_uci_lichess) = "-";          

  - id: reset_display_message
    then:
      - lambda: |-
          id(display_message_black) = std::string("{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"") + id(chess_time_control).current_option() + std::string("\"}");
          id(display_message_white) = std::string("{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"") + id(chess_time_control).current_option() + std::string("\"}");
          id(oled_show_page_message).execute();

  - id: redraw_displays
    then:
      - component.update: oled_white
      - component.update: oled_black

  - id: update_pgn_history
    mode: queued
    then:
      - lambda: |-
          // add current pgn to history
          if (id(white_to_move)) { // white
            std::string fullmove = std::to_string((int)(id(halfmove_counter) / 2.) + 1);
            id(pgn_history) = id(pgn_history) + fullmove + ". " + id(last_move_pgn);
          } else { // black
            id(pgn_history) = id(pgn_history) + " " + id(last_move_pgn) + "\n";
          }

          // allways update first pgn          
          id(pgn_history_1).update();
          // update furhter sensors (pgn can not be shorten in game)
          int curr_pgn_length = id(pgn_history).length();
          if ( curr_pgn_length > 255) {
            id(pgn_history_2).update();  
          }
          if ( curr_pgn_length > 510) {
            id(pgn_history_3).update();  
          }
          if ( curr_pgn_length > 765) {
            id(pgn_history_4).update();  
          }
          if ( curr_pgn_length > 1020) {
            id(pgn_history_5).update();  
          }
          if ( curr_pgn_length > 1275) {
            id(pgn_history_6).update();  
          }
          if ( curr_pgn_length > 1530) {
            id(pgn_history_7).update();  
          }
          if ( curr_pgn_length > 1785) {
            id(pgn_history_8).update();  
          }
          if ( curr_pgn_length > 2040) {
            id(pgn_history_9).update();  
          }

  - id: reset_pgn_values
    then:
      - lambda: |-
          id(last_move_pgn) = "";
          id(last_move_pgn_additional) = "";
          id(pgn_history) = "";
          id(full_pgn) = "";
          id(pgn_history_1).update();
          id(pgn_history_2).update();
          id(pgn_history_3).update();
          id(pgn_history_4).update();
          id(pgn_history_5).update();
          id(pgn_history_6).update();
          id(pgn_history_7).update();
          id(pgn_history_8).update();
          id(pgn_history_9).update();

          id(last_move_pgn_sensor).update();

  - id: reset_fen_position
    then:
      - lambda: |-
          std::memcpy(id(fen_position_current).data(), id(fen_position_init).data(), sizeof(char)*76);
          std::memcpy(id(fen_position_previous).data(), id(fen_position_init).data(), sizeof(char)*76);
          id(fen_position_previous_string) = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
          id(fen_position_current_string) = "";
          id(update_chess_board).execute();
          id(fen_position_previous_string_sensor).update();

  - id: reset_raw_position
    then:
      - lambda: |-
          std::memcpy(id(raw_position_previous).data(), id(raw_position_init).data(), sizeof(int)*64);
          std::memcpy(id(raw_position_last_valid).data(), id(raw_position_init).data(), sizeof(int)*64);

  - id: inform_game_over
    parameters:
      game_result: string
    then:
      - lambda: |-
          if (id(game_running)) {
            // beep
            id(beep_long).execute();
            // turn all led's off
            id(led_all_turn_off).execute();

            bool white_won = (bool)(game_result == "1-0" || id(timer_black).state == "--:--");
            bool black_won = (bool)(game_result == "0-1" || id(timer_white).state == "--:--");
            bool draw = (bool)(game_result == "1/2-1/2");

            std::string message_white = "{\"n_lines\": 1, \"line_0\": \"Game finished\"}";
            std::string message_black = "{\"n_lines\": 1, \"line_0\": \"Game finished\"}";

            if (white_won) { 
              id(led_white_green).execute(); // green
              id(led_black_red).execute(); // red            
              message_black = "{\"n_lines\": 1, \"line_0\": \"LOST\"}";
              message_white = "{\"n_lines\": 1, \"line_0\": \"WINNER\"}";
              id(pgn_history) += " 1-0";
              if (id(timer_black).state == "--:--") {
                id(pgn_history) += " {Won by time}";
              }
            }

            if (black_won) {
              id(led_black_green).execute(); // green
              id(led_white_red).execute(); // red       
              message_black = "{\"n_lines\": 1, \"line_0\": \"WINNER\"}";
              message_white = "{\"n_lines\": 1, \"line_0\": \"LOST\"}";
              id(pgn_history) += " 0-1";
              if (id(timer_white).state == "--:--") {
                id(pgn_history) += " {Won by time}";
              }
            }

            if (draw) {
              id(led_black_blue).execute(); // blue
              id(led_white_blue).execute(); // blue 
              message_black = "{\"n_lines\": 1, \"line_0\": \"DRAW\"}";
              message_white = "{\"n_lines\": 1, \"line_0\": \"DRAW\"}";
              id(pgn_history) += " 1/2-1/2";
            }

            // on a lichess game, we have to end the game (abort, mate, draw)
            if (!id(lichess_game_running) && !white_won && !black_won && !draw) {
              id(led_black_red).execute(); // red
              id(led_white_red).execute(); // red 
              message_black = "{\"n_lines\": 1, \"line_0\": \"Aborted\"}";
              message_white = "{\"n_lines\": 1, \"line_0\": \"Aborted\"}";
            }

            id(display_message_black) = message_black;
            id(display_message_white) = message_white;
            id(oled_show_page_message).execute();
          }
      - if:
          condition:
            lambda: 'return id(game_running);'
          then:
            - delay: 3s
      - lambda: |-
          if (id(game_running)) {
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Black player\", \"line_1\": \"Set initial position\"}";
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"White player\", \"line_1\": \"Set initial position\"}";
            id(oled_show_page_message).execute();
          }
      - if:
          condition:
            lambda: 'return id(game_running);'
          then:
            - delay: 2s
        

  - id: sync_time_control
    then:
      - lambda: |-
          auto call = id(chess_time_control).make_call();
          if (id(time_control_duration) == 120 && id(time_control_increment) == 1) {
            call.set_option("Bullet (2+1)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 0) {
            call.set_option("Blitz (3+0)");
          } else if (id(time_control_duration) == 180 && id(time_control_increment) == 2) {
            call.set_option("Blitz (3+2)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 0) {
            call.set_option("Blitz (5+0)");
          } else if (id(time_control_duration) == 300 && id(time_control_increment) == 3) {
            call.set_option("Blitz (5+3)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 0) {
            call.set_option("Rapid (10+0)");
          } else if (id(time_control_duration) == 600 && id(time_control_increment) == 5) {
            call.set_option("Rapid (10+5)");
          } else if (id(time_control_duration) == 900 && id(time_control_increment) == 10) {
            call.set_option("Rapid (15+10)");
          } else if (id(time_control_duration) == 1200 && id(time_control_increment) == 10) {
            call.set_option("Classical (20+10)");
          } else if (id(time_control_duration) == 1800 && id(time_control_increment) == 0) {
            call.set_option("Classical (30+0)");
          } else if (id(time_control_duration) == 3600 && id(time_control_increment) == 0) {
            call.set_option("Classical (60+0)");
          } else if (id(time_control_duration) == 5400 && id(time_control_increment) == 30) {
            call.set_option("Classical (90+30)");
          } else {
            call.set_option("Rapid (15+10)");  // Default option
          }
          call.perform();

  - id: store_move
    parameters:
      game_result: string
    mode: queued
    then:
      - lambda: |-
          // flag to store ?
          if (id(move_to_store_flag)) {
            // store move if valid only
            if (id(valid_move) && id(game_running)) {
              // turn off the LED ... we are storing ....
              id(led_all_turn_off).execute();

              // update fen move, castling, enpassant, move counts
              id(update_fen_additional_fields).execute();

              // update fen string current to last
              id(fen_array_to_string).execute();

              // do we have a valid FEN so far ?
              if (id(fen_position_current_string) != "") {

                // overwrite previous data by current data
                std::memcpy(id(raw_position_previous).data(), id(raw_position_last_valid).data(), sizeof(int)*64);                
                id(fen_position_previous_string) = id(fen_position_current_string);

                // check three fold repetition for non lichess-games
                if (!id(lichess_game_running)){
                  // store fen history
                  std::string position_fen = id(fen_position_current_string).substr(0, id(fen_position_current_string).find(' '));
                  id(fen_position_history).push_back(position_fen);

                  int count = 0;
                  for (auto& f : id(fen_position_history)) {
                    if (f == position_fen) {
                      count++;
                    }
                  }
                  if (count >= 3 && game_result == "") {
                    game_result = "1/2-1/2";
                  }
                }

                // replace last fen by current fen
                std::memcpy(id(fen_position_previous).data(), id(fen_position_current).data(), sizeof(char)*76); 

                //update pgn sensors
                id(update_pgn_history).execute();
                // update n queens
                id(update_number_of_queens).execute();
                // update fen sensor
                id(fen_position_previous_string_sensor).update();

                // update last move
                if (id(white_to_move)) {
                  id(last_move_white) = id(current_move_uci);
                } else {
                  id(last_move_black) = id(current_move_uci);
                }

                // make lichess move
                id(lichess_make_move).execute();

                // game finished on board ?
                if (!id(lichess_game_running) && (game_result == "1-0" || game_result == "0-1" || game_result == "1/2-1/2")){
                  // game over
                  id(inform_game_over).execute(game_result);
                  // do some post game operations
                  id(post_game_operation).execute();
                  // stop game
                  id(game_running) = false;
                } else {               
                  // toggle white_to_move
                  id(white_to_move) = !id(white_to_move);               
                  // increase coutner of halfmoves
                  id(halfmove_counter) += 1;
                  // update timer
                  id(time_control_add_increment).execute();              
                  // reset flags
                  id(reset_validator_flags).execute();
                }            
              }
              id(valid_move) = false;
              id(move_to_store_flag) = false;
              // show clock
              id(oled_show_page_clock).execute();
            }
          }

  - id: update_number_of_queens
    then:
      - lambda: |-
          if (id(last_move_pgn).find("=Q") != std::string::npos){
            // encrease number of queens
            if (id(white_to_move)) {
              id(n_queens_white) += 1;
            } else {
              id(n_queens_black) += 1;
            }            
          }
          // decrease number of queens
          if (id(current_move_type) == "TAKE" && id(current_move_to) > -1 ) {
            char fen_name_to = id(fen_position_previous)[id(current_move_to)];
            if (fen_name_to == 'q') {
              id(n_queens_black) -= 1;
            }
            if (fen_name_to == 'Q') {
              id(n_queens_white) -= 1;
            }
          }
  
  - id: time_control_add_increment
    then:
      - lambda: |-
          if (!id(lichess_game_running)) {
            if (id(white_to_move)){
              id(time_control_timer_white) += id(time_control_increment);
            } else {
              id(time_control_timer_black) += id(time_control_increment);
            }
          }

  - id: update_uci_notation
    then:
      - lambda: |-
          if (id(current_move_to) > -1 && id(current_move_from) > -1) {
            // create uci move for lichess
            std::string field_name_from = id(chess_field_names)[id(current_move_from)];
            std::string field_name_to = id(chess_field_names)[id(current_move_to)];
            char fen_name_from = id(fen_position_previous)[id(current_move_from)];
            std::string uci_move = field_name_from + field_name_to;

            // we have to add promotion to UCI
            bool move_or_take = (bool)(id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE");
            bool promotion_move = (bool)(fen_name_from  == 'P' || fen_name_from  == 'p' );
            if (move_or_take && promotion_move) {  

              // white
              if (id(white_to_move) && (field_name_to.find('8') != std::string::npos)) {
                // add promotion piece to uci notation
                uci_move += id(default_pawn_promotion_to);
                std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
              }

              // black
              if (!id(white_to_move) && (field_name_to.find('1') != std::string::npos)) {
                // add promotion piece to uci notation
                uci_move += id(default_pawn_promotion_to);
                std::transform(uci_move.begin(), uci_move.end(), uci_move.begin(), ::tolower);
              }
            }
            
            id(current_move_uci) = uci_move;
          }

  - id: fen_array_to_string
    mode: queued
    then:
      - lambda: |-
            // transform array to fen-string
            std::string raw_fen;
            int emptyCount = 0;            
            for (int row = 0; row < 8; ++row) {
                for (int col = 0; col < 8; ++col) {
                    char piece = id(fen_position_current)[row * 8 + col];
                    if (piece == '0') {
                        ++emptyCount;
                    } else {
                        if (emptyCount > 0) {
                            raw_fen += std::to_string(emptyCount);
                            emptyCount = 0;
                        }
                      raw_fen += piece;
                    }
                }
                if (emptyCount > 0) {
                    raw_fen += std::to_string(emptyCount);
                    emptyCount = 0;
                }
                if (row < 7) raw_fen += "/";
            }

            // color to move
            raw_fen += " ";
            raw_fen += id(fen_position_current)[64];

            // castling rights
            std::string castling_part = "";
            for (int i=65; i<69; i++){
              if (id(fen_position_current)[i] != '-'){
                castling_part += id(fen_position_current)[i];
              }              
            }
            if (castling_part.length() > 0) {
              raw_fen += " " +  castling_part;
            }
            else {
              raw_fen += " -";
            }            

            // en passant (idx 69 and 70)
            raw_fen += " ";
            if (id(fen_position_current)[69] == '-') {
              raw_fen += "-";
            } else {
              // add en-passant field
              raw_fen += id(fen_position_current)[69];
              raw_fen += id(fen_position_current)[70];
            }
            

            // half move since last take (idx 71 and 72)
            raw_fen += " ";
            if (id(fen_position_current)[71] != '0') {
              raw_fen += id(fen_position_current)[71];
            }
            raw_fen += id(fen_position_current)[72];

            // full move (idx 73, 74 and 75)
            raw_fen += " ";
            if (id(fen_position_current)[73] != '0') {
              raw_fen += id(fen_position_current)[73];
            }
            if (id(fen_position_current)[74] != '0') {
              raw_fen += id(fen_position_current)[74];
            }
            raw_fen += id(fen_position_current)[75];

            // let us check the fen
            chess_validator::TableState table_state;
            if (chess_validator::get_table_state( raw_fen.c_str() , &table_state )) {
              // we have valid FEN
              id(fen_position_current_string) = raw_fen;
            } else {
              // reset current fen string
              id(fen_position_current_string) = "";
              if (id(debug_mode)) {
                id(perform_lichess_api_call).execute("debug", std::string("FEN (invalid): " + raw_fen).c_str());
              }
            }
            

  - id: check_chess_rules
    mode: queued
    then:
      - lambda: |-
          // define flag          
          bool valid_check = false;

          if (id(validator_enabled)) {
          
            std::string previous_fen = id(fen_position_previous_string);
            std::string new_uci = id(current_move_uci);

            chess_validator::TableState table_state;
            bool valid_fen = chess_validator::get_table_state( previous_fen.c_str() , &table_state );
            if (valid_fen && (new_uci.length() == 4 || new_uci.length() == 5)) {
              
              chess_validator::INVALID_REASON invalid = chess_validator::is_move_invalid( &table_state , new_uci.c_str() );
              if( invalid ){                  
                  // we have to reset store flag, if since we pressed the button, the position become invalid
                  id(move_to_store_flag) = false;
                  std::string fen_string = ", FEN = " + id(fen_position_previous_string) + ", MOVE: " + new_uci;
                  std::string invalid_reason = "";              
                  switch(invalid){
                      case chess_validator::INVALID_FEN_STRING:
                          ESP_LOGW("Validator", "Invalid move... reason: INVALID_FEN_STRING %s",  fen_string.c_str() );
                          invalid_reason = "INVALID_FEN_STRING";
                          break;
                      case chess_validator::NOT_PLAYER_TURN:
                          ESP_LOGW("Validator", "Invalid move... reason: NOT_PLAYER_TURN %s",  fen_string.c_str() );
                          invalid_reason = "NOT_PLAYER_TURN";
                          break;
                      case chess_validator::NO_UNIT:
                          ESP_LOGW("Validator", "Invalid move... reason: NO_UNIT %s",  fen_string.c_str() );
                          break;
                      case chess_validator::SAME_PLACE:
                          ESP_LOGW("Validator", "Invalid move... reason: SAME_PLACE %s",  fen_string.c_str() );
                          break;
                      case chess_validator::CAPTURING_SAME_COLOR:
                          ESP_LOGW("Validator", "Invalid move... reason: CAPTURING_SAME_COLOR %s",  fen_string.c_str() );
                          invalid_reason = "CAPTURING_SAME_COLOR";
                          break;
                      case chess_validator::INVALID_UNIT_MOVE:
                          ESP_LOGW("Validator", "Invalid move... reason: INVALID_UNIT_MOVE %s",  fen_string.c_str() );
                          invalid_reason = "INVALID_UNIT_MOVE";
                          break;
                      case chess_validator::KING_IN_CHECK:
                          ESP_LOGW("Validator", "Invalid move... reason: KING_IN_CHECK %s",  fen_string.c_str() );
                          invalid_reason = "KING_IN_CHECK";
                          break;
                  }
                  if (invalid_reason != "") {
                    if (id(white_to_move)) {
                      id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + invalid_reason + "\"}";
                      id(oled_white_acitve_page) = 2;
                    } else {
                      id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + invalid_reason + "\"}";
                      id(oled_black_acitve_page) = 2;
                    }
                  }

              } else {

                  // reset flags, if valid move and no check / mate
                  id(game_result) = "";
                  id(last_move_pgn_additional) = "";

                  // apply current move and check if any checks, mates, draws (we use here UCI due to missing promotion parameter)
                  chess_validator::TableState new_table_state = chess_validator::apply_move( &table_state , new_uci.c_str() );

                  // king in check ?
                  if (chess_validator::is_king_in_check(&new_table_state, new_table_state.next_color_to_play)) {
                      id(last_move_pgn_additional) = "+";
                  }
                  // kind in mate?
                  if (chess_validator::is_check_mate(&new_table_state))
                  {
                      id(last_move_pgn_additional) = "#";
                      if (new_table_state.next_color_to_play == chess_validator::SQUARE::COLOR_BLACK ) {
                        id(game_result) = "1-0";
                      } else {
                        id(game_result) = "0-1";
                      }                    
                  }
                  // draw ?
                  chess_validator::DRAW_REASON   draw  = chess_validator::get_draw_reason(&new_table_state);
                  if (draw != chess_validator::DRAW_REASON::NO_DRAW) {
                      id(game_result) = "1/2-1/2";
                  }
                  valid_check = true;
              }
            }
          } else {
            // reset flags, if valid move and no check / mate
            id(game_result) = "";
            id(last_move_pgn_additional) = "";
            valid_check = true;
          }

          // reset flag if not valid
          id(valid_move) = valid_check;

  - id: calculate_position_differences
    then:
      - lambda: |-
          if (!id(move_to_store_flag) || id(changed_last_valid_position)) {
            // loop over all 64 current and last positions and store differences to global variable
            int s = (id(white_to_move))? 1 : -1;
            for (int value = 0; value < 64; value++) {
              id(raw_position_differences)[value] = (id(raw_position_current)[value] - id(raw_position_previous)[value])*s;
            }

            int sum = 0; // holds the sum of all differences
            int sum_abs = 0; // holds the sum of all abs differences
            int n_changes = 0; // holds the number of changed fields
            int n_pieces_previous = 0; // holds number of pieces last
            int n_black_pieces_previous = 0;
            int n_white_pieces_previous = 0;
            int n_pieces_current = 0; // holds number of pieces current
            int n_black_pieces_current = 0;
            int n_white_pieces_current = 0;

            for (int value = 0; value < 64; value++) {
              sum += id(raw_position_differences)[value];
              int cur_pos_abs = abs(id(raw_position_differences)[value]);
              sum_abs += cur_pos_abs;
              n_changes += (int)((cur_pos_abs > 0) ? 1 : 0);
              // calculate n pieces last
              if (id(raw_position_previous)[value] < 0 ) {
                n_pieces_previous += 1;
                n_black_pieces_previous += 1;
              } else if (id(raw_position_previous)[value] > 0 ) {
                n_pieces_previous += 1;
                n_white_pieces_previous += 1;
              }  
              // calculate n pieces current
              if (id(raw_position_current)[value] < 0) {
                n_pieces_current += 1;
                n_black_pieces_current += 1;
              } else if (id(raw_position_current)[value] > 0) {
                n_pieces_current += 1;
                n_white_pieces_current += 1;
              }
            }

            id(differences_n_pieces) = n_pieces_previous - n_pieces_current;
            id(differences_n_white_pieces) = n_white_pieces_previous - n_white_pieces_current;
            id(differences_n_black_pieces) = n_black_pieces_previous - n_black_pieces_current;
            id(differences_sum) = sum;
            id(differences_sum_abs) = sum_abs;
            id(differences_n_changes) = n_changes;
          }
  
  - id: reset_validator_flags
    then:
      - lambda: |-
          // reset flag
          id(current_move_uci) = "";
          id(current_move_from) = -1;
          id(current_move_to) = -1;
          id(fen_enpassant_index) = -1;
          // there is no moved piece
          id(moved_piece) = '0';
          id(target_piece) = '0';
          // reset valid move
          id(valid_move) = false;
          // reset move type
          id(current_move_type) = "";
          // reset add pgn
          id(last_move_pgn_additional) = "";

          // we have to reset FEN, to allow move correction
          std::memcpy(id(fen_position_current).data(), id(fen_position_previous).data(), sizeof(char)*76);

  - id: move_validator
    mode: queued 
    then:
      - lambda: |-
          if (id(game_running) && (!id(move_to_store_flag) || id(changed_last_valid_position))) {

            // reset flags
            id(reset_validator_flags).execute();

            // flag if lichess game and opponent to move
            bool lichess_opponents_move =  id(lichess_game_running) && !id(lichess_opponent_at_board) && (id(white_to_move) && !id(lichess_is_my_color_white) || !id(white_to_move) && id(lichess_is_my_color_white));
            // Update from / to indexes
            if (id(differences_n_pieces) == 0 && id(differences_n_white_pieces) == 0 && id(differences_n_black_pieces) == 0) { // move or castling
              // MOVE
              if (id(differences_sum_abs) == 2 && id(differences_sum) == 0 && id(differences_n_changes) == 2 ) {
                id(validate_move).execute(lichess_opponents_move);
              } else {
                // CASTLING
                if (id(differences_sum_abs) == 4 && id(differences_sum) == 0 && id(differences_n_changes) == 4 ) {
                  id(validate_castling).execute(lichess_opponents_move);
                }
              }
            } else if (id(differences_n_pieces) == 1 && ((id(differences_n_white_pieces) == 1 && id(differences_n_black_pieces) == 0) || (id(differences_n_white_pieces) == 0 && id(differences_n_black_pieces) == 1))) { // take or enpassant
              // TAKE
              if (id(differences_sum_abs) == 3 && id(differences_sum) == 1 && id(differences_n_changes) == 2 ) {
                id(validate_take).execute(lichess_opponents_move);
              } else {
                // EN PASSANT
                if (id(differences_sum_abs) == 3 && id(differences_sum) == 1 && id(differences_n_changes) == 3 ) {
                  id(validate_enpassant).execute(lichess_opponents_move);
                }
              }
            }

            
            if (id(valid_move)) {
              // store last valid position
              std::memcpy(id(raw_position_last_valid).data(), id(raw_position_current).data(), sizeof(int)*64); 
            } else {
              // reset flags, if valid move and no check / mate
              id(game_result) = "";
              id(last_move_pgn_additional) = "";
              id(invalid_move_counter) += 1;
              // we have an invalid move ? so, we have to reset last valid, otherwiese we wont get "valid"-flag after correction of the move
              // example: we make a valid move (that one is stored), then we move an other piece -> invalid, so we move it back (valid position)
              // but, the flag is not updated and still invalid, since we already checked this position
              if (id(invalid_move_counter) == 2) {
                std::memcpy(id(raw_position_last_valid).data(), id(raw_position_init).data(), sizeof(int)*64);
                id(invalid_move_counter) = -1; // we dont want to reset every iteration
              }
              
            }

            // LICHESS MOVE
            if (lichess_opponents_move && id(valid_move)) {
              //delay(100); // do small break
              // press "finished-button" for the opponent
              if (id(lichess_is_my_color_white)) {
                id(button_black_finished_script).execute();
              } else {
                id(button_white_finished_script).execute();             
              }
            }

            // ON SETTING START POSITION?
            if (id(game_running) && (id(differences_n_pieces) < -2 || id(differences_n_changes) > 6 || id(differences_n_pieces) > 4)) { // added three and more pieces to board or moved more than 3 pieces at once
              // inform game is aborted
              id(inform_game_over).execute(id(game_result));
              // we stop the game and send png
              id(post_game_operation).execute();
              // abort the current game
              id(game_running) = false;
            }
          }

  - id: clear_display_messages
    mode: queued 
    then:
      - lambda: |-
          // if we had some messages in a non-lichess game, clear them at valid move 
          if (!id(lichess_game_running) && id(valid_move) && id(game_running)) {
            if (id(white_to_move) && id(oled_white_acitve_page) == 2) {
              id(oled_white_acitve_page) = 1;
            }
            if (!id(white_to_move) && id(oled_black_acitve_page) == 2) {
              id(oled_black_acitve_page) = 1;
            }
          }
 
  - id: validate_move
    parameters:
      lichess_opponents_move: bool
    then:
      - lambda: |-
          int from = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          if (from > -1 && to > -1) {
            // update global variables
            id(moved_piece) = id(fen_position_previous)[from];
            id(target_piece) = id(fen_position_previous)[to];

            if (id(moved_piece) != '0'  && id(target_piece) == '0') {
              // for the case of en passant, we have to exclude taking of "empty square" from "move"
              // furthermore, we have to wait, till the rook also moved at casteling
              // otherwise the move will be checked as valid, although the opponent pawn is still on the board
              bool pawn_move = (id(moved_piece) == 'P' || id(moved_piece) == 'p' );
              bool king_move = (id(moved_piece) == 'K' || id(moved_piece) == 'k' );
              bool take_enpassant = pawn_move  && (std::abs(from - to) == 7 || std::abs(from - to) == 9);
              bool king_castling = king_move && std::abs(from - to) == 2;

              // skip, till the opponent pawn is removed from board and we recognize the "enpassant - move"
              if (!take_enpassant && !king_castling) { 

                id(current_move_from) = from;
                id(current_move_to) = to;
                id(current_move_type) = "MOVE";

                // if pawn move by 2 fields (16 indexes), we have to check en-passant for FEN
                if ( std::abs(from - to) == 16 && pawn_move)
                {
                  std::vector<int> idx_to_check;
                  if (id(white_to_move)) { // white
                    if (from != 48) { // left diagonal (not a2 -> a4)
                      idx_to_check.push_back(to - 1);
                    } 
                    if (from != 55) { // right diagonal (not h2 -> h4)
                      idx_to_check.push_back(to + 1);
                    }
                    for (int i = 0; i < idx_to_check.size(); i++) {
                      // check if black pawns
                      if (id(fen_position_previous)[idx_to_check[i]] == 'p') {
                        id(fen_enpassant_index) = from - 8;
                        break;
                      }
                    }
                  } else { // black
                    if (from != 8) { // left diagonal (not a7 -> a5)
                      idx_to_check.push_back(to - 1);
                    } 
                    if (from != 15) { // right diagonal (not h7 -> h5)
                      idx_to_check.push_back(to + 1);
                    }
                    for (int i = 0; i < idx_to_check.size(); i++) {
                      // check if black pawns
                      if (id(fen_position_previous)[idx_to_check[i]] == 'P') {
                        id(fen_enpassant_index) = from + 8;
                        break;
                      }
                    }
                  }
                }

                // prepare uci notation
                id(update_uci_notation).execute();
                // validate move
                if (!lichess_opponents_move) {
                  // check if move is legal
                  id(check_chess_rules).execute();
                } else {
                  // we dont need to validate lichess moves
                  id(valid_move) = (id(current_move_uci_lichess) == id(current_move_uci));
                }
              }
            }

            // still valid
            if (id(valid_move)) {

              // update fen
              id(fen_position_current)[to] = id(fen_position_previous)[from];
              id(fen_position_current)[from] = '0';

              id(update_chess_board).execute();  

              // run pgn move extractor 
              id(update_pgn).execute(); 
            }
          }

  - id: validate_take
    parameters:
      lichess_opponents_move: bool
    then:
      - lambda: |-
          int from = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 2);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          if (from > -1 && to > -1) {
            // update global variables
            id(moved_piece) = id(fen_position_previous)[from];
            id(target_piece) = id(fen_position_previous)[to];

            if (id(moved_piece) != '0'  && id(target_piece) != '0') {
              id(current_move_from) = from;
              id(current_move_to) = to;
              id(current_move_type) = "TAKE";

              // prepare uci notation
              id(update_uci_notation).execute();
              // validate move
              if (!lichess_opponents_move) {
                // check if move is legal
                id(check_chess_rules).execute();
              } else {
                // we dont need to validate lichess moves
                id(valid_move) = (id(current_move_uci_lichess) == id(current_move_uci));
              }
            } 

            // still valid
            if (id(valid_move)) {
            // update fen
              id(fen_position_current)[to] = id(fen_position_previous)[from];
              id(fen_position_current)[from] = '0';

              id(update_chess_board).execute();   

              // run pgn move extractor 
              id(update_pgn).execute();
            }
          }

  - id: validate_castling
    parameters:
      lichess_opponents_move: bool
    then:
      - lambda: |-
          int from_k = -1;
          int to_k = -1;
          int from_r = -1;
          int to_r = -1;

          // white
          if (id(raw_position_differences)[60] == -1) {
            from_k = 60;
            if (id(raw_position_differences)[63] == -1) { // short
              from_r = 63;
              to_r = 61;
              to_k = 62;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[56] == -1) { // long
              from_r = 56;
              to_r = 59;
              to_k = 58;
              id(current_move_type) = "CASTLING_LONG";
            }
          }
          // black 
          if (id(raw_position_differences)[4] == -1) {
            from_k = 4;
            if (id(raw_position_differences)[7] == -1) { // short
              from_r = 7;
              to_r = 5;
              to_k = 6;
              id(current_move_type) = "CASTLING_SHORT";
            }
            if (id(raw_position_differences)[0] == -1) { // long
              from_r = 0;
              to_r = 3;
              to_k = 2;
              id(current_move_type) = "CASTLING_LONG";
            }
          }

          // update global variables
          if (from_k > -1 && to_k > -1) {

            // store moved piece (we expect king)
            id(moved_piece) = id(fen_position_previous)[from_k];
            id(target_piece) = id(fen_position_previous)[to_k];

            // check, if the moved piece is a king
            if ((id(moved_piece) == 'K' || id(moved_piece) == 'k') && id(target_piece) == '0' ) {
              // king move only is set as from - to
              id(current_move_from) = from_k;
              id(current_move_to) = to_k;

              // prepare uci notation
              id(update_uci_notation).execute();

              // validate move
              if (!lichess_opponents_move) {
                // check if move is legal
                id(check_chess_rules).execute();
              } else {
                // we dont need to validate lichess moves
                id(valid_move) = (id(current_move_uci_lichess) == id(current_move_uci));
              }
            } else {
              // reset moved piece if not the king
              id(moved_piece) = '\0';
            }

            // still valid
            if (id(valid_move)) {

              // update fen
              id(fen_position_current)[to_k] = id(fen_position_previous)[from_k];
              id(fen_position_current)[from_k] = '0';            
              
              id(fen_position_current)[to_r] = id(fen_position_previous)[from_r];   
              id(fen_position_current)[from_r] = '0'; 

              id(update_chess_board).execute();

              // run pgn move extractor 
              id(update_pgn).execute(); 
            }
          }
        
  - id: validate_enpassant
    parameters:
      lichess_opponents_move: bool
    then:
      - lambda: |-
          int from = -1;
          int from_opponent = -1;
          int to = -1;
          // find from index
          auto it_from = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), -1);
          if (it_from != id(raw_position_differences).end()) {
              from = std::distance(id(raw_position_differences).begin(), it_from);              
              if (id(raw_position_differences)[from - 1] == 1) {
                from_opponent = from - 1;  
              }
              if (id(raw_position_differences)[from + 1] == 1) {
                from_opponent = from + 1;  
              }

              if (from_opponent > -1) {
                // we deactivate the neighbour idx to find the goal
                id(raw_position_differences)[from_opponent]  = 0;
              }
          }

          // find to index
          auto it_to = std::find(id(raw_position_differences).begin(), id(raw_position_differences).end(), 1);
          if (it_to != id(raw_position_differences).end()) {
              to = std::distance(id(raw_position_differences).begin(), it_to);
          }

          char from_opponent_piece = '0';

          if (from > -1 && to > -1 && from_opponent > -1) {
            // update global variables
            id(moved_piece) = id(fen_position_previous)[from];
            id(target_piece) = id(fen_position_previous)[to];
            from_opponent_piece = toupper(id(fen_position_previous)[from_opponent]);
          }

          if ( (id(moved_piece) == 'P' || id(moved_piece) == 'p' ) && id(target_piece) == '0'  && from_opponent_piece == 'P' ) {

            id(current_move_from) = from;
            id(current_move_to) = to;          
            id(current_move_type) = "ENPASSANT";

            // prepare uci notation
            id(update_uci_notation).execute();

            // validate move
            if (!lichess_opponents_move) {
              // check if move is legal
              id(check_chess_rules).execute();
            } else {
              // we dont need to validate lichess moves
              id(valid_move) = (id(current_move_uci_lichess) == id(current_move_uci));
            }

            // still valid
            if (id(valid_move)) {

              // update fen
              id(fen_position_current)[to] = id(fen_position_previous)[from];
              id(fen_position_current)[from] = '0';
              id(fen_position_current)[from_opponent] = '0';

              id(update_chess_board).execute();
              
              // run pgn move extractor
              id(update_pgn).execute(); 
            }
          }     

  - id: update_fen_additional_fields
    mode: queued
    then:
      - lambda: |-
          // update who to move
          id(fen_position_current)[64] = (id(white_to_move) ? 'b' : 'w');

          // update castling part (white)
          if ((id(moved_piece) == 'K' || id(moved_piece) == 'R') && (id(fen_position_current)[65] == 'K' || id(fen_position_current)[66] == 'Q') ) { // white
            // king
            if (id(moved_piece) == 'K'){
              id(fen_position_current)[65] = '-';
              id(fen_position_current)[66] = '-';
            } else { // rook
                // K-rook
                if (id(current_move_from) == 63) {
                  id(fen_position_current)[65] = '-';
                }
                // Q-rook 
                if (id(current_move_from) == 56) {
                  id(fen_position_current)[66] = '-';
                } 
            }
          }
          // update castling part (black) 
          if ((id(moved_piece) == 'k' || id(moved_piece) == 'r') && (id(fen_position_current)[67] == 'k' || id(fen_position_current)[68] == 'q')) {
            // king
            if (id(moved_piece) == 'k'){
              id(fen_position_current)[67] = '-';
              id(fen_position_current)[68] = '-';
            } else { // rook
                // k-rook
                if (id(current_move_from) == 7) {
                  id(fen_position_current)[67] = '-';
                } 
                // q-rook
                if (id(current_move_from) == 0) {
                  id(fen_position_current)[68] = '-';
                }                   
            }
          }

          //en passant field
          if (id(fen_enpassant_index) > 0 && id(fen_enpassant_index) < 63) {
            id(fen_position_current)[69] = id(chess_field_names)[id(fen_enpassant_index)].at(0);
            id(fen_position_current)[70] = id(chess_field_names)[id(fen_enpassant_index)].at(1);
          } else {
            id(fen_position_current)[69] = '-';
            id(fen_position_current)[70] = '-';
          }

          // update fen capture counters (idx 71 and 72)
          if (id(current_move_type) == "TAKE" || id(moved_piece) == 'p' || id(moved_piece) == 'P') {
            id(halfmove_or_capture_counter) = 0;                        
          } else {
            id(halfmove_or_capture_counter) += 1;
          }
          std::string count_capture = std::to_string(id(halfmove_or_capture_counter)); 
          if (count_capture.length() == 2) {
            id(fen_position_current)[71] = count_capture.at(0);
            id(fen_position_current)[72] = count_capture.at(1);
          } else {
            id(fen_position_current)[71] = '0';
            id(fen_position_current)[72] = count_capture.at(0);
          }
              
          // update fen move counter (idx 73,74 and 75)
          std::string count_move = id(white_to_move) ? std::to_string((int)(id(halfmove_counter) / 2.) + 1) : std::to_string((int)(id(halfmove_counter) / 2.) + 2);
          if (count_move.length() == 3) {
            id(fen_position_current)[73] = count_move.at(0);
            id(fen_position_current)[74] = count_move.at(1);
            id(fen_position_current)[75] = count_move.at(2);
          } else if (count_move.length() == 2) {
            id(fen_position_current)[73] = '0';
            id(fen_position_current)[74] = count_move.at(0);
            id(fen_position_current)[75] = count_move.at(1);
          } else {
            id(fen_position_current)[73] = '0';
            id(fen_position_current)[74] = '0';
            id(fen_position_current)[75] = count_move.at(0);
          }
  

  - id: update_pgn
    mode: queued
    then:
      - lambda: |-
            // create pgn notation (internal)
            std::string pgn_move = "";
            
            if ((id(current_move_type) == "MOVE" ||  id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") && id(current_move_to) > -1 && id(current_move_from) > -1) {            
              
              // from FEN-position to upper case
              char fen_from = (char)toupper(id(fen_position_previous)[id(current_move_from)]);

              // get type of piece has been moved
              bool p_move = (bool)(fen_from == 'P');
              bool q_move = (bool)(fen_from == 'Q');
              bool q_1_move = (bool)(q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1));
              bool pkb_move = (bool)(p_move || fen_from == 'K' || fen_from == 'B');
              bool kb_move = (bool)(fen_from == 'K' || fen_from == 'B');

              // we dont need P in notation
              if (!p_move) {
                pgn_move += fen_from;
              }

              //for pawns, king and bishops we dont need to use "from" field (and queens, as long 1 on the board) 
              if (id(current_move_type) == "MOVE" ) { 
                if (pkb_move || q_1_move) {
                  // pgn without from field
                  pgn_move += id(chess_field_names)[id(current_move_to)];
                } else {
                  // pgn with from field
                  pgn_move += id(chess_field_names)[id(current_move_from)] + id(chess_field_names)[id(current_move_to)];
                }
              }

              // if we take, add "x" to pgn
              if (id(current_move_type) == "TAKE" ||  id(current_move_type) == "ENPASSANT") {
                if (kb_move || (q_move && (id(n_queens_white) == 1 || id(n_queens_black) == 1))) {
                  pgn_move += "x" + id(chess_field_names)[id(current_move_to)];
                } else {  
                  pgn_move += id(chess_field_names)[id(current_move_from)] + "x" + id(chess_field_names)[id(current_move_to)];
                }  
              }

              // PAWN PROMOTION
              // for move and take by a pawn we have to check the promotion
              if (p_move ) {                                 
                // white
                if (id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('8') != std::string::npos)) {
                  // add promotion piece
                  pgn_move += "=" + id(default_pawn_promotion_to);  
                  // update fen by promoted piece 
                  id(fen_position_current)[id(current_move_to)] = id(default_pawn_promotion_to).at(0); 
                }
                // black
                if (!id(white_to_move) && (id(chess_field_names)[id(current_move_to)].find('1') != std::string::npos)) {
                  
                  // add promotion piece 
                  pgn_move += "=" + id(default_pawn_promotion_to);
                  // update fen by promoted piece (for black we have to lower it)
                  id(fen_position_current)[id(current_move_to)] = (char)tolower(id(default_pawn_promotion_to).at(0));
                }
              }
            }

            // CASTLING
            if (id(current_move_type) == "CASTLING_SHORT" ) {
                pgn_move += "O-O";
            } 
            if (id(current_move_type) == "CASTLING_LONG" ) {
                pgn_move += "O-O-O";
            }

            // check, mate, draw
            pgn_move +=  id(last_move_pgn_additional);

            id(last_move_pgn) = pgn_move;
            id(last_move_pgn_sensor).update();  

  - id: compare_raw_position
    then:
      - lambda: |-
          if (!id(move_to_store_flag)) {
            id(changed_position) = false;
            for (int i = 0; i < 64; i++) {
              if (id(raw_position_current)[i]  != id(raw_position_previous)[i])
              {
                id(changed_position) = true;
                break;
              }
            }
          }

  - id: compare_last_valid_position
    then:
      - lambda: |-
          id(changed_last_valid_position) = false;
          for (int i = 0; i < 64; i++) {
            if (id(raw_position_current)[i]  != id(raw_position_last_valid)[i])
            {
              id(changed_last_valid_position) = true;
              break;
            }
          }

  - id: update_raw_position_current
    mode: queued
    then:
      - lambda: |-
          if (!id(move_to_store_flag)) {
            // We want to calculate mean voltage drift from the values without pieces
            const float n_empty_fields_init = 0.0;
            float n_empty_fields = n_empty_fields_init;
            float sum_voltage_drift = 0.0;

            float max_voltage_non_occupied = 0.0;
            float min_voltage_occupied = 3.0;
            int max_deviation_field_idx = -1;

            // Read all 64 hall sensor values
            for (int value = 0; value < 64; value++) {

              // extract values from arrays
              float curr_field = id(voltage_field_current)[value];

              // Simplified sign and position detection
              int sign = (curr_field > 0) ? 1 : (curr_field < 0) ? -1 : 0;
              int field_occupied =  (fabsf(curr_field) > id(voltage_field_detection_threshold)[value]) ? 1 : 0;

              if (field_occupied == 0) {
                // we have to substract the drift, to get uncorrected value
                sum_voltage_drift += curr_field + id(voltage_field_drift);
                n_empty_fields += 1.00;
                if (id(debug_mode) && (fabsf(curr_field) > fabsf(max_voltage_non_occupied))) {
                   max_voltage_non_occupied = curr_field;
                   max_deviation_field_idx = value;
                }
              } else {
                  if (id(debug_mode) && (fabsf(curr_field) < min_voltage_occupied)) {
                    min_voltage_occupied = fabsf(curr_field);
                  }
              }
              // set position -1, 0 or 1
              id(raw_position_current)[value] = field_occupied * sign;
            }

            if (id(debug_mode)){ 
              id(loop_min_voltage_occupied)[id(median_array_index)] = min_voltage_occupied;
              id(loop_max_voltage_non_occupied)[id(median_array_index)] = max_voltage_non_occupied;
              id(loop_max_deviation_field_idx)[id(median_array_index)] = max_deviation_field_idx;
            }

            // calc mean deviation
            if ((n_empty_fields > n_empty_fields_init)) {
              id(voltage_field_drift) = sum_voltage_drift / n_empty_fields;
            }
          }

  - id: update_all_hall_sensors
    mode: queued
    then:
      - lambda: |-
          if (!id(move_to_store_flag)) {
            // Define a array of size 64 to hold the ADC values
            std::array<float, 64> adc_values;

            // Read all 16 ADC-Channels and store them in the array
            for (int value = 0; value < 16; value++) {

              if (value & 0b0001) {
                id(output_s1).turn_on();
              } else {
                id(output_s1).turn_off();
              }

              if (value & 0b0010) {
                id(output_s2).turn_on();
              } else {
                id(output_s2).turn_off();
              }

              if (value & 0b0100) {
                id(output_s3).turn_on();
              } else {
                id(output_s3).turn_off();
              }

              if (value & 0b1000) {
                id(output_s4).turn_on();
              } else {
                id(output_s4).turn_off();
              }

              // all outputs are set

              // if, during the reading of sensors, the flag for storing is set, we abbort the loop
              // so, we dont need to wait in worst case ~200ms 
              if(id(move_to_store_flag)) {
                break;
              }

              // let the multiplexer select the sensor to be read
              delay($delay_before_adc_reading);  

              // let the ADC reads the sampels
              id(current_hall_sensor_1).update(); // update adc value
              id(current_hall_sensor_2).update(); // update adc value
              id(current_hall_sensor_3).update(); // update adc value
              id(current_hall_sensor_4).update(); // update adc value

              // read and write values into array
              adc_values[value*4    ] = id(current_hall_sensor_1).state;
              adc_values[value*4 + 1] = id(current_hall_sensor_2).state;
              adc_values[value*4 + 2] = id(current_hall_sensor_3).state;
              adc_values[value*4 + 3] = id(current_hall_sensor_4).state;
            }

            if (!id(move_to_store_flag)) {
              // Once all 64 values are read, update the global array
              for (int i = 0; i < 64; i++) {
                id(voltage_field_current)[i] = adc_values[id(hall_sensor_order)[i]] - id(voltage_field_offset)[i] - id(voltage_field_drift);
              }
            }
          }

  - id: beep_short
    then:
      - lambda: |-
          id(beep_switch).turn_on();
      - delay: 50ms
      - lambda: |-
          id(beep_switch).turn_off();

  - id: beep_long
    then:
      - lambda: |-
          id(beep_switch).turn_on();
      - delay: 200ms
      - lambda: |-
          id(beep_switch).turn_off();

  - id: encrypt_message
    parameters:
      input_string: string
    then:
      - lambda: |-
          std::string key = id(secret_key);
          std::string encrypted = "";
          // Convert to hex for safe transmission
          std::string hex = input_string;

          if (input_string != "" && input_string != "idle") {
            hex = "";
            for (size_t i = 0; i < input_string.size(); i++) {
              encrypted += (char)(input_string[i] ^ key[i % key.size()]);
            }

            
            const char* hex_chars = "0123456789ABCDEF";
            for (char c : encrypted) {
              hex += hex_chars[(c >> 4) & 0xF];
              hex += hex_chars[c & 0xF];
            }
          }

          id(encrypted_message) = hex;

  - id: perform_lichess_api_call
    parameters:
      api_endpoint: string 
      json_input: string
    then:
      - lambda: |-
          std::string topic = "chessboard/" + api_endpoint;
          std::transform(topic.begin(), topic.end(), topic.begin(), ::tolower);

          if (id(mqtt_client)->is_connected()) {
            id(mqtt_client).publish(topic, json_input);
          }

  - id: check_opponent_otb_select
    then:
      - lambda: |- 
          bool otb_player = (id(lichess_opponent).current_option() == id(lichess_opponent).at(0) || id(lichess_opponent).current_option() == id(lichess_opponent).at(1) || id(lichess_opponent).current_option() == id(lichess_opponent).at(11));
          if ( id(lichess_opponent_at_board) && !otb_player ) {
            // not possible to play "on board"
            auto call = id(lichess_opponent_at_board_select).make_call();
            call.set_option("no");
            call.perform();          
          }

  - id: lichess_arena_withdraw_by_id
    then:
      - lambda: |-
          // if we are currently in a tournament, we have to withdraw
          if (id(lichess_tournament_id).state.length() == 8){              
            std::string withdraw_json = "{\"type\": \"withdrawTournament\", \"id\": \"" + id(lichess_tournament_id).state + "\"}";
            id(perform_lichess_api_call).execute("api_call", withdraw_json);
          } 

  - id: lichess_arena_join_by_id
    then:
      - lambda: |-
          // if we are currently in a tournament, we have to withdraw
          if (id(lichess_tournament_id).state.length() == 8){              
            std::string join_json = "{\"type\": \"joinTournamentById\", \"id\": \"" + id(lichess_tournament_id).state + "\"}";
            id(perform_lichess_api_call).execute("api_call", join_json);
          } 

  - id: lichess_arena_quit_tournament
    then: 
      - lambda: |-
          id(lichess_arena_withdraw_by_id).execute();
          id(lichess_tournament_id).publish_state("idle");
          id(lichess_tournament_json) = "";


  - id: lichess_arena_join_new_tournament
    then:
      - lambda: |-
          // sync timer with tournament timer
          auto call = id(chess_time_control).make_call();
          call.set_option(id(lichess_tournament_speed).current_option());
          call.perform();
         
          // withdraw current tournament
          id(lichess_arena_withdraw_by_id).execute();
          // update current tournament json
          id(lichess_tournament_json_update).execute(id(lichess_tournament).current_option(), id(lichess_tournament_speed).current_option(), id(lichess_tournament_start).current_option());
          // reset current tournament_id
          id(lichess_tournament_id).publish_state("idle");
          // join tournament
          if (id(lichess_tournament_json) != "") {
            // deserialize for messaging
            JsonDocument root;
            deserializeJson(root, id(lichess_tournament_json));
            // update display message
            id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"joining arena ...\", \"line_1\": \"" + root["tournamentName"].as<std::string>() + "\"}";
            id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"joining arena ...\", \"line_1\": \"" + root["tournamentName"].as<std::string>() + "\"}"; 
            id(oled_show_page_message).execute();
            // try to join the tournament
            id(perform_lichess_api_call).execute("api_call", id(lichess_tournament_json));           
          }

  - id: lichess_tournament_json_update
    parameters:
      freq: string
      speed: string
      start: string
    then:
      - lambda: |-
          std::string tournament_json = "";
          std::string tournament_name = "";          
          std::string tournament_start = "";

          int limit = 0;
          int increment = 0;

          // convert type
          tournament_name += freq + " ";

          // set speed
          size_t pos = speed.find(' '); // Find the "(" character
          if (pos != std::string::npos) {
              std::string first_part = speed.substr(0, pos); // Extract first part
              tournament_name += first_part + " Arena";

              size_t open_paren = speed.find('(');
              size_t plus_sign = speed.find('+');
              size_t close_paren = speed.find(')');

              if (open_paren != std::string::npos && plus_sign != std::string::npos && close_paren != std::string::npos) {
                std::string duration_str = speed.substr(open_paren + 1, plus_sign - open_paren - 1);
                std::string increment_str = speed.substr(plus_sign + 1, close_paren - plus_sign - 1);

                limit = std::stoi(duration_str)*60;
                increment = std::stoi(increment_str);
              }
          }

          // convert start
          if (start == "Wait for next") {
            tournament_start = "created";
          } else if (start == "Join now") {
            tournament_start = "started";
          }

          // Create JSON object
          JsonDocument root;  
          root["type"] = "joinTournamentByName";   
          root["tournamentName"] = tournament_name;     
          root["tournamentStatus"] = tournament_start;
          root["limit"] = limit;
          root["increment"] = increment;            

          // Convert JSON to string
          serializeJson(root, tournament_json);

          // overwrite current tournament json
          id(lichess_tournament_json) = tournament_json;

  - id: lichess_make_move
    then:
      - lambda: |- 
          if (id(current_move_uci) != "") {                                 
            // do lichess calls and updates 
            if (id(lichess_game_running) ) {
              // let lichess know about my move              
              if( (id(white_to_move) && id(lichess_is_my_color_white)) || (!id(white_to_move) && !id(lichess_is_my_color_white))) {  
                std::string move_body = "{\"type\": \"makeMove\", \"move\": \"" + id(current_move_uci) + "\"}"; 
                // send the move to lichess           
                id(perform_lichess_api_call).execute("api_call", move_body);              
              } else if( id(lichess_opponent_at_board)) {
                // switch to oppoents token
                std::string move_body_opponent = "{\"type\": \"makeMoveOpponent\", \"move\": \"" + id(current_move_uci) + "\"}";
                // make a move for the opponent
                id(perform_lichess_api_call).execute("api_call", move_body_opponent); 
              }                
            }
          }  

  - id: update_lichess_token
    then:
      - lambda: |-
          // update own token
          auto index = id(lichess_account).active_index();
          std::string previous_token_main = id(chessboard_token_current);
          std::string previous_token_opponent = id(chessboard_token_opponent);

          if (index.value() == 0) {
            id(chessboard_token_current) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_current) = id(chessboard_token_b);
          } else if (index.value() == 2) {
            id(chessboard_token_current) = id(chessboard_token_c);
          } else {
            id(chessboard_token_current) = id(chessboard_token_c);
          }

          // encrypt token
          id(encrypt_message).execute(id(chessboard_token_current));
          id(chessboard_token_current) = id(encrypted_message);

          // update opponents token
          index = id(lichess_opponent).active_index();
          if (index.value() == 0) {
            id(chessboard_token_opponent) = id(chessboard_token_a);
          } else if (index.value() == 1) {
            id(chessboard_token_opponent) = id(chessboard_token_b);
          } else if (index.value() == 11) {
            id(chessboard_token_opponent) = id(chessboard_token_c);
          } else {
            id(chessboard_token_opponent) = "idle";
          }

          // if token has changed, we have to reset the game stream
          if (previous_token_main != id(chessboard_token_current)) {
            id(lichess_game_id).publish_state("idle");
          }

          // encrypt token
          id(encrypt_message).execute(id(chessboard_token_opponent));
          id(chessboard_token_opponent) = id(encrypted_message);

          if (id(mqtt_client)->is_connected()) {
            // update opponents token if changed
            if (previous_token_opponent != id(chessboard_token_opponent)) {
              id(perform_lichess_api_call).execute("token_opponent", id(chessboard_token_opponent));
            }
            // update main token if changed
            if (previous_token_main != id(chessboard_token_current)) {
              id(perform_lichess_api_call).execute("token_main", id(chessboard_token_current));
              // get account info
              id(perform_lichess_api_call).execute("api_call", "{\"type\": \"getAccountInfoMain\"}");
            }
          } else {
            // if we are not connected, we have to reset the token
            id(oled_show_page_temporary_message).execute("{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"No lichess-api connection\"}", "both", 2000);
          }

  - id: lichess_create_new_game
    mode: single
    then:
      - lambda: |-
          // update sensor
          id(update_raw_position_current).execute();
          id(initial_position_state_update).execute();
          // not during the gave
          if (id(initial_position_state) == 3 && id(mqtt_client)->is_connected()) {
            // stop timer, if running
            id(game_running) = false;
            // we try to close board stream events, if running
            id(lichess_game_id).publish_state("idle");

            // if we have a game running, try to abort all pengling games (TODO: check if we close the stream event in that case)
            id(perform_lichess_api_call).execute("api_call", "{\"type\": \"abortRunningGames\"}");
 
            // Create JSON object
            JsonDocument root;  
            root["type"] = "createGame";   
            root["color"] = id(lichess_seek_color).current_option();     
            root["time_m"] = float(float(id(time_control_duration)) / 60.);
            root["time_s"] = int(round(float(id(time_control_duration)) / 15.)*15) ; // closes value to a multiple of 15
            root["increment"] = int(id(time_control_increment));            
            if (id(lichess_seek_rated).current_option() == "rated") {
              root["rated"] = true;
            } else {
              root["rated"] = false;
            }
            root["opponentname"] = id(lichess_opponent).current_option();
            root["otb"] = id(lichess_opponent_at_board_select).current_option();

            // the shortest seek posible is 10+0, so we set this time, if shorter time - control is choosen
            if (id(lichess_opponent).current_option() == "random" && id(time_control_duration) < 600 ){              
              id(oled_show_page_temporary_message).execute("{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"Invalid time control. Set the clock to 10+0.\"}", "both", 2000); 
              auto call = id(chess_time_control).make_call();
              call.set_option("Rapid (10+0)");
              call.perform();              
              root["time_m"] = 10;
              root["time_s"] = 600;
              root["increment"] = 0;
            }

            // Convert JSON to string
            std::string json_string;
            serializeJson(root, json_string);

            // just for better representation in web-server
            std::string search = ",";
            std::string replace = ", ";            
            size_t pos = 0;
            while ((pos = json_string.find(search, pos)) != std::string::npos) {
                json_string.replace(pos, search.length(), replace);
                pos += replace.length(); 
            }

            id(display_message_black) = std::string("{\"n_lines\": 2, \"line_0\": \"Waiting for new game ...\", \"line_1\": \"") + id(chess_time_control).current_option() + std::string("\"}");
            id(display_message_white) = std::string("{\"n_lines\": 2, \"line_0\": \"Waiting for new game ...\", \"line_1\": \"") + id(chess_time_control).current_option() + std::string("\"}"); 
            id(oled_show_page_message).execute();

            // force changed state, to be able to call the same request 
            id(perform_lichess_api_call).execute("api_call", json_string);

          } else {
              id(beep_long).execute();
              if (id(mqtt_client)->is_connected()) {
                id(oled_show_page_temporary_message).execute("{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"Set initial position\"}", "both", 2000);   
              } else {
                id(oled_show_page_temporary_message).execute("{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"No lichess-api connection\"}", "both", 2000); 
              }                  
          }

  - id: lichess_drain_queue
    mode: restart   # only one drain loop; restart just ensures it runs
    then:
      - while:
          condition:
            lambda: 'return !id(lichess_queue).empty();'
          then:
            - lambda: |-
                // pop next message
                std::string msg = id(lichess_queue).front();
                id(lichess_queue).pop_front();

                // call your actual handler (make it take a string arg)
                id(lichess_handle_response).execute(msg);

            # optional: tiny yield so Wi-Fi / MQTT stack stays happy
            - delay: 1ms

      - lambda: |-
          id(lichess_draining) = false;  
  
  - id: lichess_handle_response
    parameters:
      json_str: string
    mode: queued
    max_runs: 10
    then:
      - lambda: |-
          // std::string json_str = id(lichess_response).state;

          if (id(debug_mode)) {
              id(perform_lichess_api_call).execute("debug", std::string("Handling response"));
          }

          JsonDocument root;
          deserializeJson(root, json_str);

          if (root["type"].is<std::string>() && root["type"].as<std::string>().length() > 0) {

            if (id(debug_mode)) {
                id(perform_lichess_api_call).execute("debug", std::string("JSON to handle: " + json_str).c_str());
            }

            // #######################################
            // ########### EVENTS ####################
            // #######################################

            // ############# game id info ########
            // #######################################
            if ((root["type"].as<std::string>() == "createdGameId")){
              if (root["status"].as<std::string>() == "seek") {
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"Created game: " + root["id"].as<std::string>() + "\", \"line_1\": \"Waiting to be accepted ...\"}";
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Created game: " + root["id"].as<std::string>() + "\", \"line_1\": \"Waiting to be accepted ...\"}";
              } else if (root["status"].as<std::string>() != "success") {
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + root["error"].as<std::string>() + "\"}";
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"" + root["error"].as<std::string>() + "\"}";
              }
              id(oled_show_page_message).execute();
            }

            // ############# new game started #############
            // #######################################
            if (root["type"].as<std::string>() == "gameStart"){

              if (id(debug_mode)) {
                  id(perform_lichess_api_call).execute("debug", "Triggered by gameStart the gameId is " + root["gameId"].as<std::string>());
              }

              if (id(lichess_tournament_id).state.length() == 8) {
                  id(beep_long).execute();
              } else {
                id(beep_short).execute();
              }

              id(game_running) = true;
              id(white_to_move) = true;
              // we could have some pgn_additionals from last game
              id(pgn_history) = ""; 
              id(last_move_pgn_additional) = "";

              // extract opponents name to be shown on display
              std::string opponent =  root["opponent"].as<std::string>();
              std::string me = id(lichess_account).current_option();
              std::string game_id = root["gameId"].as<std::string>();

              // we start board stream (if not startet by "createGameId" - response)
              id(lichess_game_id).publish_state(game_id);

              if (id(lichess_main_json) != "" ) {
                JsonDocument root_me;
                deserializeJson(root_me, id(lichess_main_json));
                std::string chess_time = id(chess_time_control).current_option();
                if (chess_time.find("Blitz") != std::string::npos) {
                  me += ": " + std::to_string(root_me["blitz"].as<int>());
                } else if (chess_time.find("Classical") != std::string::npos) {
                  me += ": " + std::to_string(root_me["classical"].as<int>());
                } else {
                  me += ": " + std::to_string(root_me["rapid"].as<int>());
                }              
              }

              // we check the white color
              if ( root["color"].as<std::string>() == "white"){ 
                id(lichess_is_my_color_white) = true;
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).current_option() + "\"}";
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + opponent + "\", \"line_1\": \"" + id(chess_time_control).current_option() + "\"}";
              }
              // we check the white color
              if (root["color"].as<std::string>() == "black"){
                id(lichess_is_my_color_white) = false;
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"" + opponent + "\", \"line_1\": \"" + id(chess_time_control).current_option() + "\"}";
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"" + me + "\", \"line_1\": \"" + id(chess_time_control).current_option() + "\"}";
              }

              id(lichess_opponent_name) = opponent;     
              id(oled_show_page_message).execute();

              // rise flag we are in lichess game
              id(lichess_game_running) = true;

            }

            // ############# game finished #############
            // #######################################
            if ((root["type"].as<std::string>() == "gameFinish" ) && (root["gameId"].as<std::string>() == id(lichess_game_id).state)){

                if (id(debug_mode)) {
                    id(perform_lichess_api_call).execute("debug", "Triggered by gameFinish");
                }

                // store the win-state
                std::string curr_game_result = root["win"].as<std::string>();
                std::string state = root["status"].as<std::string>();

                // draw ?
                if (state == "stalemate" || state == "draw") {
                  curr_game_result = "1/2-1/2";
                } 
                
                id(lichess_game_id).publish_state("idle");
                id(inform_game_over).execute(curr_game_result);
                id(post_game_operation).execute();
                id(reset_current_game_values).execute(); 
                
                // if we are in tournament, withdraw the game to set the initial position
                id(lichess_arena_withdraw_by_id).execute();
            }

            // ############# joined new arena tournament #############
            // #######################################
            if ((root["type"].as<std::string>() == "tournamentJoinedByName") && root["id"].is<std::string>() && (root["id"].as<std::string>().length() == 8)){
              if (root["status"].as<std::string>() == "success") {
                id(lichess_tournament_id).publish_state(root["id"].as<std::string>());
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Joined: " + id(lichess_tournament_id).state + "\", \"line_1\": \"Start: " + root["starts_in"].as<std::string>() + "\"}";
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"Joined: " + id(lichess_tournament_id).state + "\", \"line_1\": \"Start: " + root["starts_in"].as<std::string>() + "\"}";    
                id(oled_show_page_message).execute();          
              } else {
                id(beep_long).execute();
                id(oled_show_page_temporary_message).execute("{\"n_lines\": 2, \"line_0\": \"WARNING\", \"line_1\": \"Failed to join\"}", "both", 2000); 
              }                        
            }
            
            // ############# rejoined arena tournament #############
            // #######################################
            if ((root["type"].as<std::string>() == "tournamentJoinedById") && root["id"].is<std::string>() && (root["id"].as<std::string>().length() == 8)){
                id(display_message_black) = "{\"n_lines\": 2, \"line_0\": \"Joined: " + id(lichess_tournament_id).state + "\", \"line_1\": \"Waiting for new game\"}";
                id(display_message_white) = "{\"n_lines\": 2, \"line_0\": \"Joined: " + id(lichess_tournament_id).state + "\", \"line_1\": \"Waiting for new game\"}";
                id(oled_show_page_message).execute();
            }

            // ############# stream event off #############
            // #######################################
            if ((root["type"].as<std::string>() == "streamBoardMain") && root["state"].is<std::string>()){
                // api reseted game_id already within handler, we do it for the board
                id(lichess_game_id).publish_state(root["state"].as<std::string>());
            }

            // #######################################
            // ########### BOARD API #################
            // #######################################

            // ############# account info ########
            // #######################################
            if ((root["type"].as<std::string>() == "accountInfoMain")){
              std::string serialized_json_str = "";
              serializeJson(root, serialized_json_str);  
              id(lichess_main_json) = serialized_json_str;
            }

            // ############# opponent gone #############
            // #######################################
            if ((root["type"].as<std::string>() == "opponentGone") && (root["gone"].as<bool>() == true ) && (root["claimWinInSeconds"].as<int>() == 0) &&  (root["id"].as<std::string>() == id(lichess_game_id).state)  ){
              delay(1000);  // Wait 1s to sync
              // claim victory
              id(perform_lichess_api_call).execute("api_call", "{\"type\": \"claim-victory\"}");            
            }

            // ############# chat line #############
            // #######################################
            if ((root["type"].as<std::string>() == "chatLine") && (root["text"].as<std::string>() != "" ) &&  (root["id"].as<std::string>() == id(lichess_game_id).state) ){

              int maxCharsPerLine = 32;
              std::string part_1 = root["text"].as<std::string>();            
              std::string part_2 = "";
              if (part_1.length() > maxCharsPerLine) {
                part_2 = part_1.substr(maxCharsPerLine, maxCharsPerLine);
                part_1 = part_1.substr(0, maxCharsPerLine);              
              }
              std::string chat_message = "{\"n_lines\": 2, \"line_0\": \"" + part_1 + "\", \"line_1\": \"" + part_2 + "\"}";
              id(oled_show_page_temporary_message).execute(chat_message, "otb", 3000);   
              id(beep_short).execute();      
            }

            // ############# move on board #############
            // #######################################
            if ((root["type"].as<std::string>() == "gameState") && root["state"].is<std::string>() && (root["state"].as<std::string>() == "started") &&  (root["id"].as<std::string>() == id(lichess_game_id).state)){

              if (id(debug_mode)) {
                  id(perform_lichess_api_call).execute("debug", std::string("Triggered by gameState: " + root["last"].as<std::string>()).c_str());
              }
              
              // let the player know about the last move of opponent
              std::string last_move = root["last"].as<std::string>();
              std::string from = last_move.substr(0, 2);
              std::string to = last_move.substr(2, 2);
              int idx_from = id(chess_field_indexes)[from];

              std::string moved_piece = "";
              if (idx_from > -1 && idx_from < 64) {              
                char moved_piece_char = toupper(id(fen_position_previous)[idx_from]);
                if (moved_piece_char != 'P') {
                  moved_piece += moved_piece_char;
                  moved_piece += ":";
                }
              }

              // get number of moves
              bool is_my_turn = (bool)( (root["n"].as<int>() % 2) == int(id(lichess_is_my_color_white)));            

              if (!is_my_turn) { // we want the opponents move
                if( !id(lichess_opponent_at_board)) {
                  // opponent is white and its turn
                  if (!id(lichess_is_my_color_white)){ 
                    id(display_message_black) = "{\"n_lines\": 1, \"line_0\": \"" + moved_piece +  last_move + "\"}";                
                    id(oled_black_acitve_page) = 2;
                    id(beep_short).execute();       
                  } 
                  // opponent is black and its turn
                  if (id(lichess_is_my_color_white)){  
                    id(display_message_white) = "{\"n_lines\": 1, \"line_0\":  \""+ moved_piece  + last_move + "\"}";
                    id(oled_white_acitve_page) = 2;
                    id(beep_short).execute();
                  }
                } else {
                  // always beep, so we know, the otb-opponent move is accepted by lichess
                  id(beep_short).execute();
                }
              } else if (id(lichess_opponent_at_board)) {
                // always beep, so we know, our  move is accepted by lichess
                id(beep_short).execute();
              }

              // store lichess move
              id(current_move_uci_lichess) = last_move;

              // if my turn, show the clock
              if (id(white_to_move) && is_my_turn){ // I'm white and my turn
                id(oled_white_acitve_page) = 1;
              } 
              
              if (!id(white_to_move) && is_my_turn){  // I'm black and my turn
                id(oled_black_acitve_page) = 1;
              }
              
              // update chessboard clock by values from lichess
              std::string wclk = root["wclk"].as<std::string>();
              std::string bclk = root["bclk"].as<std::string>();

              // set white clock
              size_t pos = wclk.find('+'); // Find the "+" character
              if (pos != std::string::npos) {
                  std::string first_part = wclk.substr(0, pos); // Extract first part
                  id(time_control_timer_white) = std::stoi(first_part); 
                  id(timer_white).update();
              }

              // set black clock
              pos = bclk.find('+'); // Find the "+" character
              if (pos != std::string::npos) {
                  std::string first_part = bclk.substr(0, pos); // Extract first part
                  id(time_control_timer_black) = std::stoi(first_part);
                  id(timer_black).update();
              }   
            
              // draw offer ?
              if ( ((root["wdraw"].as<int>() == 1) && !id(lichess_is_my_color_white)) || ((root["bdraw"].as<int>() == 1) && id(lichess_is_my_color_white)) ) {
                id(beep_long).execute(); 
                id(oled_show_page_temporary_message).execute("{\"n_lines\": 1, \"line_0\": \"DRAW?\"}", "otb", 2000);                          
              }

              // take back offer ?
              if ( ((root["wback"].as<int>() == 1) && !id(lichess_is_my_color_white)) || ((root["bback"].as<int>() == 1) && id(lichess_is_my_color_white)) ) {
                id(beep_long).execute();
                id(oled_show_page_temporary_message).execute("{\"n_lines\": 1, \"line_0\": \"Takeback?\"}", "otb", 2000);                 
              }                        
            }
          }

          id(redraw_displays).execute();

  - id: oled_show_page_clock
    then:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.show_main:   my_menu
            - display_menu.hide:  my_menu
      - lambda: |-
            if (!id(lichess_game_running) || id(lichess_opponent_at_board) || !id(game_running)) {
              id(oled_white_acitve_page) = 1;
              id(oled_black_acitve_page) = 1;
            } else { // at lichess game with online opponent, we dont want to show clock
              if (id(lichess_is_my_color_white) ) { // I'm white
                id(oled_white_acitve_page) = 1;
                // if we've been in menu, switch to messages
                if (id(oled_black_acitve_page) == 0) {
                  id(oled_black_acitve_page) = 2;
                }
              } else { // I'm black
                id(oled_black_acitve_page) = 1;
                // if we've been in menu, switch to messages
                if (id(oled_white_acitve_page) == 0) {
                  id(oled_white_acitve_page) = 2;
                }
              }
            }            
      - component.update: oled_white
      - component.update: oled_black

  - id: oled_show_page_menu
    then:
      - if:
          condition:
            not:
              display_menu.is_active: my_menu
          then:
            - display_menu.show:  my_menu    
      - lambda: |-
            id(oled_white_acitve_page) = 0;
            id(oled_black_acitve_page) = 0;
      - component.update: oled_white
      - component.update: oled_black

  - id: oled_show_page_message
    then:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.show_main:   my_menu
            - display_menu.hide:  my_menu
      - lambda: |-
            id(oled_white_acitve_page) = 2;
            id(oled_black_acitve_page) = 2;
      - component.update: oled_white
      - component.update: oled_black

    # color: "white", "black", "both", "otb" (player otb is selected, lichess games only)
  - id: oled_show_page_temporary_message
    parameters:      
      message: string
      color: string
      duration_ms: int 
    then:
      - lambda: |-
            if (color == "otb") {
              if(id(lichess_game_running) && id(lichess_is_my_color_white)) {
                color = "white";
              }
              if(id(lichess_game_running) && !id(lichess_is_my_color_white)) {
                color = "black";
              }
              // we dont really need that case, makes not so much sence
              if(id(lichess_game_running) && id(lichess_opponent_at_board)) {
                color = "both";
              }
            }

            // store previous values
            std::string message_w = id(display_message_white);
            std::string message_b = id(display_message_black);
            int page_w = id(oled_white_acitve_page);
            int page_b = id(oled_black_acitve_page);

            if (color == "white" || color == "both") {
              id(display_message_white) = message; 
              id(oled_white_acitve_page) = 2;
            }
            if (color == "black" || color == "both") {
              id(display_message_black) = message; 
              id(oled_black_acitve_page) = 2;
            }
            // show temporary message
            id(redraw_displays).execute();
            // wait
            delay(duration_ms);
            // restore previous message
            if (color == "white" || color == "both") {
              id(display_message_white) = message_w; 
              id(oled_white_acitve_page) = page_w;
            }
            if (color == "black" || color == "both") {
              id(display_message_black) = message_b; 
              id(oled_black_acitve_page) = page_b;
            }
            // show previous message
            id(redraw_displays).execute();
  
  - id: led_update_initial_position_state
    then:
      - lambda: |-
          // if game not running only (or menu)
          if (!id(game_running)) {
            // turn all leds off
            id(led_all_turn_off).execute();
            // extract the current state of init position
            // 0 - non, 1 - black, 2 - white, 3 - both are set
            int value = id(initial_position_state);
            // black -> red if not set
            if (value & 0b01) {
              id(led_black_blue).execute(); 
            } else {
              id(led_black_red).execute();
            }
            // white -> red if not set
            if (value & 0b10) {
              id(led_white_blue).execute();
            } else {
              id(led_white_red).execute();
            }
          }

  - id: led_update_color_to_move
    then:
      - lambda: |-
          // update only if game is running
          if (id(game_running)) {
            // white to move
            if (id(white_to_move)) { 
              id(led_black_turn_off).execute();           
              id(led_white_blue).execute();              
            } else { // black to move
              id(led_white_turn_off).execute();
              id(led_black_blue).execute();
            }
          }
          
  - id: led_update_valid_move
    then:
      - lambda: |-
          // update only if game is running
          // if no valid move found, rise flag
          if (id(valid_move)) {
            // update leds
            if (id(white_to_move)) {
              id(led_black_turn_off).execute();
              id(led_white_green).execute();
            } else {
              id(led_black_green).execute(); 
              id(led_white_turn_off).execute();          
            }
          } else {
            if (id(white_to_move)) {
              id(led_white_red).execute();
              id(led_black_turn_off).execute();
            } else {
              id(led_black_red).execute();  
              id(led_white_turn_off).execute();             
            }
          }


  - id: led_white_red
    then: 
      - lambda: |-
          // r
          if (!id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_on();
          }
          // g
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          // b
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }
 
  - id: led_white_green
    then: 
      - lambda: |-
          // r
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          // g
          if (!id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_on();
          } 
          // b
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }

  - id: led_white_blue
    then: 
      - lambda: |-
          // r
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          // g
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          // b
          if (!id(led_white_to_move).state) {
            id(led_white_to_move).turn_on();
          }

  - id: led_black_red
    then: 
      - lambda: |-
          // r
          if (!id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_on();
          }
          // g
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          } 
          // b
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }
 
  - id: led_black_green
    then: 
      - lambda: |-
          // r
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          // g
          if (!id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_on();
          } 
          // b
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }

  - id: led_black_blue
    then: 
      - lambda: |-
          // r
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          // g
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          } 
          // b
          if (!id(led_black_to_move).state) {
            id(led_black_to_move).turn_on();
          }

  - id: led_all_turn_off
    then:
      - lambda: |-
          id(led_white_turn_off).execute();
          id(led_black_turn_off).execute(); 

  - id: led_white_turn_off
    then:
      - lambda: |-
          if (id(led_white_to_move).state) {
            id(led_white_to_move).turn_off();
          }
          if (id(led_white_nonvalid_move).state) {
            id(led_white_nonvalid_move).turn_off();
          }
          if (id(led_white_valid_move).state) {
            id(led_white_valid_move).turn_off();
          } 
          
  - id: led_black_turn_off
    then:
      - lambda: |-
          if (id(led_black_to_move).state) {
            id(led_black_to_move).turn_off();
          }
          if (id(led_black_nonvalid_move).state) {
            id(led_black_nonvalid_move).turn_off();
          }
          if (id(led_black_valid_move).state) {
            id(led_black_valid_move).turn_off();
          }